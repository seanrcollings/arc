from abc import ABC, abstractmethod
import arc._utils as util
from arc.script import Script
from arc.config import Config
from arc.errors import ExecutionError, ScriptError


class ScriptContainer(ABC):
    """Parent class of CLI and Utility"""

    def __init__(self, arcfile=None):
        self.scripts = {}
        self.script("help")(self.helper)

        if arcfile is not None and not Config._loaded:
            Config.load_arc_file(arcfile)

    @abstractmethod
    def __call__(self):
        pass

    def script(self, *args, **kwargs):
        """Installs a script to the container
        Creates a script object, appends it to
        the script container

        :returns: the provided function, for decorator chaining. As such,
            you can give one function multiple script names
        """

        def decorator(function):
            if "function" in kwargs:
                raise ScriptError(
                    "Keyword 'function' not acceptable in script decorator"
                )
            script = Script(*args, **kwargs, function=function)
            self.scripts[script.name] = script
            util.logger(f"Registered '{script.name}' script", state="debug")
            return function

        return decorator

    @util.timer
    def execute(self, script_node):
        """Executes the script from the user's command

        :param script_node: ScriptNode object generated by the parser
            contains both the options and flags for the script

        :excepts ExecutionError: Raised during the execution of a script anytime
            bad data is passed or something unexpected happens
        """

        if script_node.name not in self.scripts:
            raise ScriptError("That command does not exist")

        script = self.scripts[script_node.name]
        try:
            script(options=script_node.options, flags=script_node.flags)
        except ExecutionError as e:
            print(e)

    @abstractmethod
    def helper(self):
        pass

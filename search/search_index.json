{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 arc is a tool for building declarative, and highly extendable CLI applications for Python ^3.10. Features \u00b6 arc's features include: Command line Arguments, Options, and Flags - Using Python function arguments Data Validation - Via Python type hints Subcommands - For breaking functionality of your CLI into discrete components Documentation - Automatic --help generation from your command definitons Developer Extension - Middleware for extending the functionality of your CLI User Extension - Plugin support for extending the functionality of your CLI Installation \u00b6 arc can be installed with pip $ pip install arc-cli Example \u00b6 To start off, here's a simple example application that can be used to greet someone examples/hello.py import arc @arc . command def hello ( name : str ): \"\"\"Greets someone by name\"\"\" arc . print ( f \"Hello { name } !\" ) hello () Tip The above example, and all examples in this documentation are complete and should run as-is. Additionally all examples are available in the source repo $ python hello.py Joseph Hello Joseph! Automatic Documentation \u00b6 And a quick demonstration of the documention generation: $ python hello.py --help USAGE hello.py [-h] name DESCRIPTION Greets someone by name ARGUMENTS name OPTIONS --help (-h) Displays this help message Pretty cool, huh? arc will pull all of the information that it needs from your function docstrings and parameter definitons. Check out the Usage section for more information on how to use arc . Playground \u00b6 You can check out the playground to try out arc in your browser.","title":"Home"},{"location":"#overview","text":"arc is a tool for building declarative, and highly extendable CLI applications for Python ^3.10.","title":"Overview"},{"location":"#features","text":"arc's features include: Command line Arguments, Options, and Flags - Using Python function arguments Data Validation - Via Python type hints Subcommands - For breaking functionality of your CLI into discrete components Documentation - Automatic --help generation from your command definitons Developer Extension - Middleware for extending the functionality of your CLI User Extension - Plugin support for extending the functionality of your CLI","title":"Features"},{"location":"#installation","text":"arc can be installed with pip $ pip install arc-cli","title":"Installation"},{"location":"#example","text":"To start off, here's a simple example application that can be used to greet someone examples/hello.py import arc @arc . command def hello ( name : str ): \"\"\"Greets someone by name\"\"\" arc . print ( f \"Hello { name } !\" ) hello () Tip The above example, and all examples in this documentation are complete and should run as-is. Additionally all examples are available in the source repo $ python hello.py Joseph Hello Joseph!","title":"Example"},{"location":"#automatic-documentation","text":"And a quick demonstration of the documention generation: $ python hello.py --help USAGE hello.py [-h] name DESCRIPTION Greets someone by name ARGUMENTS name OPTIONS --help (-h) Displays this help message Pretty cool, huh? arc will pull all of the information that it needs from your function docstrings and parameter definitons. Check out the Usage section for more information on how to use arc .","title":"Automatic Documentation"},{"location":"#playground","text":"You can check out the playground to try out arc in your browser.","title":"Playground"},{"location":"examples/grep-clone/","text":"This tutorial will be all about writing a simple grep clone in arc . When completed our grep clone will be able to: Accept a PATTERN to search for Accept any number of FILES to search Ouptut lines of the FILES that match the PATTERN to stdout, with coloring 1. Setup \u00b6 To begin with we need to scaffold the project Install arc if you haven't already $ pip install arc-cli And create a file called grep_clone.py that contains the following: examples/grep_clone/1_grep_clone.py import arc @arc . command def command (): arc . print ( \"hello there!\" ) command () This is just some simple scaffolding to get us started. Run it to make sure eveything is in order. $ python grep.py hello there! $ python grep.py --help USAGE grep.py [-h] OPTIONS --help (-h) Displays this help message 2. Arguments \u00b6 Next, we're going to want to add arguments to the command. For now, we'll only be implementing the PATTERN and FILES arguments. All of grep's many flags will be left alone for now. examples/grep_clone/2_grep_clone.py import re import arc from arc import types @arc . command def command ( pattern : re . Pattern , files : list [ types . File . Read ]): arc . print ( pattern ) arc . print ( files ) command () $ python grep.py ^ [ \\\\ d+ ] docs/docs/index.md docs/docs/usage/intro.md re.compile('^[\\\\d+]') [<_io.TextIOWrapper name='docs/docs/index.md' mode='r' encoding='UTF-8'>, <_io.TextIOWrapper name='docs/docs/usage/intro.md' mode='r' encoding='UTF-8'>] As you can see, we've already got a validated regex pattern, and file handles to each of the specified files. 3. Functionality \u00b6 With type handling / data validation already out of the way, the implentation will be fairly straightfoward. examples/grep_clone/3_grep_clone.py import re import arc from arc import color from arc.types import File @arc . command def grep ( pattern : re . Pattern , files : list [ File . Read ]): for file in files : # Iterate over all the files for line in file . readlines (): # Iterate over all the line in the file if match := pattern . search ( line ): # check for a match # If there is a match, highlight it colored = pattern . sub ( color . fg . RED + match . group () + color . fx . CLEAR , line , ) arc . print ( colored , end = \"\" ) grep () Let's run this over a couple of arc's documentation files searching for references to arc $ python grep.py arc docs/docs/index.md docs/docs/usage/intro.md *arc* is a tool for building declarative, and highly extendable CLI applications for Python ^3.10. *arc's* features include: *arc* can be installed with pip $ pip install arc-cli [source repo](https://github.com/seanrcollings/arc/tree/master/docs/examples) Pretty cool, huh? *arc* will pull *all* of the information that it needs from your [function docstrings and parameter definitons.](usage/documentation-generation.md) Check out the [Usage](./usage/intro.md) section for more information on how to use *arc*. You can check out the [playground](https://arc-playground.seancollings.dev) to try out *arc* in your browser. This intro serves as a quick starting off point to see some of *arc's* most useful features. The simplest *arc* program would look like this 1. `#!python @arc.command` is a Python decorator that transforms a function into an *arc* command. *arc* uses argument type hints for data validation / conversion. For example, say we want to write a command that can sum two numbers together: if the input fails to validate, *arc* will report a user-friendly error for the type - if a parameter does not specify a type, *arc* implicitly types it as `#!python str`. - **All** builtin types are supported by *arc*, and many stdlib types *arc* is easily configurable via the `#!python arc.configure()` function. *View the [reference](../reference/config.md#arc.config.configure) for details on all the configuration options*","title":"Grep clone"},{"location":"examples/grep-clone/#1-setup","text":"To begin with we need to scaffold the project Install arc if you haven't already $ pip install arc-cli And create a file called grep_clone.py that contains the following: examples/grep_clone/1_grep_clone.py import arc @arc . command def command (): arc . print ( \"hello there!\" ) command () This is just some simple scaffolding to get us started. Run it to make sure eveything is in order. $ python grep.py hello there! $ python grep.py --help USAGE grep.py [-h] OPTIONS --help (-h) Displays this help message","title":"1. Setup"},{"location":"examples/grep-clone/#2-arguments","text":"Next, we're going to want to add arguments to the command. For now, we'll only be implementing the PATTERN and FILES arguments. All of grep's many flags will be left alone for now. examples/grep_clone/2_grep_clone.py import re import arc from arc import types @arc . command def command ( pattern : re . Pattern , files : list [ types . File . Read ]): arc . print ( pattern ) arc . print ( files ) command () $ python grep.py ^ [ \\\\ d+ ] docs/docs/index.md docs/docs/usage/intro.md re.compile('^[\\\\d+]') [<_io.TextIOWrapper name='docs/docs/index.md' mode='r' encoding='UTF-8'>, <_io.TextIOWrapper name='docs/docs/usage/intro.md' mode='r' encoding='UTF-8'>] As you can see, we've already got a validated regex pattern, and file handles to each of the specified files.","title":"2. Arguments"},{"location":"examples/grep-clone/#3-functionality","text":"With type handling / data validation already out of the way, the implentation will be fairly straightfoward. examples/grep_clone/3_grep_clone.py import re import arc from arc import color from arc.types import File @arc . command def grep ( pattern : re . Pattern , files : list [ File . Read ]): for file in files : # Iterate over all the files for line in file . readlines (): # Iterate over all the line in the file if match := pattern . search ( line ): # check for a match # If there is a match, highlight it colored = pattern . sub ( color . fg . RED + match . group () + color . fx . CLEAR , line , ) arc . print ( colored , end = \"\" ) grep () Let's run this over a couple of arc's documentation files searching for references to arc $ python grep.py arc docs/docs/index.md docs/docs/usage/intro.md *arc* is a tool for building declarative, and highly extendable CLI applications for Python ^3.10. *arc's* features include: *arc* can be installed with pip $ pip install arc-cli [source repo](https://github.com/seanrcollings/arc/tree/master/docs/examples) Pretty cool, huh? *arc* will pull *all* of the information that it needs from your [function docstrings and parameter definitons.](usage/documentation-generation.md) Check out the [Usage](./usage/intro.md) section for more information on how to use *arc*. You can check out the [playground](https://arc-playground.seancollings.dev) to try out *arc* in your browser. This intro serves as a quick starting off point to see some of *arc's* most useful features. The simplest *arc* program would look like this 1. `#!python @arc.command` is a Python decorator that transforms a function into an *arc* command. *arc* uses argument type hints for data validation / conversion. For example, say we want to write a command that can sum two numbers together: if the input fails to validate, *arc* will report a user-friendly error for the type - if a parameter does not specify a type, *arc* implicitly types it as `#!python str`. - **All** builtin types are supported by *arc*, and many stdlib types *arc* is easily configurable via the `#!python arc.configure()` function. *View the [reference](../reference/config.md#arc.config.configure) for details on all the configuration options*","title":"3. Functionality"},{"location":"reference/autocompletions/","text":"autocompletions \u00b6 CompletionType \u00b6 Constants for common completion types Source code in /home/runner/work/arc/arc/arc/autocompletions.py 46 47 48 49 50 51 52 53 class CompletionType : \"\"\"Constants for common completion types\"\"\" FILE = \"file\" DIR = \"dir\" USERS = \"users\" GROUPS = \"groups\" PLAIN = \"plain\" ShellCompletion \u00b6 Source code in /home/runner/work/arc/arc/arc/autocompletions.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class ShellCompletion : template : t . ClassVar [ str ] shells : dict [ str , type [ \"ShellCompletion\" ]] = {} def __init__ ( self , command : Command , info : CompletionInfo ): self . command = command self . info = info self . command_name = self . command . name def __init_subclass__ ( cls , name : str ) -> None : ShellCompletion . shells [ name ] = cls @property def completion_vars ( self ) -> dict [ str , t . Any ]: return { \"name_exe\" : \"python cli.py\" if os . getenv ( \"ARC_DEVELOPMENT\" ) else self . command_name , \"name_com\" : self . command_name , \"func_name\" : f \"_ { self . command_name } _completions\" . replace ( \"-\" , \"_\" ), \"completion_var\" : self . completion_var , } @property def completion_var ( self ) -> str : return f \"_ { self . command_name } _complete\" . upper () . replace ( \"-\" , \"_\" ) def should_complete ( self ) -> bool : return os . getenv ( self . completion_var ) is not None def source ( self ) -> str : \"\"\"Returns the script for the paricular lanuage\"\"\" return self . template . format ( ** self . completion_vars ) def complete ( self ) -> str : \"\"\"Actually provides the completions\"\"\" return \"\" def format_completion ( self , comp : Completion ) -> str : return \"\" @classmethod def run ( cls , shell : str , command : Command ) -> str : info = CompletionInfo . from_env () if shell not in cls . shells : raise errors . ArgumentError ( f \"Unsupported shell: { shell } . \" f \"Supported shells: { Join . with_comma ( cls . shells ) } \" ) comp : ShellCompletion = cls . shells [ shell ]( command , info ) with open ( \"completions.log\" , \"w+\" ) as f , redirect_stderr ( f ): res = comp . complete () if comp . should_complete () else comp . source () f . write ( \" \\n \" ) f . write ( \" \" . join ( info . words )) f . write ( \" \\n \" ) f . write ( res ) f . write ( \" \\n\\n \" ) return res complete () \u00b6 Actually provides the completions Source code in /home/runner/work/arc/arc/arc/autocompletions.py 98 99 100 def complete ( self ) -> str : \"\"\"Actually provides the completions\"\"\" return \"\" source () \u00b6 Returns the script for the paricular lanuage Source code in /home/runner/work/arc/arc/arc/autocompletions.py 94 95 96 def source ( self ) -> str : \"\"\"Returns the script for the paricular lanuage\"\"\" return self . template . format ( ** self . completion_vars ) get_completions ( obj , info , * args , ** kwargs ) \u00b6 Gets the completions for a particular object that supports the CompletionProtocol Source code in /home/runner/work/arc/arc/arc/autocompletions.py 16 17 18 19 20 21 22 23 24 25 26 27 28 def get_completions ( obj : CompletionProtocol , info : CompletionInfo , * args : t . Any , ** kwargs : t . Any , ) -> list [ Completion ]: \"\"\"Gets the completions for a particular object that supports the `CompletionProtocol`\"\"\" comps = obj . __completions__ ( info , * args , ** kwargs ) if comps is None : comps = [] else : comps = list ( comps ) return comps","title":"autocompletions"},{"location":"reference/autocompletions/#autocompletions","text":"","title":"autocompletions"},{"location":"reference/autocompletions/#arc.autocompletions.CompletionType","text":"Constants for common completion types Source code in /home/runner/work/arc/arc/arc/autocompletions.py 46 47 48 49 50 51 52 53 class CompletionType : \"\"\"Constants for common completion types\"\"\" FILE = \"file\" DIR = \"dir\" USERS = \"users\" GROUPS = \"groups\" PLAIN = \"plain\"","title":"CompletionType"},{"location":"reference/autocompletions/#arc.autocompletions.ShellCompletion","text":"Source code in /home/runner/work/arc/arc/arc/autocompletions.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class ShellCompletion : template : t . ClassVar [ str ] shells : dict [ str , type [ \"ShellCompletion\" ]] = {} def __init__ ( self , command : Command , info : CompletionInfo ): self . command = command self . info = info self . command_name = self . command . name def __init_subclass__ ( cls , name : str ) -> None : ShellCompletion . shells [ name ] = cls @property def completion_vars ( self ) -> dict [ str , t . Any ]: return { \"name_exe\" : \"python cli.py\" if os . getenv ( \"ARC_DEVELOPMENT\" ) else self . command_name , \"name_com\" : self . command_name , \"func_name\" : f \"_ { self . command_name } _completions\" . replace ( \"-\" , \"_\" ), \"completion_var\" : self . completion_var , } @property def completion_var ( self ) -> str : return f \"_ { self . command_name } _complete\" . upper () . replace ( \"-\" , \"_\" ) def should_complete ( self ) -> bool : return os . getenv ( self . completion_var ) is not None def source ( self ) -> str : \"\"\"Returns the script for the paricular lanuage\"\"\" return self . template . format ( ** self . completion_vars ) def complete ( self ) -> str : \"\"\"Actually provides the completions\"\"\" return \"\" def format_completion ( self , comp : Completion ) -> str : return \"\" @classmethod def run ( cls , shell : str , command : Command ) -> str : info = CompletionInfo . from_env () if shell not in cls . shells : raise errors . ArgumentError ( f \"Unsupported shell: { shell } . \" f \"Supported shells: { Join . with_comma ( cls . shells ) } \" ) comp : ShellCompletion = cls . shells [ shell ]( command , info ) with open ( \"completions.log\" , \"w+\" ) as f , redirect_stderr ( f ): res = comp . complete () if comp . should_complete () else comp . source () f . write ( \" \\n \" ) f . write ( \" \" . join ( info . words )) f . write ( \" \\n \" ) f . write ( res ) f . write ( \" \\n\\n \" ) return res","title":"ShellCompletion"},{"location":"reference/autocompletions/#arc.autocompletions.ShellCompletion.complete","text":"Actually provides the completions Source code in /home/runner/work/arc/arc/arc/autocompletions.py 98 99 100 def complete ( self ) -> str : \"\"\"Actually provides the completions\"\"\" return \"\"","title":"complete()"},{"location":"reference/autocompletions/#arc.autocompletions.ShellCompletion.source","text":"Returns the script for the paricular lanuage Source code in /home/runner/work/arc/arc/arc/autocompletions.py 94 95 96 def source ( self ) -> str : \"\"\"Returns the script for the paricular lanuage\"\"\" return self . template . format ( ** self . completion_vars )","title":"source()"},{"location":"reference/autocompletions/#arc.autocompletions.get_completions","text":"Gets the completions for a particular object that supports the CompletionProtocol Source code in /home/runner/work/arc/arc/arc/autocompletions.py 16 17 18 19 20 21 22 23 24 25 26 27 28 def get_completions ( obj : CompletionProtocol , info : CompletionInfo , * args : t . Any , ** kwargs : t . Any , ) -> list [ Completion ]: \"\"\"Gets the completions for a particular object that supports the `CompletionProtocol`\"\"\" comps = obj . __completions__ ( info , * args , ** kwargs ) if comps is None : comps = [] else : comps = list ( comps ) return comps","title":"get_completions()"},{"location":"reference/color/","text":"color \u00b6 Module re-exports the relavent items from the ansi module","title":"color"},{"location":"reference/color/#color","text":"Module re-exports the relavent items from the ansi module","title":"color"},{"location":"reference/config/","text":"config \u00b6 ColorConfig dataclass \u00b6 Configures Colors for the application Source code in /home/runner/work/arc/arc/arc/config.py 20 21 22 23 24 25 26 27 @dataclass class ColorConfig : \"\"\"Configures Colors for the application\"\"\" error : str = fg . RED highlight : str = fg . YELLOW accent : str = fg . ARC_BLUE subtle : str = fg . GREY Config dataclass \u00b6 arc's Config object. A single global instance of this class is created, then used where it is needed Source code in /home/runner/work/arc/arc/arc/config.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 @dataclass class Config : \"\"\"arc's Config object. A single global instance of this class is created, then used where it is needed\"\"\" environment : at . Env = \"production\" transform_snake_case : bool = True env_prefix : str = \"\" config_env_prefix : str = \"ARC_\" load_env : bool = True version : str | SemVer | None = None autocomplete : bool = False allow_unrecognized_args : bool = False debug : bool = False prompt : Prompt = field ( default_factory = Prompt ) suggest : SuggestionConfig = field ( default_factory = SuggestionConfig ) links : LinksConfig = field ( default_factory = LinksConfig ) present : PresentConfig = field ( default_factory = PresentConfig ) plugins : PluginConfig = field ( default_factory = PluginConfig ) extra : dict [ str , t . Any ] = field ( default_factory = dict ) def __post_init__ ( self ) -> None : if self . load_env : self . _load_from_env () @classmethod def load ( cls ) -> \"Config\" : \"\"\"Access the Global `Config` instance\"\"\" global _config if not _config : _config = cls () return _config def update ( self , ** kwargs : t . Any ) -> None : for key , value in kwargs . items (): if value is not None : setattr ( self , key , value ) def _load_from_env ( self ) -> None : env = os . environ . get ( f \" { self . config_env_prefix } ENVIRONMENT\" , \"\" ) . lower () if env in ( \"production\" , \"development\" , \"test\" ): self . environment = t . cast ( at . Env , env ) if os . environ . get ( f \" { self . config_env_prefix } DEBUG\" , \"\" ) . lower () == \"true\" : self . debug = True @classmethod def __depends__ ( cls , ctx : Context ) -> Config : return ctx . config load () classmethod \u00b6 Access the Global Config instance Source code in /home/runner/work/arc/arc/arc/config.py 112 113 114 115 116 117 118 119 120 @classmethod def load ( cls ) -> \"Config\" : \"\"\"Access the Global `Config` instance\"\"\" global _config if not _config : _config = cls () return _config LinksConfig dataclass \u00b6 Configures Links for the application Source code in /home/runner/work/arc/arc/arc/config.py 45 46 47 48 49 @dataclass class LinksConfig : \"\"\"Configures Links for the application\"\"\" bug : str | None = None PluginConfig dataclass \u00b6 Configures Plugins locations for the application Source code in /home/runner/work/arc/arc/arc/config.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @dataclass class PluginConfig : \"\"\"Configures Plugins locations for the application\"\"\" paths : list [ str ] = field ( default_factory = list ) \"\"\"List of paths to search for plugins. These paths will be searched for python modules that contain a `plugin` function. If the file does not exist, or the function is not found, it will be ignored The paths provided can be to a specific file, or a directory. If a directory is provided, all files in that directory will be searched for plugins. \"\"\" groups : list [ str ] = field ( default_factory = lambda : [ \"arc.plugins\" ]) \"\"\"List of entrypoint groups to search for plugins. The entrypoint's value must be a callable that accepts a single argument, the `Context` object. Defaults to using the `arc.plugins` entrypoint group \"\"\" entrypoints : list [ str ] = field ( default_factory = list ) \"\"\"List of explicit entrypoints to search for plugins. The entrypoint's value must be a callable that accepts a single argument, the `Context` object. \"\"\" entrypoints : list [ str ] = field ( default_factory = list ) class-attribute instance-attribute \u00b6 List of explicit entrypoints to search for plugins. The entrypoint's value must be a callable that accepts a single argument, the Context object. groups : list [ str ] = field ( default_factory = lambda : [ 'arc.plugins' ]) class-attribute instance-attribute \u00b6 List of entrypoint groups to search for plugins. The entrypoint's value must be a callable that accepts a single argument, the Context object. Defaults to using the arc.plugins entrypoint group paths : list [ str ] = field ( default_factory = list ) class-attribute instance-attribute \u00b6 List of paths to search for plugins. These paths will be searched for python modules that contain a plugin function. If the file does not exist, or the function is not found, it will be ignored The paths provided can be to a specific file, or a directory. If a directory is provided, all files in that directory will be searched for plugins. PresentConfig dataclass \u00b6 Configures the presentation of the application Source code in /home/runner/work/arc/arc/arc/config.py 30 31 32 33 34 35 36 37 38 39 40 41 42 @dataclass class PresentConfig : \"\"\"Configures the presentation of the application\"\"\" indent : str = \" \" * 4 \"\"\"The indent to use for each level of indentation\"\"\" width : int = 80 \"\"\"The default width to present content at. This is used for wrapping text. Will be ignored if the terminal width is smaller\"\"\" color : ColorConfig = field ( default_factory = ColorConfig ) \"\"\"The color configuration for the application\"\"\" formatter : type [ HelpFormatter ] = DefaultHelpFormatter \"\"\"Class to use when formatting help messages\"\"\" color : ColorConfig = field ( default_factory = ColorConfig ) class-attribute instance-attribute \u00b6 The color configuration for the application formatter : type [ HelpFormatter ] = DefaultHelpFormatter class-attribute instance-attribute \u00b6 Class to use when formatting help messages indent : str = ' ' * 4 class-attribute instance-attribute \u00b6 The indent to use for each level of indentation width : int = 80 class-attribute instance-attribute \u00b6 The default width to present content at. This is used for wrapping text. Will be ignored if the terminal width is smaller SuggestionConfig dataclass \u00b6 Configures Suggestiosn for the application Source code in /home/runner/work/arc/arc/arc/config.py 52 53 54 55 56 57 58 @dataclass class SuggestionConfig : \"\"\"Configures Suggestiosn for the application\"\"\" commands : bool = True params : bool = True distance : int = 2 configure ( * , version = None , environment = None , transform_snake_case = None , suggest = None , env_prefix = None , config_env_prefix = None , load_env = None , prompt = None , autocomplete = None , allow_unrecognized_args = None , debug = None , links = None , present = None , plugins = None , ** kwargs ) \u00b6 Function for updating global arc configuration Parameters: Name Type Description Default version str | SemVer Version string to display with --version None environment str The current environment, either production or development . Defaults to production . When in development mode, the arc logger is set to level logging.INFO None transform_snake_case bool Transform snake_case to kebab-case . Defaults to True . None env_prefix str A prefix to use when selecting values for parameters from enviroment variables. Will be combined with the name specified by parameter. None config_env_prefix str A prefix to use when selecting values from enviroment for the configuration. None load_env bool Enable / disable loading config values from environment variables. Currently, arc can only load environment and debug from environment variables. None prompt Prompt A prompt object will be used when prompting for parameter values. Is also made available via Context.prompt . None autocomplete bool Enable / disable command line completions for this app. Currently the default is False None allow_unrecognized_args bool arc will not error when there are arguments provided that arc does not recognize. Their values will be stored in the context under the key arc.parse.extra . Defaults to False None debug bool enable / disable arc debug logs. None present PresentConfig set the presentation configuration for arc None suggest SuggestConfig configure the settings for suggesting replacements when arc does not recognize a command / parameter None links LinksConfig configure the links that arc may use in some output None Source code in /home/runner/work/arc/arc/arc/config.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def configure ( * , version : str | None = None , environment : at . Env | None = None , transform_snake_case : bool | None = None , suggest : SuggestionConfig | None = None , env_prefix : str | None = None , config_env_prefix : str | None = None , load_env : bool | None = None , prompt : Prompt | None = None , autocomplete : bool | None = None , allow_unrecognized_args : bool | None = None , debug : bool | None = None , links : LinksConfig | None = None , present : PresentConfig | None = None , plugins : PluginConfig | None = None , ** kwargs : t . Any , ) -> None : \"\"\"Function for updating global `arc` configuration Args: version (str | SemVer, optional): Version string to display with `--version` environment (str, optional): The current environment, either `production` or `development`. Defaults to `production`. When in `development` mode, the arc logger is set to level `logging.INFO` transform_snake_case (bool, optional): Transform `snake_case` to `kebab-case`. Defaults to `True`. env_prefix (str, optional): A prefix to use when selecting values for parameters from enviroment variables. Will be combined with the name specified by parameter. config_env_prefix (str, optional): A prefix to use when selecting values from enviroment for the configuration. load_env (bool, optional): Enable / disable loading config values from environment variables. Currently, arc can only load `environment` and `debug` from environment variables. prompt (Prompt, optional): A prompt object will be used when prompting for parameter values. Is also made available via `Context.prompt`. autocomplete (bool, optional): Enable / disable command line completions for this app. Currently the default is `False` allow_unrecognized_args (bool, optional): arc will not error when there are arguments provided that arc does not recognize. Their values will be stored in the context under the key `arc.parse.extra`. Defaults to `False` debug (bool, optional): enable / disable arc debug logs. present (PresentConfig, optional): set the presentation configuration for arc suggest (SuggestConfig, optional): configure the settings for suggesting replacements when arc does not recognize a command / parameter links (LinksConfig, optional): configure the links that arc may use in some output \"\"\" data : dict [ str , t . Any ] = { \"version\" : version , \"environment\" : environment , \"transform_snake_case\" : transform_snake_case , \"suggestions\" : suggest , \"env_prefix\" : env_prefix , \"config_env_prefix\" : config_env_prefix , \"load_env\" : load_env , \"prompt\" : prompt , \"autocomplete\" : autocomplete , \"allow_unrecognized_args\" : allow_unrecognized_args , \"debug\" : debug , \"links\" : links , \"present\" : present , \"plugins\" : plugins , \"extra\" : kwargs or None , } config = Config . load () config . update ( ** data )","title":"config"},{"location":"reference/config/#config","text":"","title":"config"},{"location":"reference/config/#arc.config.ColorConfig","text":"Configures Colors for the application Source code in /home/runner/work/arc/arc/arc/config.py 20 21 22 23 24 25 26 27 @dataclass class ColorConfig : \"\"\"Configures Colors for the application\"\"\" error : str = fg . RED highlight : str = fg . YELLOW accent : str = fg . ARC_BLUE subtle : str = fg . GREY","title":"ColorConfig"},{"location":"reference/config/#arc.config.Config","text":"arc's Config object. A single global instance of this class is created, then used where it is needed Source code in /home/runner/work/arc/arc/arc/config.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 @dataclass class Config : \"\"\"arc's Config object. A single global instance of this class is created, then used where it is needed\"\"\" environment : at . Env = \"production\" transform_snake_case : bool = True env_prefix : str = \"\" config_env_prefix : str = \"ARC_\" load_env : bool = True version : str | SemVer | None = None autocomplete : bool = False allow_unrecognized_args : bool = False debug : bool = False prompt : Prompt = field ( default_factory = Prompt ) suggest : SuggestionConfig = field ( default_factory = SuggestionConfig ) links : LinksConfig = field ( default_factory = LinksConfig ) present : PresentConfig = field ( default_factory = PresentConfig ) plugins : PluginConfig = field ( default_factory = PluginConfig ) extra : dict [ str , t . Any ] = field ( default_factory = dict ) def __post_init__ ( self ) -> None : if self . load_env : self . _load_from_env () @classmethod def load ( cls ) -> \"Config\" : \"\"\"Access the Global `Config` instance\"\"\" global _config if not _config : _config = cls () return _config def update ( self , ** kwargs : t . Any ) -> None : for key , value in kwargs . items (): if value is not None : setattr ( self , key , value ) def _load_from_env ( self ) -> None : env = os . environ . get ( f \" { self . config_env_prefix } ENVIRONMENT\" , \"\" ) . lower () if env in ( \"production\" , \"development\" , \"test\" ): self . environment = t . cast ( at . Env , env ) if os . environ . get ( f \" { self . config_env_prefix } DEBUG\" , \"\" ) . lower () == \"true\" : self . debug = True @classmethod def __depends__ ( cls , ctx : Context ) -> Config : return ctx . config","title":"Config"},{"location":"reference/config/#arc.config.Config.load","text":"Access the Global Config instance Source code in /home/runner/work/arc/arc/arc/config.py 112 113 114 115 116 117 118 119 120 @classmethod def load ( cls ) -> \"Config\" : \"\"\"Access the Global `Config` instance\"\"\" global _config if not _config : _config = cls () return _config","title":"load()"},{"location":"reference/config/#arc.config.LinksConfig","text":"Configures Links for the application Source code in /home/runner/work/arc/arc/arc/config.py 45 46 47 48 49 @dataclass class LinksConfig : \"\"\"Configures Links for the application\"\"\" bug : str | None = None","title":"LinksConfig"},{"location":"reference/config/#arc.config.PluginConfig","text":"Configures Plugins locations for the application Source code in /home/runner/work/arc/arc/arc/config.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @dataclass class PluginConfig : \"\"\"Configures Plugins locations for the application\"\"\" paths : list [ str ] = field ( default_factory = list ) \"\"\"List of paths to search for plugins. These paths will be searched for python modules that contain a `plugin` function. If the file does not exist, or the function is not found, it will be ignored The paths provided can be to a specific file, or a directory. If a directory is provided, all files in that directory will be searched for plugins. \"\"\" groups : list [ str ] = field ( default_factory = lambda : [ \"arc.plugins\" ]) \"\"\"List of entrypoint groups to search for plugins. The entrypoint's value must be a callable that accepts a single argument, the `Context` object. Defaults to using the `arc.plugins` entrypoint group \"\"\" entrypoints : list [ str ] = field ( default_factory = list ) \"\"\"List of explicit entrypoints to search for plugins. The entrypoint's value must be a callable that accepts a single argument, the `Context` object. \"\"\"","title":"PluginConfig"},{"location":"reference/config/#arc.config.PluginConfig.entrypoints","text":"List of explicit entrypoints to search for plugins. The entrypoint's value must be a callable that accepts a single argument, the Context object.","title":"entrypoints"},{"location":"reference/config/#arc.config.PluginConfig.groups","text":"List of entrypoint groups to search for plugins. The entrypoint's value must be a callable that accepts a single argument, the Context object. Defaults to using the arc.plugins entrypoint group","title":"groups"},{"location":"reference/config/#arc.config.PluginConfig.paths","text":"List of paths to search for plugins. These paths will be searched for python modules that contain a plugin function. If the file does not exist, or the function is not found, it will be ignored The paths provided can be to a specific file, or a directory. If a directory is provided, all files in that directory will be searched for plugins.","title":"paths"},{"location":"reference/config/#arc.config.PresentConfig","text":"Configures the presentation of the application Source code in /home/runner/work/arc/arc/arc/config.py 30 31 32 33 34 35 36 37 38 39 40 41 42 @dataclass class PresentConfig : \"\"\"Configures the presentation of the application\"\"\" indent : str = \" \" * 4 \"\"\"The indent to use for each level of indentation\"\"\" width : int = 80 \"\"\"The default width to present content at. This is used for wrapping text. Will be ignored if the terminal width is smaller\"\"\" color : ColorConfig = field ( default_factory = ColorConfig ) \"\"\"The color configuration for the application\"\"\" formatter : type [ HelpFormatter ] = DefaultHelpFormatter \"\"\"Class to use when formatting help messages\"\"\"","title":"PresentConfig"},{"location":"reference/config/#arc.config.PresentConfig.color","text":"The color configuration for the application","title":"color"},{"location":"reference/config/#arc.config.PresentConfig.formatter","text":"Class to use when formatting help messages","title":"formatter"},{"location":"reference/config/#arc.config.PresentConfig.indent","text":"The indent to use for each level of indentation","title":"indent"},{"location":"reference/config/#arc.config.PresentConfig.width","text":"The default width to present content at. This is used for wrapping text. Will be ignored if the terminal width is smaller","title":"width"},{"location":"reference/config/#arc.config.SuggestionConfig","text":"Configures Suggestiosn for the application Source code in /home/runner/work/arc/arc/arc/config.py 52 53 54 55 56 57 58 @dataclass class SuggestionConfig : \"\"\"Configures Suggestiosn for the application\"\"\" commands : bool = True params : bool = True distance : int = 2","title":"SuggestionConfig"},{"location":"reference/config/#arc.config.configure","text":"Function for updating global arc configuration Parameters: Name Type Description Default version str | SemVer Version string to display with --version None environment str The current environment, either production or development . Defaults to production . When in development mode, the arc logger is set to level logging.INFO None transform_snake_case bool Transform snake_case to kebab-case . Defaults to True . None env_prefix str A prefix to use when selecting values for parameters from enviroment variables. Will be combined with the name specified by parameter. None config_env_prefix str A prefix to use when selecting values from enviroment for the configuration. None load_env bool Enable / disable loading config values from environment variables. Currently, arc can only load environment and debug from environment variables. None prompt Prompt A prompt object will be used when prompting for parameter values. Is also made available via Context.prompt . None autocomplete bool Enable / disable command line completions for this app. Currently the default is False None allow_unrecognized_args bool arc will not error when there are arguments provided that arc does not recognize. Their values will be stored in the context under the key arc.parse.extra . Defaults to False None debug bool enable / disable arc debug logs. None present PresentConfig set the presentation configuration for arc None suggest SuggestConfig configure the settings for suggesting replacements when arc does not recognize a command / parameter None links LinksConfig configure the links that arc may use in some output None Source code in /home/runner/work/arc/arc/arc/config.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def configure ( * , version : str | None = None , environment : at . Env | None = None , transform_snake_case : bool | None = None , suggest : SuggestionConfig | None = None , env_prefix : str | None = None , config_env_prefix : str | None = None , load_env : bool | None = None , prompt : Prompt | None = None , autocomplete : bool | None = None , allow_unrecognized_args : bool | None = None , debug : bool | None = None , links : LinksConfig | None = None , present : PresentConfig | None = None , plugins : PluginConfig | None = None , ** kwargs : t . Any , ) -> None : \"\"\"Function for updating global `arc` configuration Args: version (str | SemVer, optional): Version string to display with `--version` environment (str, optional): The current environment, either `production` or `development`. Defaults to `production`. When in `development` mode, the arc logger is set to level `logging.INFO` transform_snake_case (bool, optional): Transform `snake_case` to `kebab-case`. Defaults to `True`. env_prefix (str, optional): A prefix to use when selecting values for parameters from enviroment variables. Will be combined with the name specified by parameter. config_env_prefix (str, optional): A prefix to use when selecting values from enviroment for the configuration. load_env (bool, optional): Enable / disable loading config values from environment variables. Currently, arc can only load `environment` and `debug` from environment variables. prompt (Prompt, optional): A prompt object will be used when prompting for parameter values. Is also made available via `Context.prompt`. autocomplete (bool, optional): Enable / disable command line completions for this app. Currently the default is `False` allow_unrecognized_args (bool, optional): arc will not error when there are arguments provided that arc does not recognize. Their values will be stored in the context under the key `arc.parse.extra`. Defaults to `False` debug (bool, optional): enable / disable arc debug logs. present (PresentConfig, optional): set the presentation configuration for arc suggest (SuggestConfig, optional): configure the settings for suggesting replacements when arc does not recognize a command / parameter links (LinksConfig, optional): configure the links that arc may use in some output \"\"\" data : dict [ str , t . Any ] = { \"version\" : version , \"environment\" : environment , \"transform_snake_case\" : transform_snake_case , \"suggestions\" : suggest , \"env_prefix\" : env_prefix , \"config_env_prefix\" : config_env_prefix , \"load_env\" : load_env , \"prompt\" : prompt , \"autocomplete\" : autocomplete , \"allow_unrecognized_args\" : allow_unrecognized_args , \"debug\" : debug , \"links\" : links , \"present\" : present , \"plugins\" : plugins , \"extra\" : kwargs or None , } config = Config . load () config . update ( ** data )","title":"configure()"},{"location":"reference/errors/","text":"errors \u00b6 ArgumentError \u00b6 Bases: ExternalError Error with the value of a provided argument Source code in /home/runner/work/arc/arc/arc/errors.py 44 45 class ArgumentError ( ExternalError ): \"\"\"Error with the value of a provided argument\"\"\" ConversionError \u00b6 Bases: ArgumentError Raised if a type conversion fails Source code in /home/runner/work/arc/arc/arc/errors.py 48 49 50 51 52 53 54 class ConversionError ( ArgumentError ): \"\"\"Raised if a type conversion fails\"\"\" def __init__ ( self , value : t . Any , message : str , details : t . Any | None = None ): self . value = value self . details = details super () . __init__ ( message ) ExternalError \u00b6 Bases: ArcError Errors that fire due to user / input errors Source code in /home/runner/work/arc/arc/arc/errors.py 36 37 class ExternalError ( ArcError ): \"\"\"Errors that fire due to user / input errors\"\"\" InternalError \u00b6 Bases: ArcError Errors that fire due to development / internal errors. These will be noted to probably be bugs in production mode Source code in /home/runner/work/arc/arc/arc/errors.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 class InternalError ( ArcError ): \"\"\"Errors that fire due to development / internal errors. These will be noted to probably be bugs in production mode\"\"\" def fmt ( self , ctx : Context ) -> str : message = ( f \" { colorize ( 'ERROR:' , ctx . config . present . color . error , fx . BOLD ) } { str ( self ) } \\n\\n \" \"This is probably a bug, please report it to the maintainer\" ) if link := ctx . config . links . bug : message += f \": { link } \" return message UsageError \u00b6 Bases: ExternalError Indicates that the command was used incorrectly. If a command is provided, the command's usage will be printed, along with the provided error message Source code in /home/runner/work/arc/arc/arc/errors.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class UsageError ( ExternalError ): \"\"\"Indicates that the command was used incorrectly. If a command is provided, the command's usage will be printed, along with the provided error message\"\"\" def __init__ ( self , message : str , command : Command = None ): self . message = message self . command = command def fmt ( self , ctx : Context ) -> str : return f \" { self . usage () }{ self . message } \" def usage ( self ) -> str : if self . command : return self . command . doc . usage () + \" \\n \" return \"\" exit ( code = 0 , message = None ) \u00b6 Exits the application with code . Optionally recieves a message that will be written to stderr before exiting Source code in /home/runner/work/arc/arc/arc/errors.py 24 25 26 27 28 def exit ( code : int = 0 , message : str | None = None ) -> t . NoReturn : \"\"\"Exits the application with `code`. Optionally recieves a `message` that will be written to stderr before exiting\"\"\" raise Exit ( code , message )","title":"errors"},{"location":"reference/errors/#errors","text":"","title":"errors"},{"location":"reference/errors/#arc.errors.ArgumentError","text":"Bases: ExternalError Error with the value of a provided argument Source code in /home/runner/work/arc/arc/arc/errors.py 44 45 class ArgumentError ( ExternalError ): \"\"\"Error with the value of a provided argument\"\"\"","title":"ArgumentError"},{"location":"reference/errors/#arc.errors.ConversionError","text":"Bases: ArgumentError Raised if a type conversion fails Source code in /home/runner/work/arc/arc/arc/errors.py 48 49 50 51 52 53 54 class ConversionError ( ArgumentError ): \"\"\"Raised if a type conversion fails\"\"\" def __init__ ( self , value : t . Any , message : str , details : t . Any | None = None ): self . value = value self . details = details super () . __init__ ( message )","title":"ConversionError"},{"location":"reference/errors/#arc.errors.ExternalError","text":"Bases: ArcError Errors that fire due to user / input errors Source code in /home/runner/work/arc/arc/arc/errors.py 36 37 class ExternalError ( ArcError ): \"\"\"Errors that fire due to user / input errors\"\"\"","title":"ExternalError"},{"location":"reference/errors/#arc.errors.InternalError","text":"Bases: ArcError Errors that fire due to development / internal errors. These will be noted to probably be bugs in production mode Source code in /home/runner/work/arc/arc/arc/errors.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 class InternalError ( ArcError ): \"\"\"Errors that fire due to development / internal errors. These will be noted to probably be bugs in production mode\"\"\" def fmt ( self , ctx : Context ) -> str : message = ( f \" { colorize ( 'ERROR:' , ctx . config . present . color . error , fx . BOLD ) } { str ( self ) } \\n\\n \" \"This is probably a bug, please report it to the maintainer\" ) if link := ctx . config . links . bug : message += f \": { link } \" return message","title":"InternalError"},{"location":"reference/errors/#arc.errors.UsageError","text":"Bases: ExternalError Indicates that the command was used incorrectly. If a command is provided, the command's usage will be printed, along with the provided error message Source code in /home/runner/work/arc/arc/arc/errors.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class UsageError ( ExternalError ): \"\"\"Indicates that the command was used incorrectly. If a command is provided, the command's usage will be printed, along with the provided error message\"\"\" def __init__ ( self , message : str , command : Command = None ): self . message = message self . command = command def fmt ( self , ctx : Context ) -> str : return f \" { self . usage () }{ self . message } \" def usage ( self ) -> str : if self . command : return self . command . doc . usage () + \" \\n \" return \"\"","title":"UsageError"},{"location":"reference/errors/#arc.errors.exit","text":"Exits the application with code . Optionally recieves a message that will be written to stderr before exiting Source code in /home/runner/work/arc/arc/arc/errors.py 24 25 26 27 28 def exit ( code : int = 0 , message : str | None = None ) -> t . NoReturn : \"\"\"Exits the application with `code`. Optionally recieves a `message` that will be written to stderr before exiting\"\"\" raise Exit ( code , message )","title":"exit()"},{"location":"reference/logging/","text":"logging \u00b6","title":"logging"},{"location":"reference/logging/#logging","text":"","title":"logging"},{"location":"reference/parser/","text":"parser \u00b6","title":"parser"},{"location":"reference/parser/#parser","text":"","title":"parser"},{"location":"reference/safe/","text":"safe \u00b6","title":"safe"},{"location":"reference/safe/#safe","text":"","title":"safe"},{"location":"reference/typing/","text":"typing \u00b6 Module contains custom type defintions that arc uses CommandCallback = t . Union [ FunctionCallback , type [ ClassCallback ]] module-attribute \u00b6 The type of a command's callback. May be a function @arc . command def command ( name : str ): print ( f \"Hello { name } !\" ) Or a class @arc . command class command : name : str def handle ( self ): print ( f \"Hello { self . name } !\" ) CompletionProtocol \u00b6 Bases: t . Protocol Protocal that objects need to implement if they are expected to provide completions Source code in /home/runner/work/arc/arc/arc/typing.py 84 85 86 87 88 89 90 class CompletionProtocol ( t . Protocol ): \"\"\"Protocal that objects need to implement if they are expected to provide completions\"\"\" def __completions__ ( self , info : CompletionInfo , ) -> CompletionReturn : ... TypeProtocol \u00b6 Bases: t . Protocol Protocol that custom types need to conform to Source code in /home/runner/work/arc/arc/arc/typing.py 93 94 95 96 97 98 @t . runtime_checkable class TypeProtocol ( t . Protocol ): \"\"\"Protocol that custom types need to conform to\"\"\" @classmethod def __convert__ ( cls , value : t . Any , * args : t . Any ) -> t . Any : ...","title":"typing"},{"location":"reference/typing/#typing","text":"Module contains custom type defintions that arc uses","title":"typing"},{"location":"reference/typing/#arc.typing.CommandCallback","text":"The type of a command's callback. May be a function @arc . command def command ( name : str ): print ( f \"Hello { name } !\" ) Or a class @arc . command class command : name : str def handle ( self ): print ( f \"Hello { self . name } !\" )","title":"CommandCallback"},{"location":"reference/typing/#arc.typing.CompletionProtocol","text":"Bases: t . Protocol Protocal that objects need to implement if they are expected to provide completions Source code in /home/runner/work/arc/arc/arc/typing.py 84 85 86 87 88 89 90 class CompletionProtocol ( t . Protocol ): \"\"\"Protocal that objects need to implement if they are expected to provide completions\"\"\" def __completions__ ( self , info : CompletionInfo , ) -> CompletionReturn : ...","title":"CompletionProtocol"},{"location":"reference/typing/#arc.typing.TypeProtocol","text":"Bases: t . Protocol Protocol that custom types need to conform to Source code in /home/runner/work/arc/arc/arc/typing.py 93 94 95 96 97 98 @t . runtime_checkable class TypeProtocol ( t . Protocol ): \"\"\"Protocol that custom types need to conform to\"\"\" @classmethod def __convert__ ( cls , value : t . Any , * args : t . Any ) -> t . Any : ...","title":"TypeProtocol"},{"location":"reference/version/","text":"version \u00b6","title":"version"},{"location":"reference/version/#version","text":"","title":"version"},{"location":"reference/define/alias/","text":"define.alias \u00b6 AliasDict \u00b6 Bases: dict [ K , V ] Dict subclass for storing aliases to keys alongside the actual key Source code in /home/runner/work/arc/arc/arc/define/alias.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class AliasDict ( dict [ K , V ]): \"\"\"Dict subclass for storing aliases to keys alongside the actual key\"\"\" def __init__ ( self , * args : t . Any , ** kwargs : t . Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . aliases : dict [ K , K ] = {} \"\"\"Maps aliases to the cannonical key\"\"\" @t . overload def get ( self , key : K ) -> V | None : ... @t . overload def get ( self , key : K , default : V | t . Any ) -> V | t . Any : ... def get ( self , key : K , default : t . Any = None ) -> V | t . Any : \"\"\"Wraps `dict.get()` but also checks for aliases\"\"\" if super () . __contains__ ( key ): return self [ key ] if key in self . aliases : return self [ self . aliases [ key ]] return default def __contains__ ( self , key : object ) -> bool : return super () . __contains__ ( key ) or key in self . aliases def add_alias ( self , key : K , alias : K ) -> None : \"\"\"Add an `alias` for `key`\"\"\" self . aliases [ alias ] = key def add_aliases ( self , key : K , * aliases : K ) -> None : \"\"\"Add an several `aliass` for `key`\"\"\" for alias in aliases : self . add_alias ( key , alias ) def aliases_for ( self , key : K ) -> list [ K ]: return [ alias for alias , val in self . aliases . items () if val == key ] aliases : dict [ K , K ] = {} instance-attribute \u00b6 Maps aliases to the cannonical key add_alias ( key , alias ) \u00b6 Add an alias for key Source code in /home/runner/work/arc/arc/arc/define/alias.py 37 38 39 def add_alias ( self , key : K , alias : K ) -> None : \"\"\"Add an `alias` for `key`\"\"\" self . aliases [ alias ] = key add_aliases ( key , * aliases ) \u00b6 Add an several aliass for key Source code in /home/runner/work/arc/arc/arc/define/alias.py 41 42 43 44 def add_aliases ( self , key : K , * aliases : K ) -> None : \"\"\"Add an several `aliass` for `key`\"\"\" for alias in aliases : self . add_alias ( key , alias ) get ( key , default = None ) \u00b6 Wraps dict.get() but also checks for aliases Source code in /home/runner/work/arc/arc/arc/define/alias.py 25 26 27 28 29 30 31 32 def get ( self , key : K , default : t . Any = None ) -> V | t . Any : \"\"\"Wraps `dict.get()` but also checks for aliases\"\"\" if super () . __contains__ ( key ): return self [ key ] if key in self . aliases : return self [ self . aliases [ key ]] return default","title":"define.alias"},{"location":"reference/define/alias/#definealias","text":"","title":"define.alias"},{"location":"reference/define/alias/#arc.define.alias.AliasDict","text":"Bases: dict [ K , V ] Dict subclass for storing aliases to keys alongside the actual key Source code in /home/runner/work/arc/arc/arc/define/alias.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class AliasDict ( dict [ K , V ]): \"\"\"Dict subclass for storing aliases to keys alongside the actual key\"\"\" def __init__ ( self , * args : t . Any , ** kwargs : t . Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . aliases : dict [ K , K ] = {} \"\"\"Maps aliases to the cannonical key\"\"\" @t . overload def get ( self , key : K ) -> V | None : ... @t . overload def get ( self , key : K , default : V | t . Any ) -> V | t . Any : ... def get ( self , key : K , default : t . Any = None ) -> V | t . Any : \"\"\"Wraps `dict.get()` but also checks for aliases\"\"\" if super () . __contains__ ( key ): return self [ key ] if key in self . aliases : return self [ self . aliases [ key ]] return default def __contains__ ( self , key : object ) -> bool : return super () . __contains__ ( key ) or key in self . aliases def add_alias ( self , key : K , alias : K ) -> None : \"\"\"Add an `alias` for `key`\"\"\" self . aliases [ alias ] = key def add_aliases ( self , key : K , * aliases : K ) -> None : \"\"\"Add an several `aliass` for `key`\"\"\" for alias in aliases : self . add_alias ( key , alias ) def aliases_for ( self , key : K ) -> list [ K ]: return [ alias for alias , val in self . aliases . items () if val == key ]","title":"AliasDict"},{"location":"reference/define/alias/#arc.define.alias.AliasDict.aliases","text":"Maps aliases to the cannonical key","title":"aliases"},{"location":"reference/define/alias/#arc.define.alias.AliasDict.add_alias","text":"Add an alias for key Source code in /home/runner/work/arc/arc/arc/define/alias.py 37 38 39 def add_alias ( self , key : K , alias : K ) -> None : \"\"\"Add an `alias` for `key`\"\"\" self . aliases [ alias ] = key","title":"add_alias()"},{"location":"reference/define/alias/#arc.define.alias.AliasDict.add_aliases","text":"Add an several aliass for key Source code in /home/runner/work/arc/arc/arc/define/alias.py 41 42 43 44 def add_aliases ( self , key : K , * aliases : K ) -> None : \"\"\"Add an several `aliass` for `key`\"\"\" for alias in aliases : self . add_alias ( key , alias )","title":"add_aliases()"},{"location":"reference/define/alias/#arc.define.alias.AliasDict.get","text":"Wraps dict.get() but also checks for aliases Source code in /home/runner/work/arc/arc/arc/define/alias.py 25 26 27 28 29 30 31 32 def get ( self , key : K , default : t . Any = None ) -> V | t . Any : \"\"\"Wraps `dict.get()` but also checks for aliases\"\"\" if super () . __contains__ ( key ): return self [ key ] if key in self . aliases : return self [ self . aliases [ key ]] return default","title":"get()"},{"location":"reference/define/classful/","text":"define.classful \u00b6 class_signature ( cls ) \u00b6 Constructs a inspect.Signature object for a type. It uses the class-level annotations as the parameters so that we can treat the classes and functions the same Source code in /home/runner/work/arc/arc/arc/define/classful.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def class_signature ( cls : type ) -> inspect . Signature : \"\"\"Constructs a `inspect.Signature` object for a type. It uses the class-level annotations as the parameters so that we can treat the classes and functions the same \"\"\" annotations = t . get_type_hints ( cls , include_extras = True ) defaults = { name : getattr ( cls , name ) for name in dir ( cls ) if not isdunder ( name )} attrs = {} for name , annotation in annotations . items (): attrs [ name ] = ( annotation , inspect . Parameter . empty ) for name , default in defaults . items (): if inspect . isfunction ( default ): continue if name in attrs : attrs [ name ] = ( attrs [ name ][ 0 ], default ) else : attrs [ name ] = ( t . Any , default ) parameters = [ inspect . Parameter ( name = name , kind = inspect . Parameter . POSITIONAL_OR_KEYWORD , default = default , annotation = annotation , ) for name , ( annotation , default ) in attrs . items () ] sig = inspect . Signature ( sorted ( parameters , key = lambda p : not p . default is inspect . Parameter . empty ) ) # inspect.signature() checks for a cached signature object # at __signature__. So we can cache it there # to generate the correct signature object # during the parameter building process setattr ( cls , \"__signature__\" , sig ) return sig","title":"define.classful"},{"location":"reference/define/classful/#defineclassful","text":"","title":"define.classful"},{"location":"reference/define/classful/#arc.define.classful.class_signature","text":"Constructs a inspect.Signature object for a type. It uses the class-level annotations as the parameters so that we can treat the classes and functions the same Source code in /home/runner/work/arc/arc/arc/define/classful.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def class_signature ( cls : type ) -> inspect . Signature : \"\"\"Constructs a `inspect.Signature` object for a type. It uses the class-level annotations as the parameters so that we can treat the classes and functions the same \"\"\" annotations = t . get_type_hints ( cls , include_extras = True ) defaults = { name : getattr ( cls , name ) for name in dir ( cls ) if not isdunder ( name )} attrs = {} for name , annotation in annotations . items (): attrs [ name ] = ( annotation , inspect . Parameter . empty ) for name , default in defaults . items (): if inspect . isfunction ( default ): continue if name in attrs : attrs [ name ] = ( attrs [ name ][ 0 ], default ) else : attrs [ name ] = ( t . Any , default ) parameters = [ inspect . Parameter ( name = name , kind = inspect . Parameter . POSITIONAL_OR_KEYWORD , default = default , annotation = annotation , ) for name , ( annotation , default ) in attrs . items () ] sig = inspect . Signature ( sorted ( parameters , key = lambda p : not p . default is inspect . Parameter . empty ) ) # inspect.signature() checks for a cached signature object # at __signature__. So we can cache it there # to generate the correct signature object # during the parameter building process setattr ( cls , \"__signature__\" , sig ) return sig","title":"class_signature()"},{"location":"reference/define/command/","text":"define.command \u00b6 Command \u00b6 Bases: ParamMixin , MiddlewareManager Source code in /home/runner/work/arc/arc/arc/define/command.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 class Command ( ParamMixin , MiddlewareManager ): name : str parent : Command | None config : Config subcommands : AliasDict [ str , Command ] param_def : ParamDefinition doc : Documentation explicit_name : bool data : dict [ str , t . Any ] def __init__ ( self , callback : at . CommandCallback , config : Config , name : str | None = None , description : str | None = None , parent : Command | None = None , explicit_name : bool = True , autoload : bool = False , ** kwargs : t . Any , ) -> None : ParamMixin . __init__ ( self ) MiddlewareManager . __init__ ( self , []) if inspect . isclass ( callback ): self . callback = self . wrap_class_callback ( t . cast ( type [ at . ClassCallback ], callback ) ) else : self . callback = callback self . config = config self . name = name or callback . __name__ self . parent = parent self . subcommands = AliasDict () self . doc = Documentation ( self , self . config . present , description ) self . explicit_name = explicit_name self . data = kwargs __repr__ = api . display ( \"name\" ) def __call__ ( self , input_args : at . InputArgs = None , state : dict [ str , t . Any ] = None ) -> t . Any : \"\"\"Entry point for a command, call to execute your command object Args: input_args (str | list[str], optional): The input you wish to be processed. If none is provided, `sys.argv` is used. state (dict, optional): Execution State. Returns: result (Any): The value that the command's callback returns \"\"\" app = App ( self , state = state or {}) return app ( input_args ) def __iter__ ( self ) -> t . Iterator [ Command ]: stack : list [ Command ] = [] stack . append ( self ) while stack : curr = stack . pop () stack . extend ( curr . subcommands . values ()) yield curr def __completions__ ( self , info : CompletionInfo ) -> t . Iterable [ Completion ]: # TODO: This is a very naive approach it: # - does not take into account that collection # types can include more than 1 positional argument. # - Does not take into account that collection types # can be repeated when they're options # - Assumes that the user's cursor is at the end of the line command , args = self . find_command ( info . words ) if len ( args ) == 0 : yield from command . __complete_subcommands ( info ) yield from command . __complete_positional_value ( info , args ) elif info . current . startswith ( \"-\" ): yield from command . __complete_options ( info ) elif args [ - 1 ] . startswith ( \"-\" ): name = args [ - 1 ] . lstrip ( \"-\" ) param = command . get_param ( name ) if not param : return if param . is_flag : yield from command . __complete_positional_value ( info , args ) else : yield from command . __complete_param_value ( info , name ) else : pos = command . __complete_positional_value ( info , args ) if pos : yield from pos elif len ( args ) == 1 and any ( c . name . startswith ( args [ 0 ]) for c in self . subcommands . values () ): yield from command . __complete_subcommands ( info ) def __complete_subcommands ( self , info : CompletionInfo ) -> t . Iterable [ Completion ]: for command in self . subcommands . values (): yield Completion ( command . name , description = command . doc . short_description ) def __complete_options ( self , info : CompletionInfo ) -> t . Iterable [ Completion ]: for param in self . key_params : yield Completion ( param . cli_name , description = param . description ) def __complete_param_value ( self , info : CompletionInfo , param_name : str ) -> list [ Completion ]: param = self . get_param ( param_name ) if not param : return [] return get_completions ( param , info ) def __complete_positional_value ( self , info : CompletionInfo , args : list [ str ] ) -> list [ Completion ]: # TODO: This approach does not take into consideration positional # arguments that are peppered in between options. It only counts ones # at the end of the command line. pos_arg_count = 0 for word in reversed ( args ): if word . startswith ( \"-\" ) and word != \"--\" : break pos_arg_count += 1 if info . current != \"\" and pos_arg_count > 0 : pos_arg_count -= 1 arg_params = list ( self . argument_params ) if pos_arg_count < len ( arg_params ): param = arg_params [ pos_arg_count ] return get_completions ( param , info ) return [] @property def schema ( self ) -> dict [ str , t . Any ]: \"\"\"Schema for the command and all it's subcommands\"\"\" return { \"name\" : self . name , \"params\" : [ param . schema for param in self . params ], \"subcommands\" : [ com . schema for com in self . subcommands . values ()], } @property def is_namespace ( self ) -> bool : \"\"\"Whether or not this command was created using `arc.namespace()`\"\"\" return self . callback is namespace_callback @property def is_root ( self ) -> bool : \"\"\"Whether or not this command is the root of the command tree\"\"\" return self . parent is None @property def root ( self ) -> \"Command\" : \"\"\"Retrieve the root of the command tree\"\"\" command = self while command . parent : command = command . parent return command @property def all_names ( self ) -> list [ str ]: \"\"\"A list of all the names that a command may be referred to as\"\"\" names = [ self . name ] if self . parent : names += self . parent . subcommands . aliases_for ( self . name ) return names @property def command_chain ( self ) -> list [ Command ]: \"\"\"Retrieve the chain of commands from root -> self\"\"\" command = self chain = [ self ] while command . parent : command = command . parent chain . append ( command ) chain . reverse () return chain def run ( self , ctx : Context ) -> t . Any : start_time : datetime | None = ctx . get ( \"arc.debug.start\" ) if start_time : diff = datetime . now () - start_time ctx . logger . debug ( f \"Executing: { self } ( { diff . total_seconds () : .4f } s)\" ) else : ctx . logger . debug ( f \"Executing: { self } \" ) ctx . logger . debug ( \"\u2014\" * 50 ) stack = MiddlewareStack () for command in self . command_chain : stack . extend ( command . _stack ) ctx = stack . start ( ctx ) if \"arc.args\" not in ctx : raise errors . InternalError ( \"The command's arguments were not set during execution \" \"(ctx['arc.args] is not set). This likely means there \" \"is a problem with your middleware stack\" ) args = ctx [ \"arc.args\" ] res = None try : res = self . callback ( ** args ) except Exception as e : stack . throw ( e ) else : res = stack . close ( res ) ctx . logger . debug ( \"\u2014\" * 50 ) return res # Subcommands ---------------------------------------------------------------- @t . overload def subcommand ( self , / , first : Command , * aliases : str , ) -> Command : ... @t . overload def subcommand ( self , / , first : at . CommandCallback , ) -> Command : ... @t . overload def subcommand ( self , / , first : str | None = None , * aliases : str , desc : str | None = None , ** kwargs : t . Any , ) -> t . Callable [[ at . CommandCallback ], Command ]: ... def subcommand ( self , / , first : t . Any = None , * aliases : str , desc : str | None = None , ** kwargs : t . Any , ) -> Command | t . Callable [[ at . CommandCallback ], Command ]: \"\"\"Create a new child commmand of this command OR adopt a already created command as the child. ```py @command.subcommand(\"name1\", \"alias\", desc=\"...\") def subcommand(): ... ``` OR ```py @arc.command(\"name1\") def subcommand(): ... command.subcommand(subcommand, \"alias\", desc=\"...\") ``` \"\"\" if isinstance ( first , type ( self )): self . add_command ( first , aliases ) return first else : def inner ( callback : at . CommandCallback ) -> Command : command_name = self . get_canonical_subcommand_name ( callback , first , self . config . transform_snake_case ) command = Command ( callback = callback , name = command_name , description = desc , config = self . config , parent = self , ** kwargs , ) self . add_command ( command , aliases ) return command if callable ( first ): callback = first first = None return inner ( callback ) elif first is None or isinstance ( first , str ): return inner else : raise errors . CommandError ( \"Bad input to command.subcommand(). \" \"Needs to be used as a decorator, or \" \"passed an already constructed Command insance\" ) def add_command ( self , command : Command , aliases : t . Sequence [ str ] | None = None ) -> Command : \"\"\"Add a command object as a subcommand Args: command (Command): The command to add aliases (t.Sequence[str] | None, optional): Optional aliases to refter to the command by \"\"\" if command is self : raise errors . CommandError ( \"Command cannot be added as children of themselves\" ) self . subcommands [ command . name ] = command if command . parent is None : command . parent = self for m in ExecMiddleware . all (): command . _stack . try_remove ( m ) if aliases : self . subcommands . add_aliases ( command . name , * aliases ) return command def add_commands ( self , * commands : Command ) -> list [ Command ]: \"\"\"Add multiple commands as subcommands\"\"\" return [ self . add_command ( command ) for command in commands ] @staticmethod def get_canonical_subcommand_name ( callback : at . CommandCallback , cannonical_name : str | None , transform_snake_case : bool = True , ) -> str : if cannonical_name is None : cannonical_name = callback . __name__ if transform_snake_case : cannonical_name = cannonical_name . replace ( \"_\" , \"-\" ) return cannonical_name # Helpers -------------------------------------------------------------------- def find_command ( self , names : list [ str ]) -> tuple [ Command , list [ str ]]: \"\"\"Seperates out a sequence of args into: - a subcommand object - command arguments \"\"\" index = 0 command : Command = self for name in names : if name in command . subcommands : index += 1 child = command . subcommands . get ( name ) assert child is not None command = child else : break rest : list [ str ] = names [ index :] return command , rest def complete ( self , param_name : str ) -> t . Callable [[ at . CompletionFunc ], at . CompletionFunc ]: param = self . get_param ( param_name ) if param : def inner ( func : at . CompletionFunc ) -> at . CompletionFunc : param . comp_func = func # type: ignore return func return inner raise errors . ParamError ( f \"No parameter with name: { param_name } \" , Join . with_space ( self . doc . fullname ), ) def get ( self , param_name : str ) -> t . Callable [[ at . ParamGetter ], at . ParamGetter ]: param = self . get_param ( param_name ) if param : def inner ( func : at . ParamGetter ) -> at . ParamGetter : param . getter_func = func # type: ignore return func return inner raise errors . ParamError ( f \"No parameter with name: { param_name } \" , Join . with_space ( self . doc . fullname ), ) @staticmethod def wrap_class_callback ( cls : type [ at . ClassCallback ]) -> at . CommandCallback : if not hasattr ( cls , \"handle\" ): raise errors . CommandError ( \"class-style commands require a handle() method\" ) def wrapper ( ** kwargs : t . Any ) -> t . Any : inst = cls () for key , value in kwargs . items (): setattr ( inst , key , value ) return cls . handle ( inst ) classful . class_signature ( cls ) functools . update_wrapper ( wrapper , cls ) return wrapper all_names : list [ str ] property \u00b6 A list of all the names that a command may be referred to as command_chain : list [ Command ] property \u00b6 Retrieve the chain of commands from root -> self is_namespace : bool property \u00b6 Whether or not this command was created using arc.namespace() is_root : bool property \u00b6 Whether or not this command is the root of the command tree root : Command property \u00b6 Retrieve the root of the command tree schema : dict [ str , t . Any ] property \u00b6 Schema for the command and all it's subcommands __call__ ( input_args = None , state = None ) \u00b6 Entry point for a command, call to execute your command object Parameters: Name Type Description Default input_args str | list [ str ] The input you wish to be processed. If none is provided, sys.argv is used. None state dict Execution State. None Returns: Name Type Description result Any The value that the command's callback returns Source code in /home/runner/work/arc/arc/arc/define/command.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def __call__ ( self , input_args : at . InputArgs = None , state : dict [ str , t . Any ] = None ) -> t . Any : \"\"\"Entry point for a command, call to execute your command object Args: input_args (str | list[str], optional): The input you wish to be processed. If none is provided, `sys.argv` is used. state (dict, optional): Execution State. Returns: result (Any): The value that the command's callback returns \"\"\" app = App ( self , state = state or {}) return app ( input_args ) add_command ( command , aliases = None ) \u00b6 Add a command object as a subcommand Parameters: Name Type Description Default command Command The command to add required aliases t . Sequence [ str ] | None Optional aliases to refter to the command by None Source code in /home/runner/work/arc/arc/arc/define/command.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 def add_command ( self , command : Command , aliases : t . Sequence [ str ] | None = None ) -> Command : \"\"\"Add a command object as a subcommand Args: command (Command): The command to add aliases (t.Sequence[str] | None, optional): Optional aliases to refter to the command by \"\"\" if command is self : raise errors . CommandError ( \"Command cannot be added as children of themselves\" ) self . subcommands [ command . name ] = command if command . parent is None : command . parent = self for m in ExecMiddleware . all (): command . _stack . try_remove ( m ) if aliases : self . subcommands . add_aliases ( command . name , * aliases ) return command add_commands ( * commands ) \u00b6 Add multiple commands as subcommands Source code in /home/runner/work/arc/arc/arc/define/command.py 357 358 359 def add_commands ( self , * commands : Command ) -> list [ Command ]: \"\"\"Add multiple commands as subcommands\"\"\" return [ self . add_command ( command ) for command in commands ] find_command ( names ) \u00b6 Seperates out a sequence of args into: - a subcommand object - command arguments Source code in /home/runner/work/arc/arc/arc/define/command.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 def find_command ( self , names : list [ str ]) -> tuple [ Command , list [ str ]]: \"\"\"Seperates out a sequence of args into: - a subcommand object - command arguments \"\"\" index = 0 command : Command = self for name in names : if name in command . subcommands : index += 1 child = command . subcommands . get ( name ) assert child is not None command = child else : break rest : list [ str ] = names [ index :] return command , rest subcommand ( first = None , * aliases , desc = None , ** kwargs ) \u00b6 Create a new child commmand of this command OR adopt a already created command as the child. @command . subcommand ( \"name1\" , \"alias\" , desc = \"...\" ) def subcommand (): ... OR @arc . command ( \"name1\" ) def subcommand (): ... command . subcommand ( subcommand , \"alias\" , desc = \"...\" ) Source code in /home/runner/work/arc/arc/arc/define/command.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def subcommand ( self , / , first : t . Any = None , * aliases : str , desc : str | None = None , ** kwargs : t . Any , ) -> Command | t . Callable [[ at . CommandCallback ], Command ]: \"\"\"Create a new child commmand of this command OR adopt a already created command as the child. ```py @command.subcommand(\"name1\", \"alias\", desc=\"...\") def subcommand(): ... ``` OR ```py @arc.command(\"name1\") def subcommand(): ... command.subcommand(subcommand, \"alias\", desc=\"...\") ``` \"\"\" if isinstance ( first , type ( self )): self . add_command ( first , aliases ) return first else : def inner ( callback : at . CommandCallback ) -> Command : command_name = self . get_canonical_subcommand_name ( callback , first , self . config . transform_snake_case ) command = Command ( callback = callback , name = command_name , description = desc , config = self . config , parent = self , ** kwargs , ) self . add_command ( command , aliases ) return command if callable ( first ): callback = first first = None return inner ( callback ) elif first is None or isinstance ( first , str ): return inner else : raise errors . CommandError ( \"Bad input to command.subcommand(). \" \"Needs to be used as a decorator, or \" \"passed an already constructed Command insance\" ) command ( first = None , / , * , desc = None , config = None , ** kwargs ) \u00b6 Create an arc Command @arc . command def command (): print ( \"Hello there!\" ) Parameters: Name Type Description Default name str | None The name for this command. If one is not provided, the function's name will be used. required desc str | None Description for the command. If one is not provided, the docstring description will be used None config Config | None Configuration object to apply to this command. If one is not provided, the default is used None Source code in /home/runner/work/arc/arc/arc/define/command.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def command ( first : at . CommandCallback | str | None = None , / , * , desc : str | None = None , config : Config | None = None , ** kwargs : t . Any , ) -> t . Callable [[ at . CommandCallback ], Command ] | Command : \"\"\"Create an arc Command ```py @arc.command def command(): print(\"Hello there!\") ``` Args: name (str | None, optional): The name for this command. If one is not provided, the function's name will be used. desc (str | None, optional): Description for the command. If one is not provided, the docstring description will be used config (Config | None, optional): Configuration object to apply to this command. If one is not provided, the default is used \"\"\" name = None def inner ( callback : at . CommandCallback ) -> Command : cmdconfig = config or Config . load () command_name = Command . get_canonical_subcommand_name ( callback , name , cmdconfig . transform_snake_case ) command = Command ( callback = callback , config = cmdconfig , name = command_name , description = desc , parent = None , explicit_name = bool ( name ), autoload = True , ** kwargs , ) command . use ( ExecMiddleware . all ()) return command if isinstance ( first , str ) or first is None : name = first return inner else : return inner ( first ) namespace ( name , * , desc = None , config = None , ** kwargs ) \u00b6 Create an arc Command, that is not executable on it's own, but can have commands nested underneath it. ns = arc . namespace ( \"ns\" ) @ns . subcommand def sub (): print ( \"I'm a subcommand\" ) Parameters: Name Type Description Default name str Name of the command required desc str | None Description for the command. None Returns: Name Type Description command Command A command object without a callback associated with it Source code in /home/runner/work/arc/arc/arc/define/command.py 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 def namespace ( name : str , * , desc : str | None = None , config : Config | None = None , ** kwargs : t . Any , ) -> Command : \"\"\"Create an arc Command, that is not executable on it's own, but can have commands nested underneath it. ```py ns = arc.namespace(\"ns\") @ns.subcommand def sub(): print(\"I'm a subcommand\") ``` Args: name (str): Name of the command desc (str | None, optional): Description for the command. Returns: command: A command object without a callback associated with it \"\"\" config = config or Config . load () command = Command ( callback = namespace_callback , config = config , name = name , description = desc , parent = None , autoload = True , ** kwargs , ) command . use ( ExecMiddleware . all ()) return command","title":"define.command"},{"location":"reference/define/command/#definecommand","text":"","title":"define.command"},{"location":"reference/define/command/#arc.define.command.Command","text":"Bases: ParamMixin , MiddlewareManager Source code in /home/runner/work/arc/arc/arc/define/command.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 class Command ( ParamMixin , MiddlewareManager ): name : str parent : Command | None config : Config subcommands : AliasDict [ str , Command ] param_def : ParamDefinition doc : Documentation explicit_name : bool data : dict [ str , t . Any ] def __init__ ( self , callback : at . CommandCallback , config : Config , name : str | None = None , description : str | None = None , parent : Command | None = None , explicit_name : bool = True , autoload : bool = False , ** kwargs : t . Any , ) -> None : ParamMixin . __init__ ( self ) MiddlewareManager . __init__ ( self , []) if inspect . isclass ( callback ): self . callback = self . wrap_class_callback ( t . cast ( type [ at . ClassCallback ], callback ) ) else : self . callback = callback self . config = config self . name = name or callback . __name__ self . parent = parent self . subcommands = AliasDict () self . doc = Documentation ( self , self . config . present , description ) self . explicit_name = explicit_name self . data = kwargs __repr__ = api . display ( \"name\" ) def __call__ ( self , input_args : at . InputArgs = None , state : dict [ str , t . Any ] = None ) -> t . Any : \"\"\"Entry point for a command, call to execute your command object Args: input_args (str | list[str], optional): The input you wish to be processed. If none is provided, `sys.argv` is used. state (dict, optional): Execution State. Returns: result (Any): The value that the command's callback returns \"\"\" app = App ( self , state = state or {}) return app ( input_args ) def __iter__ ( self ) -> t . Iterator [ Command ]: stack : list [ Command ] = [] stack . append ( self ) while stack : curr = stack . pop () stack . extend ( curr . subcommands . values ()) yield curr def __completions__ ( self , info : CompletionInfo ) -> t . Iterable [ Completion ]: # TODO: This is a very naive approach it: # - does not take into account that collection # types can include more than 1 positional argument. # - Does not take into account that collection types # can be repeated when they're options # - Assumes that the user's cursor is at the end of the line command , args = self . find_command ( info . words ) if len ( args ) == 0 : yield from command . __complete_subcommands ( info ) yield from command . __complete_positional_value ( info , args ) elif info . current . startswith ( \"-\" ): yield from command . __complete_options ( info ) elif args [ - 1 ] . startswith ( \"-\" ): name = args [ - 1 ] . lstrip ( \"-\" ) param = command . get_param ( name ) if not param : return if param . is_flag : yield from command . __complete_positional_value ( info , args ) else : yield from command . __complete_param_value ( info , name ) else : pos = command . __complete_positional_value ( info , args ) if pos : yield from pos elif len ( args ) == 1 and any ( c . name . startswith ( args [ 0 ]) for c in self . subcommands . values () ): yield from command . __complete_subcommands ( info ) def __complete_subcommands ( self , info : CompletionInfo ) -> t . Iterable [ Completion ]: for command in self . subcommands . values (): yield Completion ( command . name , description = command . doc . short_description ) def __complete_options ( self , info : CompletionInfo ) -> t . Iterable [ Completion ]: for param in self . key_params : yield Completion ( param . cli_name , description = param . description ) def __complete_param_value ( self , info : CompletionInfo , param_name : str ) -> list [ Completion ]: param = self . get_param ( param_name ) if not param : return [] return get_completions ( param , info ) def __complete_positional_value ( self , info : CompletionInfo , args : list [ str ] ) -> list [ Completion ]: # TODO: This approach does not take into consideration positional # arguments that are peppered in between options. It only counts ones # at the end of the command line. pos_arg_count = 0 for word in reversed ( args ): if word . startswith ( \"-\" ) and word != \"--\" : break pos_arg_count += 1 if info . current != \"\" and pos_arg_count > 0 : pos_arg_count -= 1 arg_params = list ( self . argument_params ) if pos_arg_count < len ( arg_params ): param = arg_params [ pos_arg_count ] return get_completions ( param , info ) return [] @property def schema ( self ) -> dict [ str , t . Any ]: \"\"\"Schema for the command and all it's subcommands\"\"\" return { \"name\" : self . name , \"params\" : [ param . schema for param in self . params ], \"subcommands\" : [ com . schema for com in self . subcommands . values ()], } @property def is_namespace ( self ) -> bool : \"\"\"Whether or not this command was created using `arc.namespace()`\"\"\" return self . callback is namespace_callback @property def is_root ( self ) -> bool : \"\"\"Whether or not this command is the root of the command tree\"\"\" return self . parent is None @property def root ( self ) -> \"Command\" : \"\"\"Retrieve the root of the command tree\"\"\" command = self while command . parent : command = command . parent return command @property def all_names ( self ) -> list [ str ]: \"\"\"A list of all the names that a command may be referred to as\"\"\" names = [ self . name ] if self . parent : names += self . parent . subcommands . aliases_for ( self . name ) return names @property def command_chain ( self ) -> list [ Command ]: \"\"\"Retrieve the chain of commands from root -> self\"\"\" command = self chain = [ self ] while command . parent : command = command . parent chain . append ( command ) chain . reverse () return chain def run ( self , ctx : Context ) -> t . Any : start_time : datetime | None = ctx . get ( \"arc.debug.start\" ) if start_time : diff = datetime . now () - start_time ctx . logger . debug ( f \"Executing: { self } ( { diff . total_seconds () : .4f } s)\" ) else : ctx . logger . debug ( f \"Executing: { self } \" ) ctx . logger . debug ( \"\u2014\" * 50 ) stack = MiddlewareStack () for command in self . command_chain : stack . extend ( command . _stack ) ctx = stack . start ( ctx ) if \"arc.args\" not in ctx : raise errors . InternalError ( \"The command's arguments were not set during execution \" \"(ctx['arc.args] is not set). This likely means there \" \"is a problem with your middleware stack\" ) args = ctx [ \"arc.args\" ] res = None try : res = self . callback ( ** args ) except Exception as e : stack . throw ( e ) else : res = stack . close ( res ) ctx . logger . debug ( \"\u2014\" * 50 ) return res # Subcommands ---------------------------------------------------------------- @t . overload def subcommand ( self , / , first : Command , * aliases : str , ) -> Command : ... @t . overload def subcommand ( self , / , first : at . CommandCallback , ) -> Command : ... @t . overload def subcommand ( self , / , first : str | None = None , * aliases : str , desc : str | None = None , ** kwargs : t . Any , ) -> t . Callable [[ at . CommandCallback ], Command ]: ... def subcommand ( self , / , first : t . Any = None , * aliases : str , desc : str | None = None , ** kwargs : t . Any , ) -> Command | t . Callable [[ at . CommandCallback ], Command ]: \"\"\"Create a new child commmand of this command OR adopt a already created command as the child. ```py @command.subcommand(\"name1\", \"alias\", desc=\"...\") def subcommand(): ... ``` OR ```py @arc.command(\"name1\") def subcommand(): ... command.subcommand(subcommand, \"alias\", desc=\"...\") ``` \"\"\" if isinstance ( first , type ( self )): self . add_command ( first , aliases ) return first else : def inner ( callback : at . CommandCallback ) -> Command : command_name = self . get_canonical_subcommand_name ( callback , first , self . config . transform_snake_case ) command = Command ( callback = callback , name = command_name , description = desc , config = self . config , parent = self , ** kwargs , ) self . add_command ( command , aliases ) return command if callable ( first ): callback = first first = None return inner ( callback ) elif first is None or isinstance ( first , str ): return inner else : raise errors . CommandError ( \"Bad input to command.subcommand(). \" \"Needs to be used as a decorator, or \" \"passed an already constructed Command insance\" ) def add_command ( self , command : Command , aliases : t . Sequence [ str ] | None = None ) -> Command : \"\"\"Add a command object as a subcommand Args: command (Command): The command to add aliases (t.Sequence[str] | None, optional): Optional aliases to refter to the command by \"\"\" if command is self : raise errors . CommandError ( \"Command cannot be added as children of themselves\" ) self . subcommands [ command . name ] = command if command . parent is None : command . parent = self for m in ExecMiddleware . all (): command . _stack . try_remove ( m ) if aliases : self . subcommands . add_aliases ( command . name , * aliases ) return command def add_commands ( self , * commands : Command ) -> list [ Command ]: \"\"\"Add multiple commands as subcommands\"\"\" return [ self . add_command ( command ) for command in commands ] @staticmethod def get_canonical_subcommand_name ( callback : at . CommandCallback , cannonical_name : str | None , transform_snake_case : bool = True , ) -> str : if cannonical_name is None : cannonical_name = callback . __name__ if transform_snake_case : cannonical_name = cannonical_name . replace ( \"_\" , \"-\" ) return cannonical_name # Helpers -------------------------------------------------------------------- def find_command ( self , names : list [ str ]) -> tuple [ Command , list [ str ]]: \"\"\"Seperates out a sequence of args into: - a subcommand object - command arguments \"\"\" index = 0 command : Command = self for name in names : if name in command . subcommands : index += 1 child = command . subcommands . get ( name ) assert child is not None command = child else : break rest : list [ str ] = names [ index :] return command , rest def complete ( self , param_name : str ) -> t . Callable [[ at . CompletionFunc ], at . CompletionFunc ]: param = self . get_param ( param_name ) if param : def inner ( func : at . CompletionFunc ) -> at . CompletionFunc : param . comp_func = func # type: ignore return func return inner raise errors . ParamError ( f \"No parameter with name: { param_name } \" , Join . with_space ( self . doc . fullname ), ) def get ( self , param_name : str ) -> t . Callable [[ at . ParamGetter ], at . ParamGetter ]: param = self . get_param ( param_name ) if param : def inner ( func : at . ParamGetter ) -> at . ParamGetter : param . getter_func = func # type: ignore return func return inner raise errors . ParamError ( f \"No parameter with name: { param_name } \" , Join . with_space ( self . doc . fullname ), ) @staticmethod def wrap_class_callback ( cls : type [ at . ClassCallback ]) -> at . CommandCallback : if not hasattr ( cls , \"handle\" ): raise errors . CommandError ( \"class-style commands require a handle() method\" ) def wrapper ( ** kwargs : t . Any ) -> t . Any : inst = cls () for key , value in kwargs . items (): setattr ( inst , key , value ) return cls . handle ( inst ) classful . class_signature ( cls ) functools . update_wrapper ( wrapper , cls ) return wrapper","title":"Command"},{"location":"reference/define/command/#arc.define.command.Command.all_names","text":"A list of all the names that a command may be referred to as","title":"all_names"},{"location":"reference/define/command/#arc.define.command.Command.command_chain","text":"Retrieve the chain of commands from root -> self","title":"command_chain"},{"location":"reference/define/command/#arc.define.command.Command.is_namespace","text":"Whether or not this command was created using arc.namespace()","title":"is_namespace"},{"location":"reference/define/command/#arc.define.command.Command.is_root","text":"Whether or not this command is the root of the command tree","title":"is_root"},{"location":"reference/define/command/#arc.define.command.Command.root","text":"Retrieve the root of the command tree","title":"root"},{"location":"reference/define/command/#arc.define.command.Command.schema","text":"Schema for the command and all it's subcommands","title":"schema"},{"location":"reference/define/command/#arc.define.command.Command.__call__","text":"Entry point for a command, call to execute your command object Parameters: Name Type Description Default input_args str | list [ str ] The input you wish to be processed. If none is provided, sys.argv is used. None state dict Execution State. None Returns: Name Type Description result Any The value that the command's callback returns Source code in /home/runner/work/arc/arc/arc/define/command.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def __call__ ( self , input_args : at . InputArgs = None , state : dict [ str , t . Any ] = None ) -> t . Any : \"\"\"Entry point for a command, call to execute your command object Args: input_args (str | list[str], optional): The input you wish to be processed. If none is provided, `sys.argv` is used. state (dict, optional): Execution State. Returns: result (Any): The value that the command's callback returns \"\"\" app = App ( self , state = state or {}) return app ( input_args )","title":"__call__()"},{"location":"reference/define/command/#arc.define.command.Command.add_command","text":"Add a command object as a subcommand Parameters: Name Type Description Default command Command The command to add required aliases t . Sequence [ str ] | None Optional aliases to refter to the command by None Source code in /home/runner/work/arc/arc/arc/define/command.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 def add_command ( self , command : Command , aliases : t . Sequence [ str ] | None = None ) -> Command : \"\"\"Add a command object as a subcommand Args: command (Command): The command to add aliases (t.Sequence[str] | None, optional): Optional aliases to refter to the command by \"\"\" if command is self : raise errors . CommandError ( \"Command cannot be added as children of themselves\" ) self . subcommands [ command . name ] = command if command . parent is None : command . parent = self for m in ExecMiddleware . all (): command . _stack . try_remove ( m ) if aliases : self . subcommands . add_aliases ( command . name , * aliases ) return command","title":"add_command()"},{"location":"reference/define/command/#arc.define.command.Command.add_commands","text":"Add multiple commands as subcommands Source code in /home/runner/work/arc/arc/arc/define/command.py 357 358 359 def add_commands ( self , * commands : Command ) -> list [ Command ]: \"\"\"Add multiple commands as subcommands\"\"\" return [ self . add_command ( command ) for command in commands ]","title":"add_commands()"},{"location":"reference/define/command/#arc.define.command.Command.find_command","text":"Seperates out a sequence of args into: - a subcommand object - command arguments Source code in /home/runner/work/arc/arc/arc/define/command.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 def find_command ( self , names : list [ str ]) -> tuple [ Command , list [ str ]]: \"\"\"Seperates out a sequence of args into: - a subcommand object - command arguments \"\"\" index = 0 command : Command = self for name in names : if name in command . subcommands : index += 1 child = command . subcommands . get ( name ) assert child is not None command = child else : break rest : list [ str ] = names [ index :] return command , rest","title":"find_command()"},{"location":"reference/define/command/#arc.define.command.Command.subcommand","text":"Create a new child commmand of this command OR adopt a already created command as the child. @command . subcommand ( \"name1\" , \"alias\" , desc = \"...\" ) def subcommand (): ... OR @arc . command ( \"name1\" ) def subcommand (): ... command . subcommand ( subcommand , \"alias\" , desc = \"...\" ) Source code in /home/runner/work/arc/arc/arc/define/command.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def subcommand ( self , / , first : t . Any = None , * aliases : str , desc : str | None = None , ** kwargs : t . Any , ) -> Command | t . Callable [[ at . CommandCallback ], Command ]: \"\"\"Create a new child commmand of this command OR adopt a already created command as the child. ```py @command.subcommand(\"name1\", \"alias\", desc=\"...\") def subcommand(): ... ``` OR ```py @arc.command(\"name1\") def subcommand(): ... command.subcommand(subcommand, \"alias\", desc=\"...\") ``` \"\"\" if isinstance ( first , type ( self )): self . add_command ( first , aliases ) return first else : def inner ( callback : at . CommandCallback ) -> Command : command_name = self . get_canonical_subcommand_name ( callback , first , self . config . transform_snake_case ) command = Command ( callback = callback , name = command_name , description = desc , config = self . config , parent = self , ** kwargs , ) self . add_command ( command , aliases ) return command if callable ( first ): callback = first first = None return inner ( callback ) elif first is None or isinstance ( first , str ): return inner else : raise errors . CommandError ( \"Bad input to command.subcommand(). \" \"Needs to be used as a decorator, or \" \"passed an already constructed Command insance\" )","title":"subcommand()"},{"location":"reference/define/command/#arc.define.command.command","text":"Create an arc Command @arc . command def command (): print ( \"Hello there!\" ) Parameters: Name Type Description Default name str | None The name for this command. If one is not provided, the function's name will be used. required desc str | None Description for the command. If one is not provided, the docstring description will be used None config Config | None Configuration object to apply to this command. If one is not provided, the default is used None Source code in /home/runner/work/arc/arc/arc/define/command.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def command ( first : at . CommandCallback | str | None = None , / , * , desc : str | None = None , config : Config | None = None , ** kwargs : t . Any , ) -> t . Callable [[ at . CommandCallback ], Command ] | Command : \"\"\"Create an arc Command ```py @arc.command def command(): print(\"Hello there!\") ``` Args: name (str | None, optional): The name for this command. If one is not provided, the function's name will be used. desc (str | None, optional): Description for the command. If one is not provided, the docstring description will be used config (Config | None, optional): Configuration object to apply to this command. If one is not provided, the default is used \"\"\" name = None def inner ( callback : at . CommandCallback ) -> Command : cmdconfig = config or Config . load () command_name = Command . get_canonical_subcommand_name ( callback , name , cmdconfig . transform_snake_case ) command = Command ( callback = callback , config = cmdconfig , name = command_name , description = desc , parent = None , explicit_name = bool ( name ), autoload = True , ** kwargs , ) command . use ( ExecMiddleware . all ()) return command if isinstance ( first , str ) or first is None : name = first return inner else : return inner ( first )","title":"command()"},{"location":"reference/define/command/#arc.define.command.namespace","text":"Create an arc Command, that is not executable on it's own, but can have commands nested underneath it. ns = arc . namespace ( \"ns\" ) @ns . subcommand def sub (): print ( \"I'm a subcommand\" ) Parameters: Name Type Description Default name str Name of the command required desc str | None Description for the command. None Returns: Name Type Description command Command A command object without a callback associated with it Source code in /home/runner/work/arc/arc/arc/define/command.py 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 def namespace ( name : str , * , desc : str | None = None , config : Config | None = None , ** kwargs : t . Any , ) -> Command : \"\"\"Create an arc Command, that is not executable on it's own, but can have commands nested underneath it. ```py ns = arc.namespace(\"ns\") @ns.subcommand def sub(): print(\"I'm a subcommand\") ``` Args: name (str): Name of the command desc (str | None, optional): Description for the command. Returns: command: A command object without a callback associated with it \"\"\" config = config or Config . load () command = Command ( callback = namespace_callback , config = config , name = name , description = desc , parent = None , autoload = True , ** kwargs , ) command . use ( ExecMiddleware . all ()) return command","title":"namespace()"},{"location":"reference/define/documentation/","text":"define.documentation \u00b6","title":"define.documentation"},{"location":"reference/define/documentation/#definedocumentation","text":"","title":"define.documentation"},{"location":"reference/define/param/constructors/","text":"define.param.constructors \u00b6 ParamInfo \u00b6 Source code in /home/runner/work/arc/arc/arc/define/param/constructors.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class ParamInfo : def __init__ ( self , param_cls : type [ param . Param [ t . Any ]], param_name : str = None , short : str = None , default : t . Any = constants . MISSING , desc : str = None , callback : at . ParamCallback = None , action : param . Action = None , prompt : str = None , envvar : str = None , complete : at . CompletionFunc = None , getter_func : at . ParamGetter = None , data : dict [ str , t . Any ] = None , ): self . param_cls = param_cls self . param_name = param_name self . short_name = short self . default = default self . desc = desc self . callback = callback self . action = action self . prompt = prompt self . envvar = envvar self . complete = complete self . getter_func = getter_func self . data = data or {} def dict ( self ) -> dict [ str , t . Any ]: \"\"\"Used to pass to `Param()` as **kwargs\"\"\" return { \"param_name\" : self . param_name , \"short_name\" : self . short_name , \"default\" : self . default , \"description\" : self . desc , \"callback\" : self . callback , \"prompt\" : self . prompt , \"envvar\" : self . envvar , \"action\" : self . action , \"comp_func\" : self . complete , \"getter_func\" : self . getter_func , \"data\" : self . data , } dict () \u00b6 Used to pass to Param() as **kwargs Source code in /home/runner/work/arc/arc/arc/define/param/constructors.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def dict ( self ) -> dict [ str , t . Any ]: \"\"\"Used to pass to `Param()` as **kwargs\"\"\" return { \"param_name\" : self . param_name , \"short_name\" : self . short_name , \"default\" : self . default , \"description\" : self . desc , \"callback\" : self . callback , \"prompt\" : self . prompt , \"envvar\" : self . envvar , \"action\" : self . action , \"comp_func\" : self . complete , \"getter_func\" : self . getter_func , \"data\" : self . data , } Argument ( * , name = None , default = constants . MISSING , desc = None , callback = None , prompt = None , envvar = None , get = None , complete = None , ** kwargs ) \u00b6 A CLI argument. Input is passed positionally. Parameters: Name Type Description Default name str The name to use for the parameter on the command line. None default t . Any A default value for the parameter. If one is given, the argument becomes optional, otherwise it is required. constants.MISSING desc str A description of the parameter, will be added to the --help doc. None callback t . Callable a Callable object that can be used to modify the value of this parameter. None prompt str A string to provide the user with as a prompt to request input from STDIN when none is provided from the command line. None envvar str Name of an enviroment variable to obtain a value from if one is not provided on the command line. None get at . GetterFunc Callable object to retrive a possible value for the command if one is not provided on the command line. None complete at . CompletionFunc Function to provide shell completions for this parameter. None Example \u00b6 @cli . command () def test ( val : int = Argument ()): arc . print ( val ) $ python example.py test 2 2 Source code in /home/runner/work/arc/arc/arc/define/param/constructors.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def Argument ( * , name : str = None , default : t . Any = constants . MISSING , desc : str = None , callback : at . ParamCallback = None , prompt : str = None , envvar : str = None , get : at . ParamGetter = None , complete : at . CompletionFunc = None , ** kwargs : t . Any , ) -> t . Any : \"\"\"A CLI argument. Input is passed positionally. Args: name (str, optional): The name to use for the parameter on the command line. default (t.Any, optional): A default value for the parameter. If one is given, the argument becomes optional, otherwise it is required. desc (str, optional): A description of the parameter, will be added to the `--help` doc. callback (t.Callable, optional): a Callable object that can be used to modify the value of this parameter. prompt (str, optional): A string to provide the user with as a prompt to request input from STDIN when none is provided from the command line. envvar (str, optional): Name of an enviroment variable to obtain a value from if one is not provided on the command line. get (at.GetterFunc, optional): Callable object to retrive a possible value for the command if one is not provided on the command line. complete (at.CompletionFunc, optional): Function to provide shell completions for this parameter. ## Example ```py @cli.command() def test(val: int = Argument()): arc.print(val) ``` ``` $ python example.py test 2 2 ``` \"\"\" return ParamInfo ( param_cls = param . ArgumentParam , param_name = name , default = default , desc = desc , callback = callback , prompt = prompt , envvar = envvar , getter_func = get , complete = complete , data = kwargs , ) Count ( * , name = None , short = None , default = 0 , desc = None , callback = None , ** kwargs ) \u00b6 A Flag that counts it's number of apperances on the command line Parameters: Name Type Description Default name str The name to use for the parameter on the command line. None short str A single character name to refer to this parameter to on the command line ( --name vs -n ) None default int The starting point for the counter. Should be an integer. 0 desc str A description of the parameter, will be added to the --help doc. None callback t . Callable a Callable object that can be used to modify the value of this parameter. None Example \u00b6 @cli . command () def test ( val : int = Count ( short = \"v\" )): arc . print ( val ) $ python example.py test 0 $ python example.py test --val 1 $ python example.py test -vvvv 4 Source code in /home/runner/work/arc/arc/arc/define/param/constructors.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def Count ( * , name : str = None , short : str = None , default : int = 0 , desc : str = None , callback : at . ParamCallback = None , ** kwargs : t . Any , ) -> t . Any : \"\"\"A Flag that counts it's number of apperances on the command line Args: name (str, optional): The name to use for the parameter on the command line. short (str, optional): A single character name to refer to this parameter to on the command line (`--name` vs `-n`) default (int, optional): The starting point for the counter. Should be an integer. desc (str, optional): A description of the parameter, will be added to the `--help` doc. callback (t.Callable, optional): a Callable object that can be used to modify the value of this parameter. # Example ```py @cli.command() def test(val: int = Count(short=\"v\")): arc.print(val) ``` ``` $ python example.py test 0 $ python example.py test --val 1 $ python example.py test -vvvv 4 ``` \"\"\" return ParamInfo ( param_cls = param . FlagParam , param_name = name , short = short , default = default , desc = desc , callback = callback , action = param . Action . COUNT , data = kwargs , ) Flag ( * , name = None , short = None , default = False , desc = None , callback = None , ** kwargs ) \u00b6 An option that represents a boolean value. Parameters: Name Type Description Default name str The name to use for the parameter on the command line. None short str A single character name to refer to this parameter to on the command line ( --name vs -n ) None default boolean A default value for the parameter. If one is given, the argument becomes optional, otherwise it is required. False desc str A description of the parameter, will be added to the --help doc. None callback t . Callable a Callable object that can be used to modify the value of this parameter. None Example \u00b6 @cli . command () def test ( val : bool = Flag ()): arc . print ( val ) $ python example.py test False $ python example.py test --flag True Source code in /home/runner/work/arc/arc/arc/define/param/constructors.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def Flag ( * , name : str = None , short : str = None , default : bool = False , desc : str = None , callback : at . ParamCallback = None , ** kwargs : t . Any , ) -> t . Any : \"\"\"An option that represents a boolean value. Args: name (str, optional): The name to use for the parameter on the command line. short (str, optional): A single character name to refer to this parameter to on the command line (`--name` vs `-n`) default (boolean, optional): A default value for the parameter. If one is given, the argument becomes optional, otherwise it is required. desc (str, optional): A description of the parameter, will be added to the `--help` doc. callback (t.Callable, optional): a Callable object that can be used to modify the value of this parameter. # Example ```py @cli.command() def test(val: bool = Flag()): arc.print(val) ``` ``` $ python example.py test False $ python example.py test --flag True ``` \"\"\" return ParamInfo ( param_cls = param . FlagParam , param_name = name , short = short , default = default , desc = desc , callback = callback , data = kwargs , ) Option ( * , name = None , short = None , default = constants . MISSING , desc = None , callback = None , prompt = None , envvar = None , get = None , complete = None , ** kwargs ) \u00b6 A (generally optional) keyword parameter. Parameters: Name Type Description Default name str The name to use for the parameter on the command line. None short str A single character name to refer to this parameter to on the command line ( --name vs -n ) None default t . Any A default value for the parameter. If one is given, the argument becomes optional, otherwise it is required. constants.MISSING desc str A description of the parameter, will be added to the --help doc. None callback t . Callable a Callable object that can be used to modify the value of this parameter. None prompt str A string to provide the user with as a prompt to request input from STDIN when none is provided from the command line. None envvar str Name of an enviroment variable to obtain a value from if one is not provided on the command line. None get at . GetterFunc Callable object to retrive a possible value for the command if one is not provided on the command line. None complete at . CompletionFunc Function to provide shell completions for this parameter. None Example \u00b6 @cli . command () def test ( val : int = Option ()): arc . print ( val ) $ python example.py test --val 2 2 Source code in /home/runner/work/arc/arc/arc/define/param/constructors.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def Option ( * , name : str = None , short : str = None , default : t . Any = constants . MISSING , desc : str = None , callback : at . ParamCallback = None , prompt : str = None , envvar : str = None , get : at . ParamGetter = None , complete : at . CompletionFunc = None , ** kwargs : t . Any , ) -> t . Any : \"\"\"A (generally optional) keyword parameter. Args: name (str, optional): The name to use for the parameter on the command line. short (str, optional): A single character name to refer to this parameter to on the command line (`--name` vs `-n`) default (t.Any, optional): A default value for the parameter. If one is given, the argument becomes optional, otherwise it is required. desc (str, optional): A description of the parameter, will be added to the `--help` doc. callback (t.Callable, optional): a Callable object that can be used to modify the value of this parameter. prompt (str, optional): A string to provide the user with as a prompt to request input from STDIN when none is provided from the command line. envvar (str, optional): Name of an enviroment variable to obtain a value from if one is not provided on the command line. get (at.GetterFunc, optional): Callable object to retrive a possible value for the command if one is not provided on the command line. complete (at.CompletionFunc, optional): Function to provide shell completions for this parameter. # Example ```py @cli.command() def test(val: int = Option()): arc.print(val) ``` ``` $ python example.py test --val 2 2 ``` \"\"\" return ParamInfo ( param_cls = param . OptionParam , param_name = name , short = short , default = default , desc = desc , callback = callback , prompt = prompt , envvar = envvar , getter_func = get , complete = complete , data = kwargs , )","title":"define.param.constructors"},{"location":"reference/define/param/constructors/#defineparamconstructors","text":"","title":"define.param.constructors"},{"location":"reference/define/param/constructors/#arc.define.param.constructors.ParamInfo","text":"Source code in /home/runner/work/arc/arc/arc/define/param/constructors.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class ParamInfo : def __init__ ( self , param_cls : type [ param . Param [ t . Any ]], param_name : str = None , short : str = None , default : t . Any = constants . MISSING , desc : str = None , callback : at . ParamCallback = None , action : param . Action = None , prompt : str = None , envvar : str = None , complete : at . CompletionFunc = None , getter_func : at . ParamGetter = None , data : dict [ str , t . Any ] = None , ): self . param_cls = param_cls self . param_name = param_name self . short_name = short self . default = default self . desc = desc self . callback = callback self . action = action self . prompt = prompt self . envvar = envvar self . complete = complete self . getter_func = getter_func self . data = data or {} def dict ( self ) -> dict [ str , t . Any ]: \"\"\"Used to pass to `Param()` as **kwargs\"\"\" return { \"param_name\" : self . param_name , \"short_name\" : self . short_name , \"default\" : self . default , \"description\" : self . desc , \"callback\" : self . callback , \"prompt\" : self . prompt , \"envvar\" : self . envvar , \"action\" : self . action , \"comp_func\" : self . complete , \"getter_func\" : self . getter_func , \"data\" : self . data , }","title":"ParamInfo"},{"location":"reference/define/param/constructors/#arc.define.param.constructors.ParamInfo.dict","text":"Used to pass to Param() as **kwargs Source code in /home/runner/work/arc/arc/arc/define/param/constructors.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def dict ( self ) -> dict [ str , t . Any ]: \"\"\"Used to pass to `Param()` as **kwargs\"\"\" return { \"param_name\" : self . param_name , \"short_name\" : self . short_name , \"default\" : self . default , \"description\" : self . desc , \"callback\" : self . callback , \"prompt\" : self . prompt , \"envvar\" : self . envvar , \"action\" : self . action , \"comp_func\" : self . complete , \"getter_func\" : self . getter_func , \"data\" : self . data , }","title":"dict()"},{"location":"reference/define/param/constructors/#arc.define.param.constructors.Argument","text":"A CLI argument. Input is passed positionally. Parameters: Name Type Description Default name str The name to use for the parameter on the command line. None default t . Any A default value for the parameter. If one is given, the argument becomes optional, otherwise it is required. constants.MISSING desc str A description of the parameter, will be added to the --help doc. None callback t . Callable a Callable object that can be used to modify the value of this parameter. None prompt str A string to provide the user with as a prompt to request input from STDIN when none is provided from the command line. None envvar str Name of an enviroment variable to obtain a value from if one is not provided on the command line. None get at . GetterFunc Callable object to retrive a possible value for the command if one is not provided on the command line. None complete at . CompletionFunc Function to provide shell completions for this parameter. None","title":"Argument()"},{"location":"reference/define/param/constructors/#arc.define.param.constructors.Argument--example","text":"@cli . command () def test ( val : int = Argument ()): arc . print ( val ) $ python example.py test 2 2 Source code in /home/runner/work/arc/arc/arc/define/param/constructors.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def Argument ( * , name : str = None , default : t . Any = constants . MISSING , desc : str = None , callback : at . ParamCallback = None , prompt : str = None , envvar : str = None , get : at . ParamGetter = None , complete : at . CompletionFunc = None , ** kwargs : t . Any , ) -> t . Any : \"\"\"A CLI argument. Input is passed positionally. Args: name (str, optional): The name to use for the parameter on the command line. default (t.Any, optional): A default value for the parameter. If one is given, the argument becomes optional, otherwise it is required. desc (str, optional): A description of the parameter, will be added to the `--help` doc. callback (t.Callable, optional): a Callable object that can be used to modify the value of this parameter. prompt (str, optional): A string to provide the user with as a prompt to request input from STDIN when none is provided from the command line. envvar (str, optional): Name of an enviroment variable to obtain a value from if one is not provided on the command line. get (at.GetterFunc, optional): Callable object to retrive a possible value for the command if one is not provided on the command line. complete (at.CompletionFunc, optional): Function to provide shell completions for this parameter. ## Example ```py @cli.command() def test(val: int = Argument()): arc.print(val) ``` ``` $ python example.py test 2 2 ``` \"\"\" return ParamInfo ( param_cls = param . ArgumentParam , param_name = name , default = default , desc = desc , callback = callback , prompt = prompt , envvar = envvar , getter_func = get , complete = complete , data = kwargs , )","title":"Example"},{"location":"reference/define/param/constructors/#arc.define.param.constructors.Count","text":"A Flag that counts it's number of apperances on the command line Parameters: Name Type Description Default name str The name to use for the parameter on the command line. None short str A single character name to refer to this parameter to on the command line ( --name vs -n ) None default int The starting point for the counter. Should be an integer. 0 desc str A description of the parameter, will be added to the --help doc. None callback t . Callable a Callable object that can be used to modify the value of this parameter. None","title":"Count()"},{"location":"reference/define/param/constructors/#arc.define.param.constructors.Count--example","text":"@cli . command () def test ( val : int = Count ( short = \"v\" )): arc . print ( val ) $ python example.py test 0 $ python example.py test --val 1 $ python example.py test -vvvv 4 Source code in /home/runner/work/arc/arc/arc/define/param/constructors.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def Count ( * , name : str = None , short : str = None , default : int = 0 , desc : str = None , callback : at . ParamCallback = None , ** kwargs : t . Any , ) -> t . Any : \"\"\"A Flag that counts it's number of apperances on the command line Args: name (str, optional): The name to use for the parameter on the command line. short (str, optional): A single character name to refer to this parameter to on the command line (`--name` vs `-n`) default (int, optional): The starting point for the counter. Should be an integer. desc (str, optional): A description of the parameter, will be added to the `--help` doc. callback (t.Callable, optional): a Callable object that can be used to modify the value of this parameter. # Example ```py @cli.command() def test(val: int = Count(short=\"v\")): arc.print(val) ``` ``` $ python example.py test 0 $ python example.py test --val 1 $ python example.py test -vvvv 4 ``` \"\"\" return ParamInfo ( param_cls = param . FlagParam , param_name = name , short = short , default = default , desc = desc , callback = callback , action = param . Action . COUNT , data = kwargs , )","title":"Example"},{"location":"reference/define/param/constructors/#arc.define.param.constructors.Flag","text":"An option that represents a boolean value. Parameters: Name Type Description Default name str The name to use for the parameter on the command line. None short str A single character name to refer to this parameter to on the command line ( --name vs -n ) None default boolean A default value for the parameter. If one is given, the argument becomes optional, otherwise it is required. False desc str A description of the parameter, will be added to the --help doc. None callback t . Callable a Callable object that can be used to modify the value of this parameter. None","title":"Flag()"},{"location":"reference/define/param/constructors/#arc.define.param.constructors.Flag--example","text":"@cli . command () def test ( val : bool = Flag ()): arc . print ( val ) $ python example.py test False $ python example.py test --flag True Source code in /home/runner/work/arc/arc/arc/define/param/constructors.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def Flag ( * , name : str = None , short : str = None , default : bool = False , desc : str = None , callback : at . ParamCallback = None , ** kwargs : t . Any , ) -> t . Any : \"\"\"An option that represents a boolean value. Args: name (str, optional): The name to use for the parameter on the command line. short (str, optional): A single character name to refer to this parameter to on the command line (`--name` vs `-n`) default (boolean, optional): A default value for the parameter. If one is given, the argument becomes optional, otherwise it is required. desc (str, optional): A description of the parameter, will be added to the `--help` doc. callback (t.Callable, optional): a Callable object that can be used to modify the value of this parameter. # Example ```py @cli.command() def test(val: bool = Flag()): arc.print(val) ``` ``` $ python example.py test False $ python example.py test --flag True ``` \"\"\" return ParamInfo ( param_cls = param . FlagParam , param_name = name , short = short , default = default , desc = desc , callback = callback , data = kwargs , )","title":"Example"},{"location":"reference/define/param/constructors/#arc.define.param.constructors.Option","text":"A (generally optional) keyword parameter. Parameters: Name Type Description Default name str The name to use for the parameter on the command line. None short str A single character name to refer to this parameter to on the command line ( --name vs -n ) None default t . Any A default value for the parameter. If one is given, the argument becomes optional, otherwise it is required. constants.MISSING desc str A description of the parameter, will be added to the --help doc. None callback t . Callable a Callable object that can be used to modify the value of this parameter. None prompt str A string to provide the user with as a prompt to request input from STDIN when none is provided from the command line. None envvar str Name of an enviroment variable to obtain a value from if one is not provided on the command line. None get at . GetterFunc Callable object to retrive a possible value for the command if one is not provided on the command line. None complete at . CompletionFunc Function to provide shell completions for this parameter. None","title":"Option()"},{"location":"reference/define/param/constructors/#arc.define.param.constructors.Option--example","text":"@cli . command () def test ( val : int = Option ()): arc . print ( val ) $ python example.py test --val 2 2 Source code in /home/runner/work/arc/arc/arc/define/param/constructors.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def Option ( * , name : str = None , short : str = None , default : t . Any = constants . MISSING , desc : str = None , callback : at . ParamCallback = None , prompt : str = None , envvar : str = None , get : at . ParamGetter = None , complete : at . CompletionFunc = None , ** kwargs : t . Any , ) -> t . Any : \"\"\"A (generally optional) keyword parameter. Args: name (str, optional): The name to use for the parameter on the command line. short (str, optional): A single character name to refer to this parameter to on the command line (`--name` vs `-n`) default (t.Any, optional): A default value for the parameter. If one is given, the argument becomes optional, otherwise it is required. desc (str, optional): A description of the parameter, will be added to the `--help` doc. callback (t.Callable, optional): a Callable object that can be used to modify the value of this parameter. prompt (str, optional): A string to provide the user with as a prompt to request input from STDIN when none is provided from the command line. envvar (str, optional): Name of an enviroment variable to obtain a value from if one is not provided on the command line. get (at.GetterFunc, optional): Callable object to retrive a possible value for the command if one is not provided on the command line. complete (at.CompletionFunc, optional): Function to provide shell completions for this parameter. # Example ```py @cli.command() def test(val: int = Option()): arc.print(val) ``` ``` $ python example.py test --val 2 2 ``` \"\"\" return ParamInfo ( param_cls = param . OptionParam , param_name = name , short = short , default = default , desc = desc , callback = callback , prompt = prompt , envvar = envvar , getter_func = get , complete = complete , data = kwargs , )","title":"Example"},{"location":"reference/define/param/groups/","text":"define.param.groups \u00b6 group ( cls = None , * , exclude = None , ** kwargs ) \u00b6 Construct a Parameter group. Parameters: Name Type Description Default cls T The class to make into a parameter group None exclude t . Sequence [ str ] | None List of type to exclude from the parameter list. Useful if you assign values to the class instance at runtime, but still want to annotate them in your type hints None Returns: Name Type Description type T | t . Callable [[ T ], T ] The modified class Example: import arc @arc . group class MyGroup (): name : str @arc . command def command ( group : MyGroup ): print ( group . name ) command ( \"Sean\" ) Source code in /home/runner/work/arc/arc/arc/define/param/groups.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def group ( cls : T = None , * , exclude : t . Sequence [ str ] | None = None , ** kwargs : t . Any ) -> T | t . Callable [[ T ], T ]: \"\"\"Construct a Parameter group. Args: cls (T, optional): The class to make into a parameter group exclude (t.Sequence[str] | None, optional): List of type to exclude from the parameter list. Useful if you assign values to the class instance at runtime, but still want to annotate them in your type hints Returns: type: The modified class Example: ```py import arc @arc.group class MyGroup(): name: str @arc.command def command(group: MyGroup): print(group.name) command(\"Sean\") ``` \"\"\" if cls : return modify_group_cls ( cls , t . cast ( dict [ str , t . Any ], _default_group_options )) def inner ( cls : T ) -> T : return modify_group_cls ( cls , { \"exclude\" : exclude or [], ** kwargs }) return inner groupoptions ( cls ) \u00b6 Returns a dictionary representing the options passed in when a parameter group was created. Should be used in conjuction with isgroup() . Parameters: Name Type Description Default cls type Parameter Group Class required Raises: Type Description TypeError If the passed in type is not a parameter group Returns: Name Type Description ParamGroupOptions at . ParamGroupOptions The options dictionary Source code in /home/runner/work/arc/arc/arc/define/param/groups.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def groupoptions ( cls : type ) -> at . ParamGroupOptions : \"\"\"Returns a dictionary representing the options passed in when a parameter group was created. Should be used in conjuction with [`isgroup()`][arc.define.param.groups.isgroup]. Args: cls (type): Parameter Group Class Raises: TypeError: If the passed in type is not a parameter group Returns: ParamGroupOptions: The options dictionary \"\"\" if not isgroup ( cls ): raise TypeError ( f \" { cls } is not a parameter group\" ) return getattr ( cls , \"__arc_group__\" ) isgroup ( cls ) \u00b6 Returns a boolean whether or not a given type is an arc parameter group Source code in /home/runner/work/arc/arc/arc/define/param/groups.py 110 111 112 113 def isgroup ( cls : type ) -> bool : \"\"\"Returns a boolean whether or not a given type is an arc parameter group\"\"\" return hasattr ( cls , \"__arc_group__\" )","title":"define.param.groups"},{"location":"reference/define/param/groups/#defineparamgroups","text":"","title":"define.param.groups"},{"location":"reference/define/param/groups/#arc.define.param.groups.group","text":"Construct a Parameter group. Parameters: Name Type Description Default cls T The class to make into a parameter group None exclude t . Sequence [ str ] | None List of type to exclude from the parameter list. Useful if you assign values to the class instance at runtime, but still want to annotate them in your type hints None Returns: Name Type Description type T | t . Callable [[ T ], T ] The modified class Example: import arc @arc . group class MyGroup (): name : str @arc . command def command ( group : MyGroup ): print ( group . name ) command ( \"Sean\" ) Source code in /home/runner/work/arc/arc/arc/define/param/groups.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def group ( cls : T = None , * , exclude : t . Sequence [ str ] | None = None , ** kwargs : t . Any ) -> T | t . Callable [[ T ], T ]: \"\"\"Construct a Parameter group. Args: cls (T, optional): The class to make into a parameter group exclude (t.Sequence[str] | None, optional): List of type to exclude from the parameter list. Useful if you assign values to the class instance at runtime, but still want to annotate them in your type hints Returns: type: The modified class Example: ```py import arc @arc.group class MyGroup(): name: str @arc.command def command(group: MyGroup): print(group.name) command(\"Sean\") ``` \"\"\" if cls : return modify_group_cls ( cls , t . cast ( dict [ str , t . Any ], _default_group_options )) def inner ( cls : T ) -> T : return modify_group_cls ( cls , { \"exclude\" : exclude or [], ** kwargs }) return inner","title":"group()"},{"location":"reference/define/param/groups/#arc.define.param.groups.groupoptions","text":"Returns a dictionary representing the options passed in when a parameter group was created. Should be used in conjuction with isgroup() . Parameters: Name Type Description Default cls type Parameter Group Class required Raises: Type Description TypeError If the passed in type is not a parameter group Returns: Name Type Description ParamGroupOptions at . ParamGroupOptions The options dictionary Source code in /home/runner/work/arc/arc/arc/define/param/groups.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def groupoptions ( cls : type ) -> at . ParamGroupOptions : \"\"\"Returns a dictionary representing the options passed in when a parameter group was created. Should be used in conjuction with [`isgroup()`][arc.define.param.groups.isgroup]. Args: cls (type): Parameter Group Class Raises: TypeError: If the passed in type is not a parameter group Returns: ParamGroupOptions: The options dictionary \"\"\" if not isgroup ( cls ): raise TypeError ( f \" { cls } is not a parameter group\" ) return getattr ( cls , \"__arc_group__\" )","title":"groupoptions()"},{"location":"reference/define/param/groups/#arc.define.param.groups.isgroup","text":"Returns a boolean whether or not a given type is an arc parameter group Source code in /home/runner/work/arc/arc/arc/define/param/groups.py 110 111 112 113 def isgroup ( cls : type ) -> bool : \"\"\"Returns a boolean whether or not a given type is an arc parameter group\"\"\" return hasattr ( cls , \"__arc_group__\" )","title":"isgroup()"},{"location":"reference/define/param/param/","text":"define.param.param \u00b6 InjectedParam \u00b6 Bases: Param [ T ] Injected Params are params whose values do not come from the command line, but from a dependancy injection. Used to get access to things like the arc Context and State Source code in /home/runner/work/arc/arc/arc/define/param/param.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 class InjectedParam ( Param [ T ]): \"\"\"Injected Params are params whose values do not come from the command line, but from a dependancy injection. Used to get access to things like the arc Context and State \"\"\" callback : at . ParamGetter # type: ignore[assignment] def get_injected_value ( self , ctx : t . Any ) -> t . Any : value = api . dispatch_args ( self . callback , ctx , self ) return value @property def is_injected ( self ) -> bool : return True Param \u00b6 Bases: t . Generic [ T ] Source code in /home/runner/work/arc/arc/arc/define/param/param.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class Param ( t . Generic [ T ]): argument_name : str \"\"\"The cannonical name of the function's argument\"\"\" param_name : str \"\"\"The names used on the command line / for parsing\"\"\" short_name : str | None \"\"\"Optional single-character name alternabive for keyword params\"\"\" type : TypeInfo [ T ] \"\"\"Information on the type of the argument\"\"\" default : T | Constant | None \"\"\"Default value for this Param, will be used if no other source provides a value. A value `MISSING` indicates that the parameter is required. Otherwise, the parameter is optional\"\"\" description : str | None \"\"\"Documentation for this parameter. If none is provided explicitly, it may also originate from the command's docstring\"\"\" envvar : str | None \"\"\"Optional Enviroment variable to pull the value from if there is no value provided on the CLI\"\"\" prompt : str | None \"\"\"Optional input prompt text to pull the value from stdin with when no valus is provided on the CLI\"\"\" action : Action | t . Type [ argparse . Action ] \"\"\"argparse action associated with this param\"\"\" expose : bool \"\"\"If a param is 'exposed' it will be passed to the command's callback. If it's not 'exposed' then it will not be passed to the command's callback. This is useful when the parameter's side effects are desired, but the value doesn't matter. This is used to implment the `--version` and `--help` flags\"\"\" comp_func : at . CompletionFunc | None \"\"\"Function that can provide shell completions for the parameter\"\"\" getter_func : at . ParamGetter | None \"\"\"Function that can retrieve a value not provided on the command line\"\"\" data : dict [ str , t . Any ] \"\"\"Dictionary of any other key values passed to the constructors\"\"\" def __init__ ( self , argument_name : str , type : TypeInfo [ T ], default : T | None | Constant = MISSING , param_name : str | None = None , short_name : str | None = None , description : str | None = None , callback : at . ParamCallback | None = None , envvar : str | None = None , prompt : str | None = None , action : Action | t . Type [ argparse . Action ] | None = None , expose : bool = True , comp_func : at . CompletionFunc | None = None , getter_func : at . ParamGetter | None = None , data : dict [ str , t . Any ] = None , ): self . argument_name = argument_name self . param_name = param_name or argument_name self . type = type self . short_name = short_name self . default = default self . description = description self . callback = callback self . envvar = envvar self . prompt = prompt self . action = action or Action . STORE self . expose = expose self . comp_func = comp_func self . getter_func = getter_func self . data = data or {} if self . type . is_optional_type and self . default is MISSING : self . default = None __repr__ = api . display ( \"argument_name\" , \"type\" ) def __completions__ ( self , info : CompletionInfo , * args : t . Any , ** kwargs : t . Any ) -> at . CompletionReturn : if self . comp_func : return self . comp_func ( info , self ) if hasattr ( self . type . resolved_type , \"__completions__\" ): return get_completions ( self . type . resolved_type , info , self ) # type: ignore return None @property def schema ( self ) -> dict [ str , t . Any ]: return { \"argument_name\" : self . argument_name , \"type\" : self . type , \"param_name\" : self . param_name , \"short_name\" : self . short_name , \"default\" : self . default , } @property def is_argument ( self ) -> bool : return False @property def is_keyword ( self ) -> bool : return False @property def is_option ( self ) -> bool : return False @property def is_flag ( self ) -> bool : return False @property def is_injected ( self ) -> bool : return False @property def is_optional ( self ) -> bool : return self . type . is_optional_type or self . default is not MISSING @property def is_required ( self ) -> bool : return not self . is_optional @property def prompt_string ( self ) -> str : assert isinstance ( self . prompt , str ), \"No prompt string provided\" if self . default is not MISSING : return self . prompt + colorize ( f \" ( { self . default } ) \" , fg . GREY ) return self . prompt @property def cli_name ( self ) -> str : return self . param_name @property def parser_default ( self ) -> t . Any : return MISSING @cached_property def nargs ( self ) -> at . NArgs : if ( safe . issubclass ( self . type . origin , tuple ) and self . type . sub_types and self . type . sub_types [ - 1 ] . origin is not Ellipsis ): return len ( self . type . sub_types ) # Consume a specific number elif self . type . is_collection_type : return \"*\" # Consume one or more return \"?\" # Optional def convert ( self , value : t . Any ) -> T : return convert_type ( self . type . resolved_type , value , self . type ) def run_middleware ( self , value : t . Any , ctx : t . Any ) -> t . Any : for middleware in self . type . middleware : value = api . dispatch_args ( middleware , value , ctx , self ) return value def get_param_names ( self ) -> list [ str ]: return [] action : Action | t . Type [ argparse . Action ] = action or Action . STORE instance-attribute \u00b6 argparse action associated with this param argument_name : str = argument_name instance-attribute \u00b6 The cannonical name of the function's argument comp_func : at . CompletionFunc | None = comp_func instance-attribute \u00b6 Function that can provide shell completions for the parameter data : dict [ str , t . Any ] = data or {} instance-attribute \u00b6 Dictionary of any other key values passed to the constructors default : T | Constant | None = default instance-attribute \u00b6 Default value for this Param, will be used if no other source provides a value. A value MISSING indicates that the parameter is required. Otherwise, the parameter is optional description : str | None = description instance-attribute \u00b6 Documentation for this parameter. If none is provided explicitly, it may also originate from the command's docstring envvar : str | None = envvar instance-attribute \u00b6 Optional Enviroment variable to pull the value from if there is no value provided on the CLI expose : bool = expose instance-attribute \u00b6 If a param is 'exposed' it will be passed to the command's callback. If it's not 'exposed' then it will not be passed to the command's callback. This is useful when the parameter's side effects are desired, but the value doesn't matter. This is used to implment the --version and --help flags getter_func : at . ParamGetter | None = getter_func instance-attribute \u00b6 Function that can retrieve a value not provided on the command line param_name : str = param_name or argument_name instance-attribute \u00b6 The names used on the command line / for parsing prompt : str | None = prompt instance-attribute \u00b6 Optional input prompt text to pull the value from stdin with when no valus is provided on the CLI short_name : str | None = short_name instance-attribute \u00b6 Optional single-character name alternabive for keyword params type : TypeInfo [ T ] = type instance-attribute \u00b6 Information on the type of the argument","title":"define.param.param"},{"location":"reference/define/param/param/#defineparamparam","text":"","title":"define.param.param"},{"location":"reference/define/param/param/#arc.define.param.param.InjectedParam","text":"Bases: Param [ T ] Injected Params are params whose values do not come from the command line, but from a dependancy injection. Used to get access to things like the arc Context and State Source code in /home/runner/work/arc/arc/arc/define/param/param.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 class InjectedParam ( Param [ T ]): \"\"\"Injected Params are params whose values do not come from the command line, but from a dependancy injection. Used to get access to things like the arc Context and State \"\"\" callback : at . ParamGetter # type: ignore[assignment] def get_injected_value ( self , ctx : t . Any ) -> t . Any : value = api . dispatch_args ( self . callback , ctx , self ) return value @property def is_injected ( self ) -> bool : return True","title":"InjectedParam"},{"location":"reference/define/param/param/#arc.define.param.param.Param","text":"Bases: t . Generic [ T ] Source code in /home/runner/work/arc/arc/arc/define/param/param.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class Param ( t . Generic [ T ]): argument_name : str \"\"\"The cannonical name of the function's argument\"\"\" param_name : str \"\"\"The names used on the command line / for parsing\"\"\" short_name : str | None \"\"\"Optional single-character name alternabive for keyword params\"\"\" type : TypeInfo [ T ] \"\"\"Information on the type of the argument\"\"\" default : T | Constant | None \"\"\"Default value for this Param, will be used if no other source provides a value. A value `MISSING` indicates that the parameter is required. Otherwise, the parameter is optional\"\"\" description : str | None \"\"\"Documentation for this parameter. If none is provided explicitly, it may also originate from the command's docstring\"\"\" envvar : str | None \"\"\"Optional Enviroment variable to pull the value from if there is no value provided on the CLI\"\"\" prompt : str | None \"\"\"Optional input prompt text to pull the value from stdin with when no valus is provided on the CLI\"\"\" action : Action | t . Type [ argparse . Action ] \"\"\"argparse action associated with this param\"\"\" expose : bool \"\"\"If a param is 'exposed' it will be passed to the command's callback. If it's not 'exposed' then it will not be passed to the command's callback. This is useful when the parameter's side effects are desired, but the value doesn't matter. This is used to implment the `--version` and `--help` flags\"\"\" comp_func : at . CompletionFunc | None \"\"\"Function that can provide shell completions for the parameter\"\"\" getter_func : at . ParamGetter | None \"\"\"Function that can retrieve a value not provided on the command line\"\"\" data : dict [ str , t . Any ] \"\"\"Dictionary of any other key values passed to the constructors\"\"\" def __init__ ( self , argument_name : str , type : TypeInfo [ T ], default : T | None | Constant = MISSING , param_name : str | None = None , short_name : str | None = None , description : str | None = None , callback : at . ParamCallback | None = None , envvar : str | None = None , prompt : str | None = None , action : Action | t . Type [ argparse . Action ] | None = None , expose : bool = True , comp_func : at . CompletionFunc | None = None , getter_func : at . ParamGetter | None = None , data : dict [ str , t . Any ] = None , ): self . argument_name = argument_name self . param_name = param_name or argument_name self . type = type self . short_name = short_name self . default = default self . description = description self . callback = callback self . envvar = envvar self . prompt = prompt self . action = action or Action . STORE self . expose = expose self . comp_func = comp_func self . getter_func = getter_func self . data = data or {} if self . type . is_optional_type and self . default is MISSING : self . default = None __repr__ = api . display ( \"argument_name\" , \"type\" ) def __completions__ ( self , info : CompletionInfo , * args : t . Any , ** kwargs : t . Any ) -> at . CompletionReturn : if self . comp_func : return self . comp_func ( info , self ) if hasattr ( self . type . resolved_type , \"__completions__\" ): return get_completions ( self . type . resolved_type , info , self ) # type: ignore return None @property def schema ( self ) -> dict [ str , t . Any ]: return { \"argument_name\" : self . argument_name , \"type\" : self . type , \"param_name\" : self . param_name , \"short_name\" : self . short_name , \"default\" : self . default , } @property def is_argument ( self ) -> bool : return False @property def is_keyword ( self ) -> bool : return False @property def is_option ( self ) -> bool : return False @property def is_flag ( self ) -> bool : return False @property def is_injected ( self ) -> bool : return False @property def is_optional ( self ) -> bool : return self . type . is_optional_type or self . default is not MISSING @property def is_required ( self ) -> bool : return not self . is_optional @property def prompt_string ( self ) -> str : assert isinstance ( self . prompt , str ), \"No prompt string provided\" if self . default is not MISSING : return self . prompt + colorize ( f \" ( { self . default } ) \" , fg . GREY ) return self . prompt @property def cli_name ( self ) -> str : return self . param_name @property def parser_default ( self ) -> t . Any : return MISSING @cached_property def nargs ( self ) -> at . NArgs : if ( safe . issubclass ( self . type . origin , tuple ) and self . type . sub_types and self . type . sub_types [ - 1 ] . origin is not Ellipsis ): return len ( self . type . sub_types ) # Consume a specific number elif self . type . is_collection_type : return \"*\" # Consume one or more return \"?\" # Optional def convert ( self , value : t . Any ) -> T : return convert_type ( self . type . resolved_type , value , self . type ) def run_middleware ( self , value : t . Any , ctx : t . Any ) -> t . Any : for middleware in self . type . middleware : value = api . dispatch_args ( middleware , value , ctx , self ) return value def get_param_names ( self ) -> list [ str ]: return []","title":"Param"},{"location":"reference/define/param/param/#arc.define.param.param.Param.action","text":"argparse action associated with this param","title":"action"},{"location":"reference/define/param/param/#arc.define.param.param.Param.argument_name","text":"The cannonical name of the function's argument","title":"argument_name"},{"location":"reference/define/param/param/#arc.define.param.param.Param.comp_func","text":"Function that can provide shell completions for the parameter","title":"comp_func"},{"location":"reference/define/param/param/#arc.define.param.param.Param.data","text":"Dictionary of any other key values passed to the constructors","title":"data"},{"location":"reference/define/param/param/#arc.define.param.param.Param.default","text":"Default value for this Param, will be used if no other source provides a value. A value MISSING indicates that the parameter is required. Otherwise, the parameter is optional","title":"default"},{"location":"reference/define/param/param/#arc.define.param.param.Param.description","text":"Documentation for this parameter. If none is provided explicitly, it may also originate from the command's docstring","title":"description"},{"location":"reference/define/param/param/#arc.define.param.param.Param.envvar","text":"Optional Enviroment variable to pull the value from if there is no value provided on the CLI","title":"envvar"},{"location":"reference/define/param/param/#arc.define.param.param.Param.expose","text":"If a param is 'exposed' it will be passed to the command's callback. If it's not 'exposed' then it will not be passed to the command's callback. This is useful when the parameter's side effects are desired, but the value doesn't matter. This is used to implment the --version and --help flags","title":"expose"},{"location":"reference/define/param/param/#arc.define.param.param.Param.getter_func","text":"Function that can retrieve a value not provided on the command line","title":"getter_func"},{"location":"reference/define/param/param/#arc.define.param.param.Param.param_name","text":"The names used on the command line / for parsing","title":"param_name"},{"location":"reference/define/param/param/#arc.define.param.param.Param.prompt","text":"Optional input prompt text to pull the value from stdin with when no valus is provided on the CLI","title":"prompt"},{"location":"reference/define/param/param/#arc.define.param.param.Param.short_name","text":"Optional single-character name alternabive for keyword params","title":"short_name"},{"location":"reference/define/param/param/#arc.define.param.param.Param.type","text":"Information on the type of the argument","title":"type"},{"location":"reference/define/param/param_definition/","text":"define.param.param_definition \u00b6 ParamDefinition \u00b6 A tree structure that represents how the parameters to a command look. This represents the definition of a command's paramaters, and not a particular execution of that comamnd with particular values Source code in /home/runner/work/arc/arc/arc/define/param/param_definition.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class ParamDefinition : \"\"\"A tree structure that represents how the parameters to a command look. This represents the definition of a command's paramaters, and not a particular execution of that comamnd with particular values\"\"\" def __init__ ( self , name : str , cls : type | None = None , * args : t . Any , ** kwargs : t . Any , ) -> None : super () . __init__ ( * args , ** kwargs ) self . name : str = name self . cls : type | None = cls self . params = collections . deque [ Param [ t . Any ]]() self . children : list [ ParamDefinition ] = [] __repr__ = api . display ( \"name\" , \"cls\" , \"params\" , \"children\" ) def all_params ( self ) -> t . Generator [ Param [ t . Any ], None , None ]: \"\"\"Generator that yields all params in the tree\"\"\" yield from self . params if self . children : for child in self . children : yield from child . all_params () def create_instance ( self ) -> ParamInstanceTree [ type [ dict [ str , t . Any ]]]: root = self . __create_tree ( self ) return ParamInstanceTree ( root ) def __create_tree ( self , definition : ParamDefinition ) -> ParamInstanceInteriorNode [ t . Any ]: # Create Param instances for all the params of the current group values : list [ ParamInstanceInteriorNode [ t . Any ] | ParamInstanceLeafNode ] = [ ParamInstanceLeafNode ( param . argument_name , MISSING , param ) for param in definition . params ] # Recursively create Param instances for all the children of the current group # (so this would be any sub-groups of the current group) values . extend ( self . __create_tree ( child ) for child in definition . children ) return ParamInstanceInteriorNode ( definition . name , definition . cls or dict , values , ) all_params () \u00b6 Generator that yields all params in the tree Source code in /home/runner/work/arc/arc/arc/define/param/param_definition.py 47 48 49 50 51 52 53 def all_params ( self ) -> t . Generator [ Param [ t . Any ], None , None ]: \"\"\"Generator that yields all params in the tree\"\"\" yield from self . params if self . children : for child in self . children : yield from child . all_params ()","title":"define.param.param_definition"},{"location":"reference/define/param/param_definition/#defineparamparam_definition","text":"","title":"define.param.param_definition"},{"location":"reference/define/param/param_definition/#arc.define.param.param_definition.ParamDefinition","text":"A tree structure that represents how the parameters to a command look. This represents the definition of a command's paramaters, and not a particular execution of that comamnd with particular values Source code in /home/runner/work/arc/arc/arc/define/param/param_definition.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class ParamDefinition : \"\"\"A tree structure that represents how the parameters to a command look. This represents the definition of a command's paramaters, and not a particular execution of that comamnd with particular values\"\"\" def __init__ ( self , name : str , cls : type | None = None , * args : t . Any , ** kwargs : t . Any , ) -> None : super () . __init__ ( * args , ** kwargs ) self . name : str = name self . cls : type | None = cls self . params = collections . deque [ Param [ t . Any ]]() self . children : list [ ParamDefinition ] = [] __repr__ = api . display ( \"name\" , \"cls\" , \"params\" , \"children\" ) def all_params ( self ) -> t . Generator [ Param [ t . Any ], None , None ]: \"\"\"Generator that yields all params in the tree\"\"\" yield from self . params if self . children : for child in self . children : yield from child . all_params () def create_instance ( self ) -> ParamInstanceTree [ type [ dict [ str , t . Any ]]]: root = self . __create_tree ( self ) return ParamInstanceTree ( root ) def __create_tree ( self , definition : ParamDefinition ) -> ParamInstanceInteriorNode [ t . Any ]: # Create Param instances for all the params of the current group values : list [ ParamInstanceInteriorNode [ t . Any ] | ParamInstanceLeafNode ] = [ ParamInstanceLeafNode ( param . argument_name , MISSING , param ) for param in definition . params ] # Recursively create Param instances for all the children of the current group # (so this would be any sub-groups of the current group) values . extend ( self . __create_tree ( child ) for child in definition . children ) return ParamInstanceInteriorNode ( definition . name , definition . cls or dict , values , )","title":"ParamDefinition"},{"location":"reference/define/param/param_definition/#arc.define.param.param_definition.ParamDefinition.all_params","text":"Generator that yields all params in the tree Source code in /home/runner/work/arc/arc/arc/define/param/param_definition.py 47 48 49 50 51 52 53 def all_params ( self ) -> t . Generator [ Param [ t . Any ], None , None ]: \"\"\"Generator that yields all params in the tree\"\"\" yield from self . params if self . children : for child in self . children : yield from child . all_params ()","title":"all_params()"},{"location":"reference/define/param/param_instance/","text":"define.param.param_instance \u00b6 ParamInstanceInteriorNode dataclass \u00b6 Bases: t . Generic [ T ] Tree data stucture that represents all the param values for a particular command execution Source code in /home/runner/work/arc/arc/arc/define/param/param_instance.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @dataclass class ParamInstanceInteriorNode ( t . Generic [ T ]): \"\"\"Tree data stucture that represents all the param values for a particular command execution\"\"\" name : str cls : T children : list [ ParamInstanceInteriorNode [ t . Any ] | ParamInstanceLeafNode ] def leaves ( self ) -> t . Generator [ ParamInstanceLeafNode , None , None ]: for value in self . children : if isinstance ( value , ParamInstanceInteriorNode ): yield from value . leaves () else : yield value def compile ( self , include_hidden : bool = False ) -> T : compiled = {} for child in self . children : if isinstance ( child , ParamInstanceInteriorNode ): compiled [ child . name ] = child . compile ( include_hidden ) else : if child . param . expose or include_hidden : compiled [ child . name ] = child . value return self . cls ( ** compiled )","title":"define.param.param_instance"},{"location":"reference/define/param/param_instance/#defineparamparam_instance","text":"","title":"define.param.param_instance"},{"location":"reference/define/param/param_instance/#arc.define.param.param_instance.ParamInstanceInteriorNode","text":"Bases: t . Generic [ T ] Tree data stucture that represents all the param values for a particular command execution Source code in /home/runner/work/arc/arc/arc/define/param/param_instance.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @dataclass class ParamInstanceInteriorNode ( t . Generic [ T ]): \"\"\"Tree data stucture that represents all the param values for a particular command execution\"\"\" name : str cls : T children : list [ ParamInstanceInteriorNode [ t . Any ] | ParamInstanceLeafNode ] def leaves ( self ) -> t . Generator [ ParamInstanceLeafNode , None , None ]: for value in self . children : if isinstance ( value , ParamInstanceInteriorNode ): yield from value . leaves () else : yield value def compile ( self , include_hidden : bool = False ) -> T : compiled = {} for child in self . children : if isinstance ( child , ParamInstanceInteriorNode ): compiled [ child . name ] = child . compile ( include_hidden ) else : if child . param . expose or include_hidden : compiled [ child . name ] = child . value return self . cls ( ** compiled )","title":"ParamInstanceInteriorNode"},{"location":"reference/define/param/param_mixin/","text":"define.param.param_mixin \u00b6 ParamMixin \u00b6 Source code in /home/runner/work/arc/arc/arc/define/param/param_mixin.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 class ParamMixin : SPECIAL_PARAMS = { \"help\" , \"version\" , \"autocomplete\" } callback : at . CommandCallback parent : t . Any config : Config @cached_property def param_def ( self ) -> ParamDefinition : # NOTE: This gets loaded lazily so we only actually # construct the param tree for the command # that is being executed. In development, # all definitions are constructed to check for # errors root = ParamDefinitionFactory ( lambda : Join . with_space ( t . cast ( \"Command\" , self ) . doc . fullname ), self . config . transform_snake_case , ) . from_function ( self . callback ) self . __add_help_param ( root ) return root @cached_property def param_map ( self ) -> t . Mapping [ str , Param [ t . Any ]]: data : AliasDict [ str , Param [ t . Any ]] = AliasDict () for param in self . params : data [ param . argument_name ] = param data . add_alias ( param . argument_name , param . param_name ) if param . short_name : data . add_alias ( param . argument_name , param . short_name ) data . add_aliases ( param . argument_name , * param . get_param_names ()) return data @property def params ( self ) -> t . Generator [ Param [ t . Any ], None , None ]: yield from self . param_def . all_params () @property def cli_params ( self ) -> t . Generator [ Param [ t . Any ], None , None ]: \"\"\"All params that are available on the command line\"\"\" for param in self . params : if not param . is_injected : yield param @property def argument_params ( self ) -> t . Generator [ ArgumentParam [ t . Any ], None , None ]: for param in self . params : if param . is_argument : yield param # type: ignore @property def key_params ( self ) -> t . Generator [ KeywordParam [ t . Any ], None , None ]: for param in self . params : if param . is_keyword : yield param # type: ignore @property def option_params ( self ) -> t . Generator [ OptionParam [ t . Any ], None , None ]: for param in self . params : if param . is_option : yield param # type: ignore @property def flag_params ( self ) -> t . Generator [ FlagParam , None , None ]: for param in self . params : if param . is_flag : yield param # type: ignore @property def injected_params ( self ) -> t . Generator [ InjectedParam [ t . Any ], None , None ]: for param in self . params : if param . is_injected : yield param # type: ignore def get_param ( self , name : str ) -> t . Optional [ Param [ t . Any ]]: return self . param_map . get ( name ) def __add_help_param ( self , group : ParamDefinition ) -> None : group . params . appendleft ( FlagParam ( \"help\" , short_name = \"h\" , type = TypeInfo . analyze ( bool ), description = \"Displays this help message\" , default = False , action = CustomHelpAction , expose = False , ), ) cli_params : t . Generator [ Param [ t . Any ], None , None ] property \u00b6 All params that are available on the command line","title":"define.param.param_mixin"},{"location":"reference/define/param/param_mixin/#defineparamparam_mixin","text":"","title":"define.param.param_mixin"},{"location":"reference/define/param/param_mixin/#arc.define.param.param_mixin.ParamMixin","text":"Source code in /home/runner/work/arc/arc/arc/define/param/param_mixin.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 class ParamMixin : SPECIAL_PARAMS = { \"help\" , \"version\" , \"autocomplete\" } callback : at . CommandCallback parent : t . Any config : Config @cached_property def param_def ( self ) -> ParamDefinition : # NOTE: This gets loaded lazily so we only actually # construct the param tree for the command # that is being executed. In development, # all definitions are constructed to check for # errors root = ParamDefinitionFactory ( lambda : Join . with_space ( t . cast ( \"Command\" , self ) . doc . fullname ), self . config . transform_snake_case , ) . from_function ( self . callback ) self . __add_help_param ( root ) return root @cached_property def param_map ( self ) -> t . Mapping [ str , Param [ t . Any ]]: data : AliasDict [ str , Param [ t . Any ]] = AliasDict () for param in self . params : data [ param . argument_name ] = param data . add_alias ( param . argument_name , param . param_name ) if param . short_name : data . add_alias ( param . argument_name , param . short_name ) data . add_aliases ( param . argument_name , * param . get_param_names ()) return data @property def params ( self ) -> t . Generator [ Param [ t . Any ], None , None ]: yield from self . param_def . all_params () @property def cli_params ( self ) -> t . Generator [ Param [ t . Any ], None , None ]: \"\"\"All params that are available on the command line\"\"\" for param in self . params : if not param . is_injected : yield param @property def argument_params ( self ) -> t . Generator [ ArgumentParam [ t . Any ], None , None ]: for param in self . params : if param . is_argument : yield param # type: ignore @property def key_params ( self ) -> t . Generator [ KeywordParam [ t . Any ], None , None ]: for param in self . params : if param . is_keyword : yield param # type: ignore @property def option_params ( self ) -> t . Generator [ OptionParam [ t . Any ], None , None ]: for param in self . params : if param . is_option : yield param # type: ignore @property def flag_params ( self ) -> t . Generator [ FlagParam , None , None ]: for param in self . params : if param . is_flag : yield param # type: ignore @property def injected_params ( self ) -> t . Generator [ InjectedParam [ t . Any ], None , None ]: for param in self . params : if param . is_injected : yield param # type: ignore def get_param ( self , name : str ) -> t . Optional [ Param [ t . Any ]]: return self . param_map . get ( name ) def __add_help_param ( self , group : ParamDefinition ) -> None : group . params . appendleft ( FlagParam ( \"help\" , short_name = \"h\" , type = TypeInfo . analyze ( bool ), description = \"Displays this help message\" , default = False , action = CustomHelpAction , expose = False , ), )","title":"ParamMixin"},{"location":"reference/define/param/param_mixin/#arc.define.param.param_mixin.ParamMixin.cli_params","text":"All params that are available on the command line","title":"cli_params"},{"location":"reference/present/ansi/","text":"present.ansi \u00b6 Module contains code relavent to ANSI escape codes Ansi \u00b6 Utility methods for ANSI color codes Source code in /home/runner/work/arc/arc/arc/present/ansi.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Ansi : \"\"\"Utility methods for ANSI color codes\"\"\" def __init__ ( self , content : t . Any ): self . __content = content def __str__ ( self ) -> str : return f \" \\033 [ { self . __content } \" @classmethod def clean ( cls , string : str ) -> str : \"\"\"Gets rid of escape sequences\"\"\" return cls . __ansi_escape () . sub ( \"\" , string ) @classmethod def len ( cls , string : str ) -> int : \"\"\"Length of a string, not including escape sequences\"\"\" length = 0 in_escape_code = False for char in string : if in_escape_code and char == \"m\" : in_escape_code = False elif char == \" \\x1b \" or in_escape_code : in_escape_code = True else : length += 1 return length @classmethod @functools . cache def __ansi_escape ( self ) -> re . Pattern [ str ]: return re . compile ( r \"(\\x9B|\\x1B\\[)[0-?]*[ -\\/]*[@-~]\" ) clean ( string ) classmethod \u00b6 Gets rid of escape sequences Source code in /home/runner/work/arc/arc/arc/present/ansi.py 16 17 18 19 @classmethod def clean ( cls , string : str ) -> str : \"\"\"Gets rid of escape sequences\"\"\" return cls . __ansi_escape () . sub ( \"\" , string ) len ( string ) classmethod \u00b6 Length of a string, not including escape sequences Source code in /home/runner/work/arc/arc/arc/present/ansi.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @classmethod def len ( cls , string : str ) -> int : \"\"\"Length of a string, not including escape sequences\"\"\" length = 0 in_escape_code = False for char in string : if in_escape_code and char == \"m\" : in_escape_code = False elif char == \" \\x1b \" or in_escape_code : in_escape_code = True else : length += 1 return length bg \u00b6 Background colors Source code in /home/runner/work/arc/arc/arc/present/ansi.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class bg : \"\"\"Background colors\"\"\" BLACK = \" \\033 [40m\" \"\"\"Escape code for background ANIS black\"\"\" RED = \" \\033 [41m\" \"\"\"Escape code for background ANIS red\"\"\" GREEN = \" \\033 [42m\" \"\"\"Escape code for background ANIS green\"\"\" YELLOW = \" \\033 [43m\" \"\"\"Escape code for background ANIS yellow\"\"\" BLUE = \" \\033 [44m\" \"\"\"Escape code for background ANIS blue\"\"\" MAGENTA = \" \\033 [45m\" \"\"\"Escape code for background ANIS magenta\"\"\" CYAN = \" \\033 [46m\" \"\"\"Escape code for background ANIS cyan\"\"\" WHITE = \" \\033 [47m\" \"\"\"Escape code for background ANIS white\"\"\" GREY = \" \\033 [100m\" \"\"\"Escape code for background ANIS grey\"\"\" BRIGHT_RED = \" \\033 [101m\" \"\"\"Escape code for background ANIS bright red\"\"\" BRIGHT_GREEN = \" \\033 [102m\" \"\"\"Escape code for background ANIS bright green\"\"\" BRIGHT_YELLOW = \" \\033 [103m\" \"\"\"Escape code for background ANIS bright yellow\"\"\" BRIGHT_BLUE = \" \\033 [104m\" \"\"\"Escape code for background ANIS bright blue\"\"\" BRIGHT_MAGENTA = \" \\033 [105m\" \"\"\"Escape code for background ANIS bright magenta\"\"\" BRIGHT_CYAN = \" \\033 [106m\" \"\"\"Escape code for background ANIS bright cyan\"\"\" BRIGHT_WHITE = \" \\033 [107m\" \"\"\"Escape code for background ANIS bright white\"\"\" ARC_BLUE = \" \\033 [48;2;59;192;240m\" \"\"\"The blue used in arc branding\"\"\" @staticmethod def rgb ( red : int = 0 , green : int = 0 , blue : int = 0 ) -> str : \"\"\"Returns the **background** escape sequence for the provided rgb values\"\"\" return _rgb ( 48 , red , green , blue ) @staticmethod def hex ( hex_code : str | int ) -> str : \"\"\"Returns the **background** escape sequence for the provided hex value\"\"\" return _rgb ( 48 , * _hex_to_rgb ( hex_code )) ARC_BLUE = ' \\x1b [48;2;59;192;240m' class-attribute instance-attribute \u00b6 The blue used in arc branding BLACK = ' \\x1b [40m' class-attribute instance-attribute \u00b6 Escape code for background ANIS black BLUE = ' \\x1b [44m' class-attribute instance-attribute \u00b6 Escape code for background ANIS blue BRIGHT_BLUE = ' \\x1b [104m' class-attribute instance-attribute \u00b6 Escape code for background ANIS bright blue BRIGHT_CYAN = ' \\x1b [106m' class-attribute instance-attribute \u00b6 Escape code for background ANIS bright cyan BRIGHT_GREEN = ' \\x1b [102m' class-attribute instance-attribute \u00b6 Escape code for background ANIS bright green BRIGHT_MAGENTA = ' \\x1b [105m' class-attribute instance-attribute \u00b6 Escape code for background ANIS bright magenta BRIGHT_RED = ' \\x1b [101m' class-attribute instance-attribute \u00b6 Escape code for background ANIS bright red BRIGHT_WHITE = ' \\x1b [107m' class-attribute instance-attribute \u00b6 Escape code for background ANIS bright white BRIGHT_YELLOW = ' \\x1b [103m' class-attribute instance-attribute \u00b6 Escape code for background ANIS bright yellow CYAN = ' \\x1b [46m' class-attribute instance-attribute \u00b6 Escape code for background ANIS cyan GREEN = ' \\x1b [42m' class-attribute instance-attribute \u00b6 Escape code for background ANIS green GREY = ' \\x1b [100m' class-attribute instance-attribute \u00b6 Escape code for background ANIS grey MAGENTA = ' \\x1b [45m' class-attribute instance-attribute \u00b6 Escape code for background ANIS magenta RED = ' \\x1b [41m' class-attribute instance-attribute \u00b6 Escape code for background ANIS red WHITE = ' \\x1b [47m' class-attribute instance-attribute \u00b6 Escape code for background ANIS white YELLOW = ' \\x1b [43m' class-attribute instance-attribute \u00b6 Escape code for background ANIS yellow hex ( hex_code ) staticmethod \u00b6 Returns the background escape sequence for the provided hex value Source code in /home/runner/work/arc/arc/arc/present/ansi.py 138 139 140 141 142 @staticmethod def hex ( hex_code : str | int ) -> str : \"\"\"Returns the **background** escape sequence for the provided hex value\"\"\" return _rgb ( 48 , * _hex_to_rgb ( hex_code )) rgb ( red = 0 , green = 0 , blue = 0 ) staticmethod \u00b6 Returns the background escape sequence for the provided rgb values Source code in /home/runner/work/arc/arc/arc/present/ansi.py 132 133 134 135 136 @staticmethod def rgb ( red : int = 0 , green : int = 0 , blue : int = 0 ) -> str : \"\"\"Returns the **background** escape sequence for the provided rgb values\"\"\" return _rgb ( 48 , red , green , blue ) fg \u00b6 Foreground colors Source code in /home/runner/work/arc/arc/arc/present/ansi.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class fg : \"\"\"Foreground colors\"\"\" BLACK = \" \\033 [30m\" \"\"\"Escape code for foreground ANSI black\"\"\" RED = \" \\033 [31m\" \"\"\"Escape code for foreground ANSI red\"\"\" GREEN = \" \\033 [32m\" \"\"\"Escape code for foreground ANSI green\"\"\" YELLOW = \" \\033 [33m\" \"\"\"Escape code for foreground ANSI yellow\"\"\" BLUE = \" \\033 [34m\" \"\"\"Escape code for foreground ANSI blue\"\"\" MAGENTA = \" \\033 [35m\" \"\"\"Escape code for foreground ANSI magenta\"\"\" CYAN = \" \\033 [36m\" \"\"\"Escape code for foreground ANSI cyan\"\"\" WHITE = \" \\033 [37m\" \"\"\"Escape code for foreground ANSI white\"\"\" GREY = \" \\033 [90m\" \"\"\"Escape code for foreground ANSI grey\"\"\" BRIGHT_RED = \" \\033 [91m\" \"\"\"Escape code for foreground ANSI bright red\"\"\" BRIGHT_GREEN = \" \\033 [92m\" \"\"\"Escape code for foreground ANSI bright green\"\"\" BRIGHT_YELLOW = \" \\033 [93m\" \"\"\"Escape code for foreground ANSI bright yellow\"\"\" BRIGHT_BLUE = \" \\033 [94m\" \"\"\"Escape code for foreground ANSI brightblue\"\"\" BRIGHT_MAGENTA = \" \\033 [95m\" \"\"\"Escape code for foreground ANSI bright magenta\"\"\" BRIGHT_CYAN = \" \\033 [96m\" \"\"\"Escape code for foreground ANSI bright cyan\"\"\" BRIGHT_WHITE = \" \\033 [97m\" \"\"\"Escape code for foreground ANSI bright white\"\"\" ARC_BLUE = \" \\033 [38;2;59;192;240m\" \"\"\"The blue used in arc branding\"\"\" @staticmethod def rgb ( red : int = 0 , green : int = 0 , blue : int = 0 ) -> str : \"\"\"Returns the **foreground** escape sequence for the provided rgb values\"\"\" return _rgb ( 38 , red , green , blue ) @staticmethod def hex ( hex_code : str | int ) -> str : \"\"\"Returns the **foreground** escape sequence for the provided hex values\"\"\" return _rgb ( 38 , * _hex_to_rgb ( hex_code )) ARC_BLUE = ' \\x1b [38;2;59;192;240m' class-attribute instance-attribute \u00b6 The blue used in arc branding BLACK = ' \\x1b [30m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI black BLUE = ' \\x1b [34m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI blue BRIGHT_BLUE = ' \\x1b [94m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI brightblue BRIGHT_CYAN = ' \\x1b [96m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI bright cyan BRIGHT_GREEN = ' \\x1b [92m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI bright green BRIGHT_MAGENTA = ' \\x1b [95m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI bright magenta BRIGHT_RED = ' \\x1b [91m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI bright red BRIGHT_WHITE = ' \\x1b [97m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI bright white BRIGHT_YELLOW = ' \\x1b [93m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI bright yellow CYAN = ' \\x1b [36m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI cyan GREEN = ' \\x1b [32m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI green GREY = ' \\x1b [90m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI grey MAGENTA = ' \\x1b [35m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI magenta RED = ' \\x1b [31m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI red WHITE = ' \\x1b [37m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI white YELLOW = ' \\x1b [33m' class-attribute instance-attribute \u00b6 Escape code for foreground ANSI yellow hex ( hex_code ) staticmethod \u00b6 Returns the foreground escape sequence for the provided hex values Source code in /home/runner/work/arc/arc/arc/present/ansi.py 87 88 89 90 91 @staticmethod def hex ( hex_code : str | int ) -> str : \"\"\"Returns the **foreground** escape sequence for the provided hex values\"\"\" return _rgb ( 38 , * _hex_to_rgb ( hex_code )) rgb ( red = 0 , green = 0 , blue = 0 ) staticmethod \u00b6 Returns the foreground escape sequence for the provided rgb values Source code in /home/runner/work/arc/arc/arc/present/ansi.py 81 82 83 84 85 @staticmethod def rgb ( red : int = 0 , green : int = 0 , blue : int = 0 ) -> str : \"\"\"Returns the **foreground** escape sequence for the provided rgb values\"\"\" return _rgb ( 38 , red , green , blue ) fx \u00b6 Other effects like CLEAR or BOLD . Support from terminal to terminal may vary Source code in /home/runner/work/arc/arc/arc/present/ansi.py 145 146 147 148 149 150 151 152 153 class fx : \"\"\"Other effects like `CLEAR` or `BOLD`. Support from terminal to terminal may vary\"\"\" CLEAR = \" \\033 [0m\" BOLD = \" \\033 [1m\" ITALIC = \" \\033 [3m\" UNDERLINE = \" \\033 [4m\" STRIKETHROUGH = \" \\033 [9m\" colorize ( string , * codes , clear = True ) \u00b6 Applies colors / effects to an entire string Parameters: Name Type Description Default string str String to colorize required *codes str colors / effects to apply to the strin () clear bool Whether or not to append effects.CLEAR to the end of the string which will prevent any subsequent strings from recieving the styles. Defaults to True True Returns: Name Type Description string str The colorized string Source code in /home/runner/work/arc/arc/arc/present/ansi.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def colorize ( string : str , * codes : str , clear : bool = True ) -> str : \"\"\"Applies colors / effects to an entire string Args: string (str): String to colorize *codes (str): colors / effects to apply to the strin clear (bool): Whether or not to append `effects.CLEAR` to the end of the string which will prevent any subsequent strings from recieving the styles. Defaults to True Returns: string: The colorized string \"\"\" return f \" { '' . join ( str ( code ) for code in codes ) }{ string }{ fx . CLEAR if clear else '' } \"","title":"present.ansi"},{"location":"reference/present/ansi/#presentansi","text":"Module contains code relavent to ANSI escape codes","title":"present.ansi"},{"location":"reference/present/ansi/#arc.present.ansi.Ansi","text":"Utility methods for ANSI color codes Source code in /home/runner/work/arc/arc/arc/present/ansi.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Ansi : \"\"\"Utility methods for ANSI color codes\"\"\" def __init__ ( self , content : t . Any ): self . __content = content def __str__ ( self ) -> str : return f \" \\033 [ { self . __content } \" @classmethod def clean ( cls , string : str ) -> str : \"\"\"Gets rid of escape sequences\"\"\" return cls . __ansi_escape () . sub ( \"\" , string ) @classmethod def len ( cls , string : str ) -> int : \"\"\"Length of a string, not including escape sequences\"\"\" length = 0 in_escape_code = False for char in string : if in_escape_code and char == \"m\" : in_escape_code = False elif char == \" \\x1b \" or in_escape_code : in_escape_code = True else : length += 1 return length @classmethod @functools . cache def __ansi_escape ( self ) -> re . Pattern [ str ]: return re . compile ( r \"(\\x9B|\\x1B\\[)[0-?]*[ -\\/]*[@-~]\" )","title":"Ansi"},{"location":"reference/present/ansi/#arc.present.ansi.Ansi.clean","text":"Gets rid of escape sequences Source code in /home/runner/work/arc/arc/arc/present/ansi.py 16 17 18 19 @classmethod def clean ( cls , string : str ) -> str : \"\"\"Gets rid of escape sequences\"\"\" return cls . __ansi_escape () . sub ( \"\" , string )","title":"clean()"},{"location":"reference/present/ansi/#arc.present.ansi.Ansi.len","text":"Length of a string, not including escape sequences Source code in /home/runner/work/arc/arc/arc/present/ansi.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @classmethod def len ( cls , string : str ) -> int : \"\"\"Length of a string, not including escape sequences\"\"\" length = 0 in_escape_code = False for char in string : if in_escape_code and char == \"m\" : in_escape_code = False elif char == \" \\x1b \" or in_escape_code : in_escape_code = True else : length += 1 return length","title":"len()"},{"location":"reference/present/ansi/#arc.present.ansi.bg","text":"Background colors Source code in /home/runner/work/arc/arc/arc/present/ansi.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class bg : \"\"\"Background colors\"\"\" BLACK = \" \\033 [40m\" \"\"\"Escape code for background ANIS black\"\"\" RED = \" \\033 [41m\" \"\"\"Escape code for background ANIS red\"\"\" GREEN = \" \\033 [42m\" \"\"\"Escape code for background ANIS green\"\"\" YELLOW = \" \\033 [43m\" \"\"\"Escape code for background ANIS yellow\"\"\" BLUE = \" \\033 [44m\" \"\"\"Escape code for background ANIS blue\"\"\" MAGENTA = \" \\033 [45m\" \"\"\"Escape code for background ANIS magenta\"\"\" CYAN = \" \\033 [46m\" \"\"\"Escape code for background ANIS cyan\"\"\" WHITE = \" \\033 [47m\" \"\"\"Escape code for background ANIS white\"\"\" GREY = \" \\033 [100m\" \"\"\"Escape code for background ANIS grey\"\"\" BRIGHT_RED = \" \\033 [101m\" \"\"\"Escape code for background ANIS bright red\"\"\" BRIGHT_GREEN = \" \\033 [102m\" \"\"\"Escape code for background ANIS bright green\"\"\" BRIGHT_YELLOW = \" \\033 [103m\" \"\"\"Escape code for background ANIS bright yellow\"\"\" BRIGHT_BLUE = \" \\033 [104m\" \"\"\"Escape code for background ANIS bright blue\"\"\" BRIGHT_MAGENTA = \" \\033 [105m\" \"\"\"Escape code for background ANIS bright magenta\"\"\" BRIGHT_CYAN = \" \\033 [106m\" \"\"\"Escape code for background ANIS bright cyan\"\"\" BRIGHT_WHITE = \" \\033 [107m\" \"\"\"Escape code for background ANIS bright white\"\"\" ARC_BLUE = \" \\033 [48;2;59;192;240m\" \"\"\"The blue used in arc branding\"\"\" @staticmethod def rgb ( red : int = 0 , green : int = 0 , blue : int = 0 ) -> str : \"\"\"Returns the **background** escape sequence for the provided rgb values\"\"\" return _rgb ( 48 , red , green , blue ) @staticmethod def hex ( hex_code : str | int ) -> str : \"\"\"Returns the **background** escape sequence for the provided hex value\"\"\" return _rgb ( 48 , * _hex_to_rgb ( hex_code ))","title":"bg"},{"location":"reference/present/ansi/#arc.present.ansi.bg.ARC_BLUE","text":"The blue used in arc branding","title":"ARC_BLUE"},{"location":"reference/present/ansi/#arc.present.ansi.bg.BLACK","text":"Escape code for background ANIS black","title":"BLACK"},{"location":"reference/present/ansi/#arc.present.ansi.bg.BLUE","text":"Escape code for background ANIS blue","title":"BLUE"},{"location":"reference/present/ansi/#arc.present.ansi.bg.BRIGHT_BLUE","text":"Escape code for background ANIS bright blue","title":"BRIGHT_BLUE"},{"location":"reference/present/ansi/#arc.present.ansi.bg.BRIGHT_CYAN","text":"Escape code for background ANIS bright cyan","title":"BRIGHT_CYAN"},{"location":"reference/present/ansi/#arc.present.ansi.bg.BRIGHT_GREEN","text":"Escape code for background ANIS bright green","title":"BRIGHT_GREEN"},{"location":"reference/present/ansi/#arc.present.ansi.bg.BRIGHT_MAGENTA","text":"Escape code for background ANIS bright magenta","title":"BRIGHT_MAGENTA"},{"location":"reference/present/ansi/#arc.present.ansi.bg.BRIGHT_RED","text":"Escape code for background ANIS bright red","title":"BRIGHT_RED"},{"location":"reference/present/ansi/#arc.present.ansi.bg.BRIGHT_WHITE","text":"Escape code for background ANIS bright white","title":"BRIGHT_WHITE"},{"location":"reference/present/ansi/#arc.present.ansi.bg.BRIGHT_YELLOW","text":"Escape code for background ANIS bright yellow","title":"BRIGHT_YELLOW"},{"location":"reference/present/ansi/#arc.present.ansi.bg.CYAN","text":"Escape code for background ANIS cyan","title":"CYAN"},{"location":"reference/present/ansi/#arc.present.ansi.bg.GREEN","text":"Escape code for background ANIS green","title":"GREEN"},{"location":"reference/present/ansi/#arc.present.ansi.bg.GREY","text":"Escape code for background ANIS grey","title":"GREY"},{"location":"reference/present/ansi/#arc.present.ansi.bg.MAGENTA","text":"Escape code for background ANIS magenta","title":"MAGENTA"},{"location":"reference/present/ansi/#arc.present.ansi.bg.RED","text":"Escape code for background ANIS red","title":"RED"},{"location":"reference/present/ansi/#arc.present.ansi.bg.WHITE","text":"Escape code for background ANIS white","title":"WHITE"},{"location":"reference/present/ansi/#arc.present.ansi.bg.YELLOW","text":"Escape code for background ANIS yellow","title":"YELLOW"},{"location":"reference/present/ansi/#arc.present.ansi.bg.hex","text":"Returns the background escape sequence for the provided hex value Source code in /home/runner/work/arc/arc/arc/present/ansi.py 138 139 140 141 142 @staticmethod def hex ( hex_code : str | int ) -> str : \"\"\"Returns the **background** escape sequence for the provided hex value\"\"\" return _rgb ( 48 , * _hex_to_rgb ( hex_code ))","title":"hex()"},{"location":"reference/present/ansi/#arc.present.ansi.bg.rgb","text":"Returns the background escape sequence for the provided rgb values Source code in /home/runner/work/arc/arc/arc/present/ansi.py 132 133 134 135 136 @staticmethod def rgb ( red : int = 0 , green : int = 0 , blue : int = 0 ) -> str : \"\"\"Returns the **background** escape sequence for the provided rgb values\"\"\" return _rgb ( 48 , red , green , blue )","title":"rgb()"},{"location":"reference/present/ansi/#arc.present.ansi.fg","text":"Foreground colors Source code in /home/runner/work/arc/arc/arc/present/ansi.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class fg : \"\"\"Foreground colors\"\"\" BLACK = \" \\033 [30m\" \"\"\"Escape code for foreground ANSI black\"\"\" RED = \" \\033 [31m\" \"\"\"Escape code for foreground ANSI red\"\"\" GREEN = \" \\033 [32m\" \"\"\"Escape code for foreground ANSI green\"\"\" YELLOW = \" \\033 [33m\" \"\"\"Escape code for foreground ANSI yellow\"\"\" BLUE = \" \\033 [34m\" \"\"\"Escape code for foreground ANSI blue\"\"\" MAGENTA = \" \\033 [35m\" \"\"\"Escape code for foreground ANSI magenta\"\"\" CYAN = \" \\033 [36m\" \"\"\"Escape code for foreground ANSI cyan\"\"\" WHITE = \" \\033 [37m\" \"\"\"Escape code for foreground ANSI white\"\"\" GREY = \" \\033 [90m\" \"\"\"Escape code for foreground ANSI grey\"\"\" BRIGHT_RED = \" \\033 [91m\" \"\"\"Escape code for foreground ANSI bright red\"\"\" BRIGHT_GREEN = \" \\033 [92m\" \"\"\"Escape code for foreground ANSI bright green\"\"\" BRIGHT_YELLOW = \" \\033 [93m\" \"\"\"Escape code for foreground ANSI bright yellow\"\"\" BRIGHT_BLUE = \" \\033 [94m\" \"\"\"Escape code for foreground ANSI brightblue\"\"\" BRIGHT_MAGENTA = \" \\033 [95m\" \"\"\"Escape code for foreground ANSI bright magenta\"\"\" BRIGHT_CYAN = \" \\033 [96m\" \"\"\"Escape code for foreground ANSI bright cyan\"\"\" BRIGHT_WHITE = \" \\033 [97m\" \"\"\"Escape code for foreground ANSI bright white\"\"\" ARC_BLUE = \" \\033 [38;2;59;192;240m\" \"\"\"The blue used in arc branding\"\"\" @staticmethod def rgb ( red : int = 0 , green : int = 0 , blue : int = 0 ) -> str : \"\"\"Returns the **foreground** escape sequence for the provided rgb values\"\"\" return _rgb ( 38 , red , green , blue ) @staticmethod def hex ( hex_code : str | int ) -> str : \"\"\"Returns the **foreground** escape sequence for the provided hex values\"\"\" return _rgb ( 38 , * _hex_to_rgb ( hex_code ))","title":"fg"},{"location":"reference/present/ansi/#arc.present.ansi.fg.ARC_BLUE","text":"The blue used in arc branding","title":"ARC_BLUE"},{"location":"reference/present/ansi/#arc.present.ansi.fg.BLACK","text":"Escape code for foreground ANSI black","title":"BLACK"},{"location":"reference/present/ansi/#arc.present.ansi.fg.BLUE","text":"Escape code for foreground ANSI blue","title":"BLUE"},{"location":"reference/present/ansi/#arc.present.ansi.fg.BRIGHT_BLUE","text":"Escape code for foreground ANSI brightblue","title":"BRIGHT_BLUE"},{"location":"reference/present/ansi/#arc.present.ansi.fg.BRIGHT_CYAN","text":"Escape code for foreground ANSI bright cyan","title":"BRIGHT_CYAN"},{"location":"reference/present/ansi/#arc.present.ansi.fg.BRIGHT_GREEN","text":"Escape code for foreground ANSI bright green","title":"BRIGHT_GREEN"},{"location":"reference/present/ansi/#arc.present.ansi.fg.BRIGHT_MAGENTA","text":"Escape code for foreground ANSI bright magenta","title":"BRIGHT_MAGENTA"},{"location":"reference/present/ansi/#arc.present.ansi.fg.BRIGHT_RED","text":"Escape code for foreground ANSI bright red","title":"BRIGHT_RED"},{"location":"reference/present/ansi/#arc.present.ansi.fg.BRIGHT_WHITE","text":"Escape code for foreground ANSI bright white","title":"BRIGHT_WHITE"},{"location":"reference/present/ansi/#arc.present.ansi.fg.BRIGHT_YELLOW","text":"Escape code for foreground ANSI bright yellow","title":"BRIGHT_YELLOW"},{"location":"reference/present/ansi/#arc.present.ansi.fg.CYAN","text":"Escape code for foreground ANSI cyan","title":"CYAN"},{"location":"reference/present/ansi/#arc.present.ansi.fg.GREEN","text":"Escape code for foreground ANSI green","title":"GREEN"},{"location":"reference/present/ansi/#arc.present.ansi.fg.GREY","text":"Escape code for foreground ANSI grey","title":"GREY"},{"location":"reference/present/ansi/#arc.present.ansi.fg.MAGENTA","text":"Escape code for foreground ANSI magenta","title":"MAGENTA"},{"location":"reference/present/ansi/#arc.present.ansi.fg.RED","text":"Escape code for foreground ANSI red","title":"RED"},{"location":"reference/present/ansi/#arc.present.ansi.fg.WHITE","text":"Escape code for foreground ANSI white","title":"WHITE"},{"location":"reference/present/ansi/#arc.present.ansi.fg.YELLOW","text":"Escape code for foreground ANSI yellow","title":"YELLOW"},{"location":"reference/present/ansi/#arc.present.ansi.fg.hex","text":"Returns the foreground escape sequence for the provided hex values Source code in /home/runner/work/arc/arc/arc/present/ansi.py 87 88 89 90 91 @staticmethod def hex ( hex_code : str | int ) -> str : \"\"\"Returns the **foreground** escape sequence for the provided hex values\"\"\" return _rgb ( 38 , * _hex_to_rgb ( hex_code ))","title":"hex()"},{"location":"reference/present/ansi/#arc.present.ansi.fg.rgb","text":"Returns the foreground escape sequence for the provided rgb values Source code in /home/runner/work/arc/arc/arc/present/ansi.py 81 82 83 84 85 @staticmethod def rgb ( red : int = 0 , green : int = 0 , blue : int = 0 ) -> str : \"\"\"Returns the **foreground** escape sequence for the provided rgb values\"\"\" return _rgb ( 38 , red , green , blue )","title":"rgb()"},{"location":"reference/present/ansi/#arc.present.ansi.fx","text":"Other effects like CLEAR or BOLD . Support from terminal to terminal may vary Source code in /home/runner/work/arc/arc/arc/present/ansi.py 145 146 147 148 149 150 151 152 153 class fx : \"\"\"Other effects like `CLEAR` or `BOLD`. Support from terminal to terminal may vary\"\"\" CLEAR = \" \\033 [0m\" BOLD = \" \\033 [1m\" ITALIC = \" \\033 [3m\" UNDERLINE = \" \\033 [4m\" STRIKETHROUGH = \" \\033 [9m\"","title":"fx"},{"location":"reference/present/ansi/#arc.present.ansi.colorize","text":"Applies colors / effects to an entire string Parameters: Name Type Description Default string str String to colorize required *codes str colors / effects to apply to the strin () clear bool Whether or not to append effects.CLEAR to the end of the string which will prevent any subsequent strings from recieving the styles. Defaults to True True Returns: Name Type Description string str The colorized string Source code in /home/runner/work/arc/arc/arc/present/ansi.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def colorize ( string : str , * codes : str , clear : bool = True ) -> str : \"\"\"Applies colors / effects to an entire string Args: string (str): String to colorize *codes (str): colors / effects to apply to the strin clear (bool): Whether or not to append `effects.CLEAR` to the end of the string which will prevent any subsequent strings from recieving the styles. Defaults to True Returns: string: The colorized string \"\"\" return f \" { '' . join ( str ( code ) for code in codes ) }{ string }{ fx . CLEAR if clear else '' } \"","title":"colorize()"},{"location":"reference/present/box/","text":"present.box \u00b6 Box \u00b6 Presenter for creating a Box around provided text Examples: arc.print(Box('some cool text', padding=2, justify='center')) -> \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 \u2502 \u2502 some cool text \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Will accept colorized strings Source code in /home/runner/work/arc/arc/arc/present/box.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class Box : \"\"\"Presenter for creating a Box around provided text Examples: ``` arc.print(Box('some cool text', padding=2, justify='center')) -> \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 \u2502 \u2502 some cool text \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f ``` Will accept colorized strings \"\"\" def __init__ ( self , string : str , border : str = \"rounded\" , padding : Union [ int , dict [ str , int ]] = 0 , justify : Justification = \"center\" , color : str = fg . WHITE , ): \"\"\" Args: string: String to surround with a box - May be colored border: Border style, either 'light' or 'heavy' defaults to 'light' padding: Dictionary containing the padding of each side of the string defaults to: `{\"top\": 0, \"left\": 0, \"bottom\": 0, \"right\": 0}` If all sides are going to have the same padding, can just pass in that integer, rather than the entire dictionary justify: how to justify the text (left, center, right). Defaults to left color: What color the border should be. Defaults to white. Use `arc.color.fg` constants \"\"\" self . string = string self . __border : Border = borders [ border ] self . __justify = justifications [ justify ] self . __padding = self . __get_padding ( padding ) self . __color = color def __str__ ( self ) -> str : cleaned = list ( self . pad_line ( Ansi . clean ( string )) for string in self . string . split ( \" \\n \" ) ) width = len ( max ( cleaned , key = len )) + 4 term_width , _ = shutil . get_terminal_size () width = min ( width , term_width ) pad_top = Join . together ( self . format_line ( \"\" , width ) for _ in range ( 0 , self . __padding [ \"top\" ]) ) content = Join . together ( self . format_line ( line , width , clean_line ) for line , clean_line in zip ( self . string . split ( \" \\n \" ), cleaned ) ) pad_btm = Join . together ( self . format_line ( \"\" , width ) for _ in range ( 0 , self . __padding [ \"bottom\" ]) ) content = f \" { pad_top }{ content }{ pad_btm } \" top = self . horizontal_border ( width , \"top\" ) bottom = self . horizontal_border ( width , \"bot\" ) return f \" { top } \\n { content }{ bottom } \" @property def border ( self ) -> Border : \"\"\"Dictionary containting the border stylings\"\"\" return self . __border @border . setter def border ( self , value : str ) -> None : self . __border = borders [ value ] # Utils def horizontal_border ( self , width : int , side : str ) -> str : return Join . together ( ( self . border [ \"corner\" ][ f \" { side } _left\" ], # type: ignore self . border [ \"horizontal\" ] * ( width - 2 ), self . border [ \"corner\" ][ f \" { side } _right\" ], # type: ignore ), style = self . __color , ) def format_line ( self , line : str , width : int , cleaned : Optional [ str ] = None , ) -> str : cleaned = cleaned or line formatted = ( f \" { self . __color }{ self . border [ 'vertical' ] }{ fx . CLEAR } \" f \" { cleaned :{ self . __justify }{ width - 2 }} \" f \" { self . __color }{ self . border [ 'vertical' ] }{ fx . CLEAR } \\n \" ) if line == \"\" : return formatted # Uses the clean string for calculating the necessary # amount of padding on the right, but we want the color, so # just re.sub it back in after regex = re . compile ( cleaned ) formatted = regex . sub ( self . pad_line ( line ), formatted ) return formatted def pad_line ( self , line : str ) -> str : return \" \" * self . __padding [ \"left\" ] + line + \" \" * self . __padding [ \"right\" ] @staticmethod def __get_padding ( padding : Union [ int , dict [ str , int ]]) -> dict [ str , int ]: default_padding = { \"top\" : 0 , \"left\" : 0 , \"bottom\" : 0 , \"right\" : 0 } if isinstance ( padding , int ): return dict . fromkeys ( default_padding , padding ) if isinstance ( padding , dict ): return default_padding | padding return default_padding border : Border writable property \u00b6 Dictionary containting the border stylings __init__ ( string , border = 'rounded' , padding = 0 , justify = 'center' , color = fg . WHITE ) \u00b6 Parameters: Name Type Description Default string str String to surround with a box - May be colored required border str Border style, either 'light' or 'heavy' defaults to 'light' 'rounded' padding Union [ int , dict [ str , int ]] Dictionary containing the padding of each side of the string defaults to: {\"top\": 0, \"left\": 0, \"bottom\": 0, \"right\": 0} If all sides are going to have the same padding, can just pass in that integer, rather than the entire dictionary 0 justify Justification how to justify the text (left, center, right). Defaults to left 'center' color str What color the border should be. Defaults to white. Use arc.color.fg constants fg.WHITE Source code in /home/runner/work/arc/arc/arc/present/box.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , string : str , border : str = \"rounded\" , padding : Union [ int , dict [ str , int ]] = 0 , justify : Justification = \"center\" , color : str = fg . WHITE , ): \"\"\" Args: string: String to surround with a box - May be colored border: Border style, either 'light' or 'heavy' defaults to 'light' padding: Dictionary containing the padding of each side of the string defaults to: `{\"top\": 0, \"left\": 0, \"bottom\": 0, \"right\": 0}` If all sides are going to have the same padding, can just pass in that integer, rather than the entire dictionary justify: how to justify the text (left, center, right). Defaults to left color: What color the border should be. Defaults to white. Use `arc.color.fg` constants \"\"\" self . string = string self . __border : Border = borders [ border ] self . __justify = justifications [ justify ] self . __padding = self . __get_padding ( padding ) self . __color = color","title":"present.box"},{"location":"reference/present/box/#presentbox","text":"","title":"present.box"},{"location":"reference/present/box/#arc.present.box.Box","text":"Presenter for creating a Box around provided text Examples: arc.print(Box('some cool text', padding=2, justify='center')) -> \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 \u2502 \u2502 some cool text \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Will accept colorized strings Source code in /home/runner/work/arc/arc/arc/present/box.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class Box : \"\"\"Presenter for creating a Box around provided text Examples: ``` arc.print(Box('some cool text', padding=2, justify='center')) -> \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 \u2502 \u2502 some cool text \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f ``` Will accept colorized strings \"\"\" def __init__ ( self , string : str , border : str = \"rounded\" , padding : Union [ int , dict [ str , int ]] = 0 , justify : Justification = \"center\" , color : str = fg . WHITE , ): \"\"\" Args: string: String to surround with a box - May be colored border: Border style, either 'light' or 'heavy' defaults to 'light' padding: Dictionary containing the padding of each side of the string defaults to: `{\"top\": 0, \"left\": 0, \"bottom\": 0, \"right\": 0}` If all sides are going to have the same padding, can just pass in that integer, rather than the entire dictionary justify: how to justify the text (left, center, right). Defaults to left color: What color the border should be. Defaults to white. Use `arc.color.fg` constants \"\"\" self . string = string self . __border : Border = borders [ border ] self . __justify = justifications [ justify ] self . __padding = self . __get_padding ( padding ) self . __color = color def __str__ ( self ) -> str : cleaned = list ( self . pad_line ( Ansi . clean ( string )) for string in self . string . split ( \" \\n \" ) ) width = len ( max ( cleaned , key = len )) + 4 term_width , _ = shutil . get_terminal_size () width = min ( width , term_width ) pad_top = Join . together ( self . format_line ( \"\" , width ) for _ in range ( 0 , self . __padding [ \"top\" ]) ) content = Join . together ( self . format_line ( line , width , clean_line ) for line , clean_line in zip ( self . string . split ( \" \\n \" ), cleaned ) ) pad_btm = Join . together ( self . format_line ( \"\" , width ) for _ in range ( 0 , self . __padding [ \"bottom\" ]) ) content = f \" { pad_top }{ content }{ pad_btm } \" top = self . horizontal_border ( width , \"top\" ) bottom = self . horizontal_border ( width , \"bot\" ) return f \" { top } \\n { content }{ bottom } \" @property def border ( self ) -> Border : \"\"\"Dictionary containting the border stylings\"\"\" return self . __border @border . setter def border ( self , value : str ) -> None : self . __border = borders [ value ] # Utils def horizontal_border ( self , width : int , side : str ) -> str : return Join . together ( ( self . border [ \"corner\" ][ f \" { side } _left\" ], # type: ignore self . border [ \"horizontal\" ] * ( width - 2 ), self . border [ \"corner\" ][ f \" { side } _right\" ], # type: ignore ), style = self . __color , ) def format_line ( self , line : str , width : int , cleaned : Optional [ str ] = None , ) -> str : cleaned = cleaned or line formatted = ( f \" { self . __color }{ self . border [ 'vertical' ] }{ fx . CLEAR } \" f \" { cleaned :{ self . __justify }{ width - 2 }} \" f \" { self . __color }{ self . border [ 'vertical' ] }{ fx . CLEAR } \\n \" ) if line == \"\" : return formatted # Uses the clean string for calculating the necessary # amount of padding on the right, but we want the color, so # just re.sub it back in after regex = re . compile ( cleaned ) formatted = regex . sub ( self . pad_line ( line ), formatted ) return formatted def pad_line ( self , line : str ) -> str : return \" \" * self . __padding [ \"left\" ] + line + \" \" * self . __padding [ \"right\" ] @staticmethod def __get_padding ( padding : Union [ int , dict [ str , int ]]) -> dict [ str , int ]: default_padding = { \"top\" : 0 , \"left\" : 0 , \"bottom\" : 0 , \"right\" : 0 } if isinstance ( padding , int ): return dict . fromkeys ( default_padding , padding ) if isinstance ( padding , dict ): return default_padding | padding return default_padding","title":"Box"},{"location":"reference/present/box/#arc.present.box.Box.border","text":"Dictionary containting the border stylings","title":"border"},{"location":"reference/present/box/#arc.present.box.Box.__init__","text":"Parameters: Name Type Description Default string str String to surround with a box - May be colored required border str Border style, either 'light' or 'heavy' defaults to 'light' 'rounded' padding Union [ int , dict [ str , int ]] Dictionary containing the padding of each side of the string defaults to: {\"top\": 0, \"left\": 0, \"bottom\": 0, \"right\": 0} If all sides are going to have the same padding, can just pass in that integer, rather than the entire dictionary 0 justify Justification how to justify the text (left, center, right). Defaults to left 'center' color str What color the border should be. Defaults to white. Use arc.color.fg constants fg.WHITE Source code in /home/runner/work/arc/arc/arc/present/box.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , string : str , border : str = \"rounded\" , padding : Union [ int , dict [ str , int ]] = 0 , justify : Justification = \"center\" , color : str = fg . WHITE , ): \"\"\" Args: string: String to surround with a box - May be colored border: Border style, either 'light' or 'heavy' defaults to 'light' padding: Dictionary containing the padding of each side of the string defaults to: `{\"top\": 0, \"left\": 0, \"bottom\": 0, \"right\": 0}` If all sides are going to have the same padding, can just pass in that integer, rather than the entire dictionary justify: how to justify the text (left, center, right). Defaults to left color: What color the border should be. Defaults to white. Use `arc.color.fg` constants \"\"\" self . string = string self . __border : Border = borders [ border ] self . __justify = justifications [ justify ] self . __padding = self . __get_padding ( padding ) self . __color = color","title":"__init__()"},{"location":"reference/present/console/","text":"present.console \u00b6 Console \u00b6 Source code in /home/runner/work/arc/arc/arc/present/console.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 class Console : def __init__ ( self , default_print_stream : t . IO [ str ] | None = None , default_log_stream : t . IO [ str ] | None = None , show_icons : bool = True , color_output : bool = True , indent : str = \" \" , ) -> None : self . default_print_stream = default_print_stream or sys . stdout self . default_log_stream = default_log_stream or sys . stderr self . show_icons = show_icons self . color_output = color_output self . _indent = indent self . _indent_count = 0 self . icons : dict [ str , str ] = { \"ok\" : \"\u2713\" , \"error\" : \"\u2717\" , \"act\" : \"\" , \"warn\" : \"\ud83d\udea7\" , \"subtle\" : \"\" , \"snake\" : \"\ud83d\udc0d\" , } def print ( self , * values : object , sep : str | None = None , end : str | None = None , file : t . IO [ str ] | None = None , flush : bool = False , ) -> None : \"\"\"A wrapper around `print()` that handles removing escape codes when the output is not a TTY\"\"\" file = file or self . default_print_stream if ( file and not file . isatty ()) or not self . color_output : values = tuple ( Ansi . clean ( str ( v )) for v in values ) if self . _indent_count and values : first , * rest = values first = f \" { self . _indent * self . _indent_count }{ first } \" values = ( first , * rest ) builtins . print ( * values , sep = sep , end = end , file = file , flush = flush ) def info ( self , * values : object , sep : str | None = None , end : str | None = None , flush : bool = False , ) -> None : \"\"\"Wrapper around `print()` that emits to the `Console.log` stream instead of the `Console.print` stream\"\"\" self . print ( * values , sep = sep , end = end , file = self . default_log_stream , flush = flush ) def log ( self , / , first : object = None , * values : object , sep : str | None = None , end : str | None = None , file : t . IO [ str ] | None = None , flush : bool = False , ) -> None : \"\"\"Useful for simple logging. Writes to stderr instead of stdout and includes a timestamps\"\"\" file = file or self . default_log_stream time = datetime . datetime . now () . strftime ( \"%H:%M:%S\" ) first = first or \"\" first = colorize ( f \"[ { time } ] \" , fg . GREY ) + str ( first ) self . print ( first , * values , sep = sep , end = end , file = file , flush = flush ) @contextmanager def indent ( self ) -> t . Generator [ None , None , None ]: \"\"\"Context manager that will indent any prints done within it's block\"\"\" try : self . _indent_count += 1 yield finally : self . _indent_count -= 1 def _decorate ( self , * values : object , color : str = \"\" , icon : str = \"\" , ** kwargs : t . Any , ) -> None : if len ( values ) == 0 : self . print ( ** kwargs ) return first = values [ 0 ] rest = values [ 1 : - 1 ] last = values [ - 1 ] if self . show_icons and icon : first = f \" { icon } { first } \" if self . color_output and color : if len ( values ) > 1 : first = f \" { color }{ first } \" last = f \" { last }{ fx . CLEAR } \" else : first = f \" { color }{ first }{ fx . CLEAR } \" objects = [ first , * rest ] if len ( values ) > 1 : objects . append ( last ) self . print ( * objects , ** kwargs , ) def rule ( self , string : str = \"\" , width : int = 80 , ** kwargs : t . Any ) -> None : \"\"\"Display a horizontal rule to the user\"\"\" self . print ( string . center ( width , \"\u2500\" ), ** kwargs ) def ok ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a successful message to the user\"\"\" self . _decorate ( * values , color = fg . GREEN , icon = self . icons [ \"ok\" ], ** kwargs ) def err ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display an unsuccessful message to the user\"\"\" self . _decorate ( * values , color = fg . RED , icon = self . icons [ \"error\" ], ** kwargs ) def act ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display an action message to the user\"\"\" self . _decorate ( * values , color = fg . BLUE , icon = self . icons [ \"act\" ], ** kwargs ) def warn ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a warning message to the user\"\"\" self . _decorate ( * values , color = fg . YELLOW , icon = self . icons [ \"warn\" ], ** kwargs ) def subtle ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a subtle (light grey) message to the user\"\"\" self . _decorate ( * values , color = fg . GREY , icon = self . icons [ \"subtle\" ], ** kwargs ) def snake ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a Pythonic message to the user\"\"\" self . _decorate ( * values , icon = self . icons [ \"snake\" ], ** kwargs ) @classmethod def __depends__ ( cls , ctx : Context ) -> Console : return cls () act ( * values , ** kwargs ) \u00b6 Display an action message to the user Source code in /home/runner/work/arc/arc/arc/present/console.py 148 149 150 def act ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display an action message to the user\"\"\" self . _decorate ( * values , color = fg . BLUE , icon = self . icons [ \"act\" ], ** kwargs ) err ( * values , ** kwargs ) \u00b6 Display an unsuccessful message to the user Source code in /home/runner/work/arc/arc/arc/present/console.py 144 145 146 def err ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display an unsuccessful message to the user\"\"\" self . _decorate ( * values , color = fg . RED , icon = self . icons [ \"error\" ], ** kwargs ) indent () \u00b6 Context manager that will indent any prints done within it's block Source code in /home/runner/work/arc/arc/arc/present/console.py 92 93 94 95 96 97 98 99 100 @contextmanager def indent ( self ) -> t . Generator [ None , None , None ]: \"\"\"Context manager that will indent any prints done within it's block\"\"\" try : self . _indent_count += 1 yield finally : self . _indent_count -= 1 info ( * values , sep = None , end = None , flush = False ) \u00b6 Wrapper around print() that emits to the Console.log stream instead of the Console.print stream Source code in /home/runner/work/arc/arc/arc/present/console.py 63 64 65 66 67 68 69 70 71 72 def info ( self , * values : object , sep : str | None = None , end : str | None = None , flush : bool = False , ) -> None : \"\"\"Wrapper around `print()` that emits to the `Console.log` stream instead of the `Console.print` stream\"\"\" self . print ( * values , sep = sep , end = end , file = self . default_log_stream , flush = flush ) log ( first = None , * values , sep = None , end = None , file = None , flush = False ) \u00b6 Useful for simple logging. Writes to stderr instead of stdout and includes a timestamps Source code in /home/runner/work/arc/arc/arc/present/console.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def log ( self , / , first : object = None , * values : object , sep : str | None = None , end : str | None = None , file : t . IO [ str ] | None = None , flush : bool = False , ) -> None : \"\"\"Useful for simple logging. Writes to stderr instead of stdout and includes a timestamps\"\"\" file = file or self . default_log_stream time = datetime . datetime . now () . strftime ( \"%H:%M:%S\" ) first = first or \"\" first = colorize ( f \"[ { time } ] \" , fg . GREY ) + str ( first ) self . print ( first , * values , sep = sep , end = end , file = file , flush = flush ) ok ( * values , ** kwargs ) \u00b6 Display a successful message to the user Source code in /home/runner/work/arc/arc/arc/present/console.py 140 141 142 def ok ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a successful message to the user\"\"\" self . _decorate ( * values , color = fg . GREEN , icon = self . icons [ \"ok\" ], ** kwargs ) print ( * values , sep = None , end = None , file = None , flush = False ) \u00b6 A wrapper around print() that handles removing escape codes when the output is not a TTY Source code in /home/runner/work/arc/arc/arc/present/console.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def print ( self , * values : object , sep : str | None = None , end : str | None = None , file : t . IO [ str ] | None = None , flush : bool = False , ) -> None : \"\"\"A wrapper around `print()` that handles removing escape codes when the output is not a TTY\"\"\" file = file or self . default_print_stream if ( file and not file . isatty ()) or not self . color_output : values = tuple ( Ansi . clean ( str ( v )) for v in values ) if self . _indent_count and values : first , * rest = values first = f \" { self . _indent * self . _indent_count }{ first } \" values = ( first , * rest ) builtins . print ( * values , sep = sep , end = end , file = file , flush = flush ) rule ( string = '' , width = 80 , ** kwargs ) \u00b6 Display a horizontal rule to the user Source code in /home/runner/work/arc/arc/arc/present/console.py 136 137 138 def rule ( self , string : str = \"\" , width : int = 80 , ** kwargs : t . Any ) -> None : \"\"\"Display a horizontal rule to the user\"\"\" self . print ( string . center ( width , \"\u2500\" ), ** kwargs ) snake ( * values , ** kwargs ) \u00b6 Display a Pythonic message to the user Source code in /home/runner/work/arc/arc/arc/present/console.py 160 161 162 def snake ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a Pythonic message to the user\"\"\" self . _decorate ( * values , icon = self . icons [ \"snake\" ], ** kwargs ) subtle ( * values , ** kwargs ) \u00b6 Display a subtle (light grey) message to the user Source code in /home/runner/work/arc/arc/arc/present/console.py 156 157 158 def subtle ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a subtle (light grey) message to the user\"\"\" self . _decorate ( * values , color = fg . GREY , icon = self . icons [ \"subtle\" ], ** kwargs ) warn ( * values , ** kwargs ) \u00b6 Display a warning message to the user Source code in /home/runner/work/arc/arc/arc/present/console.py 152 153 154 def warn ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a warning message to the user\"\"\" self . _decorate ( * values , color = fg . YELLOW , icon = self . icons [ \"warn\" ], ** kwargs )","title":"present.console"},{"location":"reference/present/console/#presentconsole","text":"","title":"present.console"},{"location":"reference/present/console/#arc.present.console.Console","text":"Source code in /home/runner/work/arc/arc/arc/present/console.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 class Console : def __init__ ( self , default_print_stream : t . IO [ str ] | None = None , default_log_stream : t . IO [ str ] | None = None , show_icons : bool = True , color_output : bool = True , indent : str = \" \" , ) -> None : self . default_print_stream = default_print_stream or sys . stdout self . default_log_stream = default_log_stream or sys . stderr self . show_icons = show_icons self . color_output = color_output self . _indent = indent self . _indent_count = 0 self . icons : dict [ str , str ] = { \"ok\" : \"\u2713\" , \"error\" : \"\u2717\" , \"act\" : \"\" , \"warn\" : \"\ud83d\udea7\" , \"subtle\" : \"\" , \"snake\" : \"\ud83d\udc0d\" , } def print ( self , * values : object , sep : str | None = None , end : str | None = None , file : t . IO [ str ] | None = None , flush : bool = False , ) -> None : \"\"\"A wrapper around `print()` that handles removing escape codes when the output is not a TTY\"\"\" file = file or self . default_print_stream if ( file and not file . isatty ()) or not self . color_output : values = tuple ( Ansi . clean ( str ( v )) for v in values ) if self . _indent_count and values : first , * rest = values first = f \" { self . _indent * self . _indent_count }{ first } \" values = ( first , * rest ) builtins . print ( * values , sep = sep , end = end , file = file , flush = flush ) def info ( self , * values : object , sep : str | None = None , end : str | None = None , flush : bool = False , ) -> None : \"\"\"Wrapper around `print()` that emits to the `Console.log` stream instead of the `Console.print` stream\"\"\" self . print ( * values , sep = sep , end = end , file = self . default_log_stream , flush = flush ) def log ( self , / , first : object = None , * values : object , sep : str | None = None , end : str | None = None , file : t . IO [ str ] | None = None , flush : bool = False , ) -> None : \"\"\"Useful for simple logging. Writes to stderr instead of stdout and includes a timestamps\"\"\" file = file or self . default_log_stream time = datetime . datetime . now () . strftime ( \"%H:%M:%S\" ) first = first or \"\" first = colorize ( f \"[ { time } ] \" , fg . GREY ) + str ( first ) self . print ( first , * values , sep = sep , end = end , file = file , flush = flush ) @contextmanager def indent ( self ) -> t . Generator [ None , None , None ]: \"\"\"Context manager that will indent any prints done within it's block\"\"\" try : self . _indent_count += 1 yield finally : self . _indent_count -= 1 def _decorate ( self , * values : object , color : str = \"\" , icon : str = \"\" , ** kwargs : t . Any , ) -> None : if len ( values ) == 0 : self . print ( ** kwargs ) return first = values [ 0 ] rest = values [ 1 : - 1 ] last = values [ - 1 ] if self . show_icons and icon : first = f \" { icon } { first } \" if self . color_output and color : if len ( values ) > 1 : first = f \" { color }{ first } \" last = f \" { last }{ fx . CLEAR } \" else : first = f \" { color }{ first }{ fx . CLEAR } \" objects = [ first , * rest ] if len ( values ) > 1 : objects . append ( last ) self . print ( * objects , ** kwargs , ) def rule ( self , string : str = \"\" , width : int = 80 , ** kwargs : t . Any ) -> None : \"\"\"Display a horizontal rule to the user\"\"\" self . print ( string . center ( width , \"\u2500\" ), ** kwargs ) def ok ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a successful message to the user\"\"\" self . _decorate ( * values , color = fg . GREEN , icon = self . icons [ \"ok\" ], ** kwargs ) def err ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display an unsuccessful message to the user\"\"\" self . _decorate ( * values , color = fg . RED , icon = self . icons [ \"error\" ], ** kwargs ) def act ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display an action message to the user\"\"\" self . _decorate ( * values , color = fg . BLUE , icon = self . icons [ \"act\" ], ** kwargs ) def warn ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a warning message to the user\"\"\" self . _decorate ( * values , color = fg . YELLOW , icon = self . icons [ \"warn\" ], ** kwargs ) def subtle ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a subtle (light grey) message to the user\"\"\" self . _decorate ( * values , color = fg . GREY , icon = self . icons [ \"subtle\" ], ** kwargs ) def snake ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a Pythonic message to the user\"\"\" self . _decorate ( * values , icon = self . icons [ \"snake\" ], ** kwargs ) @classmethod def __depends__ ( cls , ctx : Context ) -> Console : return cls ()","title":"Console"},{"location":"reference/present/console/#arc.present.console.Console.act","text":"Display an action message to the user Source code in /home/runner/work/arc/arc/arc/present/console.py 148 149 150 def act ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display an action message to the user\"\"\" self . _decorate ( * values , color = fg . BLUE , icon = self . icons [ \"act\" ], ** kwargs )","title":"act()"},{"location":"reference/present/console/#arc.present.console.Console.err","text":"Display an unsuccessful message to the user Source code in /home/runner/work/arc/arc/arc/present/console.py 144 145 146 def err ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display an unsuccessful message to the user\"\"\" self . _decorate ( * values , color = fg . RED , icon = self . icons [ \"error\" ], ** kwargs )","title":"err()"},{"location":"reference/present/console/#arc.present.console.Console.indent","text":"Context manager that will indent any prints done within it's block Source code in /home/runner/work/arc/arc/arc/present/console.py 92 93 94 95 96 97 98 99 100 @contextmanager def indent ( self ) -> t . Generator [ None , None , None ]: \"\"\"Context manager that will indent any prints done within it's block\"\"\" try : self . _indent_count += 1 yield finally : self . _indent_count -= 1","title":"indent()"},{"location":"reference/present/console/#arc.present.console.Console.info","text":"Wrapper around print() that emits to the Console.log stream instead of the Console.print stream Source code in /home/runner/work/arc/arc/arc/present/console.py 63 64 65 66 67 68 69 70 71 72 def info ( self , * values : object , sep : str | None = None , end : str | None = None , flush : bool = False , ) -> None : \"\"\"Wrapper around `print()` that emits to the `Console.log` stream instead of the `Console.print` stream\"\"\" self . print ( * values , sep = sep , end = end , file = self . default_log_stream , flush = flush )","title":"info()"},{"location":"reference/present/console/#arc.present.console.Console.log","text":"Useful for simple logging. Writes to stderr instead of stdout and includes a timestamps Source code in /home/runner/work/arc/arc/arc/present/console.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def log ( self , / , first : object = None , * values : object , sep : str | None = None , end : str | None = None , file : t . IO [ str ] | None = None , flush : bool = False , ) -> None : \"\"\"Useful for simple logging. Writes to stderr instead of stdout and includes a timestamps\"\"\" file = file or self . default_log_stream time = datetime . datetime . now () . strftime ( \"%H:%M:%S\" ) first = first or \"\" first = colorize ( f \"[ { time } ] \" , fg . GREY ) + str ( first ) self . print ( first , * values , sep = sep , end = end , file = file , flush = flush )","title":"log()"},{"location":"reference/present/console/#arc.present.console.Console.ok","text":"Display a successful message to the user Source code in /home/runner/work/arc/arc/arc/present/console.py 140 141 142 def ok ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a successful message to the user\"\"\" self . _decorate ( * values , color = fg . GREEN , icon = self . icons [ \"ok\" ], ** kwargs )","title":"ok()"},{"location":"reference/present/console/#arc.present.console.Console.print","text":"A wrapper around print() that handles removing escape codes when the output is not a TTY Source code in /home/runner/work/arc/arc/arc/present/console.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def print ( self , * values : object , sep : str | None = None , end : str | None = None , file : t . IO [ str ] | None = None , flush : bool = False , ) -> None : \"\"\"A wrapper around `print()` that handles removing escape codes when the output is not a TTY\"\"\" file = file or self . default_print_stream if ( file and not file . isatty ()) or not self . color_output : values = tuple ( Ansi . clean ( str ( v )) for v in values ) if self . _indent_count and values : first , * rest = values first = f \" { self . _indent * self . _indent_count }{ first } \" values = ( first , * rest ) builtins . print ( * values , sep = sep , end = end , file = file , flush = flush )","title":"print()"},{"location":"reference/present/console/#arc.present.console.Console.rule","text":"Display a horizontal rule to the user Source code in /home/runner/work/arc/arc/arc/present/console.py 136 137 138 def rule ( self , string : str = \"\" , width : int = 80 , ** kwargs : t . Any ) -> None : \"\"\"Display a horizontal rule to the user\"\"\" self . print ( string . center ( width , \"\u2500\" ), ** kwargs )","title":"rule()"},{"location":"reference/present/console/#arc.present.console.Console.snake","text":"Display a Pythonic message to the user Source code in /home/runner/work/arc/arc/arc/present/console.py 160 161 162 def snake ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a Pythonic message to the user\"\"\" self . _decorate ( * values , icon = self . icons [ \"snake\" ], ** kwargs )","title":"snake()"},{"location":"reference/present/console/#arc.present.console.Console.subtle","text":"Display a subtle (light grey) message to the user Source code in /home/runner/work/arc/arc/arc/present/console.py 156 157 158 def subtle ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a subtle (light grey) message to the user\"\"\" self . _decorate ( * values , color = fg . GREY , icon = self . icons [ \"subtle\" ], ** kwargs )","title":"subtle()"},{"location":"reference/present/console/#arc.present.console.Console.warn","text":"Display a warning message to the user Source code in /home/runner/work/arc/arc/arc/present/console.py 152 153 154 def warn ( self , * values : object , ** kwargs : t . Any ) -> None : \"\"\"Display a warning message to the user\"\"\" self . _decorate ( * values , color = fg . YELLOW , icon = self . icons [ \"warn\" ], ** kwargs )","title":"warn()"},{"location":"reference/present/data/","text":"present.data \u00b6","title":"present.data"},{"location":"reference/present/data/#presentdata","text":"","title":"present.data"},{"location":"reference/present/drawing/","text":"present.drawing \u00b6","title":"present.drawing"},{"location":"reference/present/drawing/#presentdrawing","text":"","title":"present.drawing"},{"location":"reference/present/formatters/","text":"present.formatters \u00b6 TextFormatter \u00b6 Source code in /home/runner/work/arc/arc/arc/present/formatters.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class TextFormatter : def __init__ ( self , indent_increment : int = 4 , width : int = None , max_width : int = DEFAULT_MAX_WIDTH , ): self . indent_increment = indent_increment if width is None : width = max_width width = min ( shutil . get_terminal_size () . columns , width ) - 2 self . width = width self . current_indent = 0 self . _buffer : list [ str ] = [] @property def value ( self ) -> str : \"\"\"Current value of the formatter\"\"\" return \"\" . join ( self . _buffer ) def indent ( self ) -> None : \"\"\"Indents text by `indent_increment`\"\"\" self . current_indent += self . indent_increment def dedent ( self ) -> None : \"\"\"Dedents text by `indent_increment`\"\"\" self . current_indent -= self . indent_increment def write ( self , string : str ) -> None : self . _buffer . append ( string ) def write_heading ( self , heading : str ) -> None : self . write ( f \" { '' : > { self . current_indent }}{ heading } \\n \" ) def write_text ( self , text : t . Union [ str , list [ str ]]) -> None : self . write ( self . wrap_text ( text , width = self . width , initial_indent = \" \" * self . current_indent , subsequent_indent = \" \" * self . current_indent , ) ) def write_paragraph ( self ) -> None : if self . _buffer : self . write ( \" \\n \" ) # TODO: This is not handling colored text properly :( def wrap_text ( self , text : t . Union [ str , list [ str ]], width : int , initial_indent : str = \"\" , subsequent_indent : str = \"\" , ) -> str : if isinstance ( text , str ): text = [ text ] wrapped = \"\" wrapper = wrap . TextWrapper ( width = width , initial_indent = initial_indent , subsequent_indent = subsequent_indent , replace_whitespace = True , drop_whitespace = True , ) for para in text : wrapped += wrapper . fill ( para ) return wrapped . rstrip ( \" \\n \" ) @contextmanager def indentation ( self ) -> t . Generator [ None , None , None ]: self . indent () try : yield finally : self . dedent () @contextmanager def section ( self , name : str ) -> t . Generator [ None , None , None ]: self . write_paragraph () self . write_heading ( name ) self . indent () try : yield finally : self . dedent () self . write_paragraph () value : str property \u00b6 Current value of the formatter dedent () \u00b6 Dedents text by indent_increment Source code in /home/runner/work/arc/arc/arc/present/formatters.py 38 39 40 def dedent ( self ) -> None : \"\"\"Dedents text by `indent_increment`\"\"\" self . current_indent -= self . indent_increment indent () \u00b6 Indents text by indent_increment Source code in /home/runner/work/arc/arc/arc/present/formatters.py 34 35 36 def indent ( self ) -> None : \"\"\"Indents text by `indent_increment`\"\"\" self . current_indent += self . indent_increment","title":"present.formatters"},{"location":"reference/present/formatters/#presentformatters","text":"","title":"present.formatters"},{"location":"reference/present/formatters/#arc.present.formatters.TextFormatter","text":"Source code in /home/runner/work/arc/arc/arc/present/formatters.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class TextFormatter : def __init__ ( self , indent_increment : int = 4 , width : int = None , max_width : int = DEFAULT_MAX_WIDTH , ): self . indent_increment = indent_increment if width is None : width = max_width width = min ( shutil . get_terminal_size () . columns , width ) - 2 self . width = width self . current_indent = 0 self . _buffer : list [ str ] = [] @property def value ( self ) -> str : \"\"\"Current value of the formatter\"\"\" return \"\" . join ( self . _buffer ) def indent ( self ) -> None : \"\"\"Indents text by `indent_increment`\"\"\" self . current_indent += self . indent_increment def dedent ( self ) -> None : \"\"\"Dedents text by `indent_increment`\"\"\" self . current_indent -= self . indent_increment def write ( self , string : str ) -> None : self . _buffer . append ( string ) def write_heading ( self , heading : str ) -> None : self . write ( f \" { '' : > { self . current_indent }}{ heading } \\n \" ) def write_text ( self , text : t . Union [ str , list [ str ]]) -> None : self . write ( self . wrap_text ( text , width = self . width , initial_indent = \" \" * self . current_indent , subsequent_indent = \" \" * self . current_indent , ) ) def write_paragraph ( self ) -> None : if self . _buffer : self . write ( \" \\n \" ) # TODO: This is not handling colored text properly :( def wrap_text ( self , text : t . Union [ str , list [ str ]], width : int , initial_indent : str = \"\" , subsequent_indent : str = \"\" , ) -> str : if isinstance ( text , str ): text = [ text ] wrapped = \"\" wrapper = wrap . TextWrapper ( width = width , initial_indent = initial_indent , subsequent_indent = subsequent_indent , replace_whitespace = True , drop_whitespace = True , ) for para in text : wrapped += wrapper . fill ( para ) return wrapped . rstrip ( \" \\n \" ) @contextmanager def indentation ( self ) -> t . Generator [ None , None , None ]: self . indent () try : yield finally : self . dedent () @contextmanager def section ( self , name : str ) -> t . Generator [ None , None , None ]: self . write_paragraph () self . write_heading ( name ) self . indent () try : yield finally : self . dedent () self . write_paragraph ()","title":"TextFormatter"},{"location":"reference/present/formatters/#arc.present.formatters.TextFormatter.value","text":"Current value of the formatter","title":"value"},{"location":"reference/present/formatters/#arc.present.formatters.TextFormatter.dedent","text":"Dedents text by indent_increment Source code in /home/runner/work/arc/arc/arc/present/formatters.py 38 39 40 def dedent ( self ) -> None : \"\"\"Dedents text by `indent_increment`\"\"\" self . current_indent -= self . indent_increment","title":"dedent()"},{"location":"reference/present/formatters/#arc.present.formatters.TextFormatter.indent","text":"Indents text by indent_increment Source code in /home/runner/work/arc/arc/arc/present/formatters.py 34 35 36 def indent ( self ) -> None : \"\"\"Indents text by `indent_increment`\"\"\" self . current_indent += self . indent_increment","title":"indent()"},{"location":"reference/present/help_formatter/","text":"present.help_formatter \u00b6","title":"present.help_formatter"},{"location":"reference/present/help_formatter/#presenthelp_formatter","text":"","title":"present.help_formatter"},{"location":"reference/present/joiner/","text":"present.joiner \u00b6 Join \u00b6 Source code in /home/runner/work/arc/arc/arc/present/joiner.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class Join : @staticmethod def together ( values : t . Iterable [ t . Any ], string : str = \"\" , remove_falsey : bool = False , style : str = None , ) -> str : if remove_falsey : values = [ v for v in values if v ] if style : return string . join ( color . colorize ( v , style ) for v in values ) return string . join ( str ( v ) for v in values ) @staticmethod def with_space ( values : t . Iterable [ t . Any ], * args : t . Any , ** kwargs : t . Any ) -> str : return Join . together ( values , \" \" , * args , ** kwargs ) @staticmethod def with_comma ( values : t . Iterable [ t . Any ], * args : t . Any , ** kwargs : t . Any ) -> str : return Join . together ( values , \", \" , * args , ** kwargs ) @staticmethod def with_newline ( values : t . Iterable [ t . Any ], * args : t . Any , ** kwargs : t . Any ) -> str : return Join . together ( values , \" \\n \" , * args , ** kwargs ) @staticmethod def in_groups ( first : t . Iterable [ t . Any ], second : t . Iterable [ t . Any ], string : str , between : str , * args : t . Any , ** kwargs : t . Any , ) -> str : \"\"\"Joins two groups objects with `string`, then joins the two groups together with `between`\"\"\" return Join . together ( ( Join . together ( first , string , * args , ** kwargs ), Join . together ( second , string , * args , ** kwargs ), ), between , ) @staticmethod def with_last ( values : t . Sequence [ t . Any ], string : str , last_string : str , * args : t . Any , ** kwargs : t . Any , ) -> str : \"\"\"Joins values together with an additional `last_string` to format how the final value is joined to the rest of the list Args: values (Sequence): Values to join string (str): What to join values 0 - penultimate value with. last_string (str): What to use to join the last value to the rest. \"\"\" if len ( values ) == 0 : return \"\" if len ( values ) == 1 : return Join . together ( values , \"\" , * args , ** kwargs ) return Join . in_groups ( values [: - 1 ], [ values [ - 1 ]], string , last_string , * args , ** kwargs ) @staticmethod def with_and ( values : t . Sequence [ t . Any ]) -> str : \"\"\"Joins a Sequence of items with commas and an \"and\" at the end Args: values (Sequence): Values to join Returns: string: joined values \"\"\" return Join . with_last ( values , \", \" , \" and \" ) @staticmethod def with_or ( values : t . Sequence [ t . Any ], * args : t . Any , ** kwargs : t . Any ) -> str : \"\"\"Joins a Sequence of items with commas and an \"or\" at the end [1, 2, 3, 4] -> \"1, 2, 3 or 4\" Args: values (Sequence): Values to join Returns: string: joined values \"\"\" return Join . with_last ( values , \", \" , \" or \" , * args , ** kwargs ) in_groups ( first , second , string , between , * args , ** kwargs ) staticmethod \u00b6 Joins two groups objects with string , then joins the two groups together with between Source code in /home/runner/work/arc/arc/arc/present/joiner.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @staticmethod def in_groups ( first : t . Iterable [ t . Any ], second : t . Iterable [ t . Any ], string : str , between : str , * args : t . Any , ** kwargs : t . Any , ) -> str : \"\"\"Joins two groups objects with `string`, then joins the two groups together with `between`\"\"\" return Join . together ( ( Join . together ( first , string , * args , ** kwargs ), Join . together ( second , string , * args , ** kwargs ), ), between , ) with_and ( values ) staticmethod \u00b6 Joins a Sequence of items with commas and an \"and\" at the end Parameters: Name Type Description Default values Sequence Values to join required Returns: Name Type Description string str joined values Source code in /home/runner/work/arc/arc/arc/present/joiner.py 78 79 80 81 82 83 84 85 86 87 88 89 @staticmethod def with_and ( values : t . Sequence [ t . Any ]) -> str : \"\"\"Joins a Sequence of items with commas and an \"and\" at the end Args: values (Sequence): Values to join Returns: string: joined values \"\"\" return Join . with_last ( values , \", \" , \" and \" ) with_last ( values , string , last_string , * args , ** kwargs ) staticmethod \u00b6 Joins values together with an additional last_string to format how the final value is joined to the rest of the list Parameters: Name Type Description Default values Sequence Values to join required string str What to join values 0 - penultimate value with. required last_string str What to use to join the last value to the rest. required Source code in /home/runner/work/arc/arc/arc/present/joiner.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @staticmethod def with_last ( values : t . Sequence [ t . Any ], string : str , last_string : str , * args : t . Any , ** kwargs : t . Any , ) -> str : \"\"\"Joins values together with an additional `last_string` to format how the final value is joined to the rest of the list Args: values (Sequence): Values to join string (str): What to join values 0 - penultimate value with. last_string (str): What to use to join the last value to the rest. \"\"\" if len ( values ) == 0 : return \"\" if len ( values ) == 1 : return Join . together ( values , \"\" , * args , ** kwargs ) return Join . in_groups ( values [: - 1 ], [ values [ - 1 ]], string , last_string , * args , ** kwargs ) with_or ( values , * args , ** kwargs ) staticmethod \u00b6 Joins a Sequence of items with commas and an \"or\" at the end [1, 2, 3, 4] -> \"1, 2, 3 or 4\" Parameters: Name Type Description Default values Sequence Values to join required Returns: Name Type Description string str joined values Source code in /home/runner/work/arc/arc/arc/present/joiner.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @staticmethod def with_or ( values : t . Sequence [ t . Any ], * args : t . Any , ** kwargs : t . Any ) -> str : \"\"\"Joins a Sequence of items with commas and an \"or\" at the end [1, 2, 3, 4] -> \"1, 2, 3 or 4\" Args: values (Sequence): Values to join Returns: string: joined values \"\"\" return Join . with_last ( values , \", \" , \" or \" , * args , ** kwargs )","title":"present.joiner"},{"location":"reference/present/joiner/#presentjoiner","text":"","title":"present.joiner"},{"location":"reference/present/joiner/#arc.present.joiner.Join","text":"Source code in /home/runner/work/arc/arc/arc/present/joiner.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class Join : @staticmethod def together ( values : t . Iterable [ t . Any ], string : str = \"\" , remove_falsey : bool = False , style : str = None , ) -> str : if remove_falsey : values = [ v for v in values if v ] if style : return string . join ( color . colorize ( v , style ) for v in values ) return string . join ( str ( v ) for v in values ) @staticmethod def with_space ( values : t . Iterable [ t . Any ], * args : t . Any , ** kwargs : t . Any ) -> str : return Join . together ( values , \" \" , * args , ** kwargs ) @staticmethod def with_comma ( values : t . Iterable [ t . Any ], * args : t . Any , ** kwargs : t . Any ) -> str : return Join . together ( values , \", \" , * args , ** kwargs ) @staticmethod def with_newline ( values : t . Iterable [ t . Any ], * args : t . Any , ** kwargs : t . Any ) -> str : return Join . together ( values , \" \\n \" , * args , ** kwargs ) @staticmethod def in_groups ( first : t . Iterable [ t . Any ], second : t . Iterable [ t . Any ], string : str , between : str , * args : t . Any , ** kwargs : t . Any , ) -> str : \"\"\"Joins two groups objects with `string`, then joins the two groups together with `between`\"\"\" return Join . together ( ( Join . together ( first , string , * args , ** kwargs ), Join . together ( second , string , * args , ** kwargs ), ), between , ) @staticmethod def with_last ( values : t . Sequence [ t . Any ], string : str , last_string : str , * args : t . Any , ** kwargs : t . Any , ) -> str : \"\"\"Joins values together with an additional `last_string` to format how the final value is joined to the rest of the list Args: values (Sequence): Values to join string (str): What to join values 0 - penultimate value with. last_string (str): What to use to join the last value to the rest. \"\"\" if len ( values ) == 0 : return \"\" if len ( values ) == 1 : return Join . together ( values , \"\" , * args , ** kwargs ) return Join . in_groups ( values [: - 1 ], [ values [ - 1 ]], string , last_string , * args , ** kwargs ) @staticmethod def with_and ( values : t . Sequence [ t . Any ]) -> str : \"\"\"Joins a Sequence of items with commas and an \"and\" at the end Args: values (Sequence): Values to join Returns: string: joined values \"\"\" return Join . with_last ( values , \", \" , \" and \" ) @staticmethod def with_or ( values : t . Sequence [ t . Any ], * args : t . Any , ** kwargs : t . Any ) -> str : \"\"\"Joins a Sequence of items with commas and an \"or\" at the end [1, 2, 3, 4] -> \"1, 2, 3 or 4\" Args: values (Sequence): Values to join Returns: string: joined values \"\"\" return Join . with_last ( values , \", \" , \" or \" , * args , ** kwargs )","title":"Join"},{"location":"reference/present/joiner/#arc.present.joiner.Join.in_groups","text":"Joins two groups objects with string , then joins the two groups together with between Source code in /home/runner/work/arc/arc/arc/present/joiner.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @staticmethod def in_groups ( first : t . Iterable [ t . Any ], second : t . Iterable [ t . Any ], string : str , between : str , * args : t . Any , ** kwargs : t . Any , ) -> str : \"\"\"Joins two groups objects with `string`, then joins the two groups together with `between`\"\"\" return Join . together ( ( Join . together ( first , string , * args , ** kwargs ), Join . together ( second , string , * args , ** kwargs ), ), between , )","title":"in_groups()"},{"location":"reference/present/joiner/#arc.present.joiner.Join.with_and","text":"Joins a Sequence of items with commas and an \"and\" at the end Parameters: Name Type Description Default values Sequence Values to join required Returns: Name Type Description string str joined values Source code in /home/runner/work/arc/arc/arc/present/joiner.py 78 79 80 81 82 83 84 85 86 87 88 89 @staticmethod def with_and ( values : t . Sequence [ t . Any ]) -> str : \"\"\"Joins a Sequence of items with commas and an \"and\" at the end Args: values (Sequence): Values to join Returns: string: joined values \"\"\" return Join . with_last ( values , \", \" , \" and \" )","title":"with_and()"},{"location":"reference/present/joiner/#arc.present.joiner.Join.with_last","text":"Joins values together with an additional last_string to format how the final value is joined to the rest of the list Parameters: Name Type Description Default values Sequence Values to join required string str What to join values 0 - penultimate value with. required last_string str What to use to join the last value to the rest. required Source code in /home/runner/work/arc/arc/arc/present/joiner.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @staticmethod def with_last ( values : t . Sequence [ t . Any ], string : str , last_string : str , * args : t . Any , ** kwargs : t . Any , ) -> str : \"\"\"Joins values together with an additional `last_string` to format how the final value is joined to the rest of the list Args: values (Sequence): Values to join string (str): What to join values 0 - penultimate value with. last_string (str): What to use to join the last value to the rest. \"\"\" if len ( values ) == 0 : return \"\" if len ( values ) == 1 : return Join . together ( values , \"\" , * args , ** kwargs ) return Join . in_groups ( values [: - 1 ], [ values [ - 1 ]], string , last_string , * args , ** kwargs )","title":"with_last()"},{"location":"reference/present/joiner/#arc.present.joiner.Join.with_or","text":"Joins a Sequence of items with commas and an \"or\" at the end [1, 2, 3, 4] -> \"1, 2, 3 or 4\" Parameters: Name Type Description Default values Sequence Values to join required Returns: Name Type Description string str joined values Source code in /home/runner/work/arc/arc/arc/present/joiner.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @staticmethod def with_or ( values : t . Sequence [ t . Any ], * args : t . Any , ** kwargs : t . Any ) -> str : \"\"\"Joins a Sequence of items with commas and an \"or\" at the end [1, 2, 3, 4] -> \"1, 2, 3 or 4\" Args: values (Sequence): Values to join Returns: string: joined values \"\"\" return Join . with_last ( values , \", \" , \" or \" , * args , ** kwargs )","title":"with_or()"},{"location":"reference/present/out/","text":"present.out \u00b6 err ( * values , sep = None , end = None , flush = False ) \u00b6 Wrapper around print() that emits to an error in red Source code in /home/runner/work/arc/arc/arc/present/out.py 54 55 56 57 58 59 60 61 def err ( * values : object , sep : str | None = None , end : str | None = None , flush : bool = False , ) -> None : \"\"\"Wrapper around `print()` that emits to an error in red\"\"\" _default_console () . err ( * values , sep = sep , end = end , flush = flush ) info ( * values , sep = None , end = None , flush = False ) \u00b6 Wrapper around print() that emits to stderr instead of stdout Source code in /home/runner/work/arc/arc/arc/present/out.py 33 34 35 36 37 38 39 40 def info ( * values : object , sep : str | None = None , end : str | None = None , flush : bool = False , ) -> None : \"\"\"Wrapper around `print()` that emits to `stderr` instead of `stdout`\"\"\" _default_console () . info ( * values , sep = sep , end = end , flush = flush ) log ( * values , sep = None , end = None , file = None , flush = False ) \u00b6 print() to stderr with a timestamp Source code in /home/runner/work/arc/arc/arc/present/out.py 43 44 45 46 47 48 49 50 51 def log ( * values : object , sep : str | None = None , end : str | None = None , file : t . IO [ str ] | None = None , flush : bool = False , ) -> None : \"\"\"`print()` to stderr with a timestamp\"\"\" _default_console () . log ( * values , sep = sep , end = end , file = file , flush = flush ) print ( * values , sep = None , end = None , file = None , flush = False ) \u00b6 A wrapper around print() that handles removing escape codes when the output is not a TTY Source code in /home/runner/work/arc/arc/arc/present/out.py 20 21 22 23 24 25 26 27 28 29 30 def print ( * values : object , sep : str | None = None , end : str | None = None , file : t . IO [ str ] | None = None , flush : bool = False , ) -> None : \"\"\"A wrapper around `print()` that handles removing escape codes when the output is not a TTY\"\"\" _default_console () . print ( * values , sep = sep , end = end , file = file , flush = flush ) usage ( command ) \u00b6 Display the usage string for a given command object. Writes it to stderr Source code in /home/runner/work/arc/arc/arc/present/out.py 64 65 66 def usage ( command : Command ) -> None : \"\"\"Display the usage string for a given command object. Writes it to `stderr`\"\"\" info ( command . doc . usage ())","title":"present.out"},{"location":"reference/present/out/#presentout","text":"","title":"present.out"},{"location":"reference/present/out/#arc.present.out.err","text":"Wrapper around print() that emits to an error in red Source code in /home/runner/work/arc/arc/arc/present/out.py 54 55 56 57 58 59 60 61 def err ( * values : object , sep : str | None = None , end : str | None = None , flush : bool = False , ) -> None : \"\"\"Wrapper around `print()` that emits to an error in red\"\"\" _default_console () . err ( * values , sep = sep , end = end , flush = flush )","title":"err()"},{"location":"reference/present/out/#arc.present.out.info","text":"Wrapper around print() that emits to stderr instead of stdout Source code in /home/runner/work/arc/arc/arc/present/out.py 33 34 35 36 37 38 39 40 def info ( * values : object , sep : str | None = None , end : str | None = None , flush : bool = False , ) -> None : \"\"\"Wrapper around `print()` that emits to `stderr` instead of `stdout`\"\"\" _default_console () . info ( * values , sep = sep , end = end , flush = flush )","title":"info()"},{"location":"reference/present/out/#arc.present.out.log","text":"print() to stderr with a timestamp Source code in /home/runner/work/arc/arc/arc/present/out.py 43 44 45 46 47 48 49 50 51 def log ( * values : object , sep : str | None = None , end : str | None = None , file : t . IO [ str ] | None = None , flush : bool = False , ) -> None : \"\"\"`print()` to stderr with a timestamp\"\"\" _default_console () . log ( * values , sep = sep , end = end , file = file , flush = flush )","title":"log()"},{"location":"reference/present/out/#arc.present.out.print","text":"A wrapper around print() that handles removing escape codes when the output is not a TTY Source code in /home/runner/work/arc/arc/arc/present/out.py 20 21 22 23 24 25 26 27 28 29 30 def print ( * values : object , sep : str | None = None , end : str | None = None , file : t . IO [ str ] | None = None , flush : bool = False , ) -> None : \"\"\"A wrapper around `print()` that handles removing escape codes when the output is not a TTY\"\"\" _default_console () . print ( * values , sep = sep , end = end , file = file , flush = flush )","title":"print()"},{"location":"reference/present/out/#arc.present.out.usage","text":"Display the usage string for a given command object. Writes it to stderr Source code in /home/runner/work/arc/arc/arc/present/out.py 64 65 66 def usage ( command : Command ) -> None : \"\"\"Display the usage string for a given command object. Writes it to `stderr`\"\"\" info ( command . doc . usage ())","title":"usage()"},{"location":"reference/present/pager/","text":"present.pager \u00b6 pager ( contents , command = None ) \u00b6 Display contents in the user's preferred pager. Essentially equivalent to $ cli-app | less Parameters: Name Type Description Default contents str String contents to display in their page required command list [ str ] | None Override the default pager discovery with a given command to run. Defaults to None. None Raises: Type Description ArcError if no pager can be found for the user Source code in /home/runner/work/arc/arc/arc/present/pager.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def pager ( contents : object , command : list [ str ] | None = None ) -> None : \"\"\"Display `contents` in the user's preferred pager. Essentially equivalent to ```bash $ cli-app | less ``` Args: contents (str): String contents to display in their page command (list[str] | None, optional): Override the default pager discovery with a given command to run. Defaults to None. Raises: ArcError: if no pager can be found for the user \"\"\" command = command or [ _get_pager_command ()] subprocess . run ( command , input = str ( contents ) . encode ( \"utf-8\" ))","title":"present.pager"},{"location":"reference/present/pager/#presentpager","text":"","title":"present.pager"},{"location":"reference/present/pager/#arc.present.pager.pager","text":"Display contents in the user's preferred pager. Essentially equivalent to $ cli-app | less Parameters: Name Type Description Default contents str String contents to display in their page required command list [ str ] | None Override the default pager discovery with a given command to run. Defaults to None. None Raises: Type Description ArcError if no pager can be found for the user Source code in /home/runner/work/arc/arc/arc/present/pager.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def pager ( contents : object , command : list [ str ] | None = None ) -> None : \"\"\"Display `contents` in the user's preferred pager. Essentially equivalent to ```bash $ cli-app | less ``` Args: contents (str): String contents to display in their page command (list[str] | None, optional): Override the default pager discovery with a given command to run. Defaults to None. Raises: ArcError: if no pager can be found for the user \"\"\" command = command or [ _get_pager_command ()] subprocess . run ( command , input = str ( contents ) . encode ( \"utf-8\" ))","title":"pager()"},{"location":"reference/present/table/","text":"present.table \u00b6 Column \u00b6 Bases: ColumnBase Column Type Source code in /home/runner/work/arc/arc/arc/present/table.py 18 19 20 21 22 class Column ( ColumnBase , total = False ): # pylint: disable=inherit-non-class \"\"\"Column Type\"\"\" justify : drawing . Justification width : int ColumnBase \u00b6 Bases: t . TypedDict ColumnBase Type Source code in /home/runner/work/arc/arc/arc/present/table.py 12 13 14 15 class ColumnBase ( t . TypedDict ): # pylint: disable=inherit-non-class \"\"\"ColumnBase Type\"\"\" name : str Table \u00b6 Display information in a table from arc.present.table import Table t = Table ([ \"Name\" , \"Age\" , \"Stand\" ]) t . add_row ([ \"Jonathen Joestar\" , 20 , \"-\" ]) t . add_row ([ \"Joseph Joestar\" , 18 , \"Hermit Purple (in Part 3)\" ]) t . add_row ([ \"Jotaro Kujo\" , 18 , \"Star Platinum\" ]) t . add_row ([ \"Josuke Higashikata\" , 16 , \"Crazy Diamond\" ]) t . add_row ([ \"Giorno Giovanna\" , 15 , \"Gold Experience\" ]) t . add_row ([ \"Joylene Kujo\" , 19 , \"Stone Free\" ]) print ( t ) Will yield: \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Name \u2503 Age \u2503 Stand \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 Jonathen Joestar \u2502 20 \u2502 - \u2502 \u2502 Joseph Joestar \u2502 18 \u2502 Hermit Purple (in Part 3) \u2502 \u2502 Jotaro Kujo \u2502 18 \u2502 Star Platinum \u2502 \u2502 Josuke Higashikata \u2502 16 \u2502 Crazy Diamond \u2502 \u2502 Giorno Giovanna \u2502 15 \u2502 Gold Experience \u2502 \u2502 Joylene Kujo \u2502 19 \u2502 Stone Free \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Source code in /home/runner/work/arc/arc/arc/present/table.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 class Table : \"\"\"Display information in a table ```py from arc.present.table import Table t = Table([\"Name\", \"Age\", \"Stand\"]) t.add_row([\"Jonathen Joestar\", 20, \"-\"]) t.add_row([\"Joseph Joestar\", 18, \"Hermit Purple (in Part 3)\"]) t.add_row([\"Jotaro Kujo\", 18, \"Star Platinum\"]) t.add_row([\"Josuke Higashikata\", 16, \"Crazy Diamond\"]) t.add_row([\"Giorno Giovanna\", 15, \"Gold Experience\"]) t.add_row([\"Joylene Kujo\", 19, \"Stone Free\"]) print(t) ``` Will yield: ```console \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Name \u2503 Age \u2503 Stand \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 Jonathen Joestar \u2502 20 \u2502 - \u2502 \u2502 Joseph Joestar \u2502 18 \u2502 Hermit Purple (in Part 3) \u2502 \u2502 Jotaro Kujo \u2502 18 \u2502 Star Platinum \u2502 \u2502 Josuke Higashikata \u2502 16 \u2502 Crazy Diamond \u2502 \u2502 Giorno Giovanna \u2502 15 \u2502 Gold Experience \u2502 \u2502 Joylene Kujo \u2502 19 \u2502 Stone Free \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ``` \"\"\" def __init__ ( self , columns : ColumnInput , rows : t . Sequence [ t . Sequence [ t . Any ]] | None = None , default_formatting : bool = True , ) -> None : self . __columns : t . Sequence [ Column ] = self . __resolve_columns ( columns ) self . __rows : list [ Row ] = [] self . _border = drawing . borders [ \"light\" ] self . _head_border = BORDER_HEAVY_TRANS self . _header_cell_formatter : TableFormatter = ( _format_header_cell if default_formatting else _format_cell ) self . _cell_formatter : TableFormatter = _format_cell self . _type_formatters : dict [ type , TableFormatter ] = ( _DEFAULT_TYPE_FORMATTERS if default_formatting else {} ) if rows : self . add_rows ( rows ) def __str__ ( self ) -> str : for col in self . __columns : cells = [ row [ col [ \"name\" ]] for row in self . __rows ] cells . append ( col [ \"name\" ]) col [ \"width\" ] = max ( Ansi . len ( self . _fmt_cell_contents ( cell )) + 2 for cell in cells ) table = \"\" table += self . _fmt_header () table += \" \\n \" for row , has_next_row in has_next ( self . __rows ): table += self . _fmt_row ( row , has_next_row ) if has_next_row : table += \" \\n \" return table def add_row ( self , row : t . Sequence [ t . Any ]) -> None : if len ( row ) > len ( self . __columns ): raise errors . ArcError ( \"Too many values\" ) resolved = {} for col , value in itertools . zip_longest ( self . __columns , row , fillvalue = \"\" ): resolved [ col [ \"name\" ]] = value # type: ignore self . __rows . append ( resolved ) def add_rows ( self , rows : t . Sequence [ t . Sequence [ t . Any ]]) -> None : for row in rows : self . add_row ( row ) def fmt_header_cell ( self , func : TableFormatter | None = None ) -> TableFormatter | t . Callable [[ TableFormatter ], TableFormatter ]: def inner ( func : TableFormatter ) -> TableFormatter : self . _cell_formatter = func return func if func : return inner ( func ) return inner def fmt_cell ( self , func : TableFormatter | None = None ) -> TableFormatter | t . Callable [[ TableFormatter ], TableFormatter ]: \"\"\"Formats any cell that does not already have a formatter applied ```py from arc.color import fg, fx from arc.present import Table table = Table() @table.fmt_cell def fmt(cell): return f\"{fg.RED}{cell}{fx.CLEAR}\" ``` \"\"\" def inner ( func : TableFormatter ) -> TableFormatter : self . _cell_formatter = func return func if func : return inner ( func ) return inner def fmt_type ( self , cls : type ) -> t . Callable [[ TableFormatter ], TableFormatter ]: def inner ( func : t . Callable [[ t . Any ], str ]) -> TableFormatter : self . _type_formatters [ cls ] = func return func return inner def _fmt_header ( self ) -> str : border = self . _head_border header = \"\" header += border [ \"corner\" ][ \"top_left\" ] for idx , col in enumerate ( self . __columns ): header += border [ \"horizontal\" ] * col [ \"width\" ] if idx < len ( self . __columns ) - 1 : header += border [ \"intersect\" ][ \"hori_top\" ] else : header += border [ \"corner\" ][ \"top_right\" ] header += \" \\n \" header += border [ \"vertical\" ] for col in self . __columns : header += self . _fmt_cell ( col [ \"name\" ], col [ \"width\" ], col [ \"justify\" ], header = True , ) header += border [ \"vertical\" ] header += \" \\n \" header += border [ \"intersect\" ][ \"vert_left\" ] for col , has_next_column in has_next ( self . __columns ): header += border [ \"horizontal\" ] * col [ \"width\" ] if has_next_column : header += border [ \"intersect\" ][ \"cross\" ] else : header += border [ \"intersect\" ][ \"vert_right\" ] return header def _fmt_row ( self , row : Row , next_row : bool ) -> str : border = self . _border fmt = \"\" fmt += border [ \"vertical\" ] for col in self . __columns : cell = row . get ( col [ \"name\" ], \"\" ) fmt += self . _fmt_cell ( cell , col [ \"width\" ], col [ \"justify\" ]) fmt += border [ \"vertical\" ] if not next_row : fmt += \" \\n \" fmt += border [ \"corner\" ][ \"bot_left\" ] for col , has_next_column in has_next ( self . __columns ): fmt += border [ \"horizontal\" ] * col [ \"width\" ] if has_next_column : fmt += border [ \"intersect\" ][ \"hori_bot\" ] else : fmt += border [ \"corner\" ][ \"bot_right\" ] return fmt def _fmt_cell ( self , cell : t . Any , width : int , justify : drawing . Justification , header : bool = False , ) -> str : formatted_cell = self . _fmt_cell_contents ( cell , header ) width = width - 2 padding = \" \" * ( width - Ansi . len ( formatted_cell )) if justify == \"left\" : return \" \" + formatted_cell + padding + \" \" elif justify == \"right\" : return \" \" + padding + formatted_cell + \" \" elif justify == \"center\" : padding_width , remainder = divmod ( width - Ansi . len ( formatted_cell ), 2 ) padding = \" \" * padding_width return ( \" \" + padding + formatted_cell + padding + ( \" \" if remainder else \" \" ) ) @functools . cache def _fmt_cell_contents ( self , cell : t . Any , header : bool = False ) -> str : if header : return self . _header_cell_formatter ( cell ) if type ( cell ) in self . _type_formatters : return self . _type_formatters [ type ( cell )]( cell ) else : return self . _cell_formatter ( cell ) @staticmethod def __resolve_columns ( columns : ColumnInput ) -> list [ Column ]: resolved : list [ Column ] = [] for column in columns : copy = DEFAULT_COLUMN . copy () if isinstance ( column , str ): copy . update ({ \"name\" : column }) elif isinstance ( column , dict ): column = t . cast ( Column , column ) copy . update ( column ) # type: ignore else : raise errors . ArcError ( \"Columns must either be a string or a dictionary\" ) resolved . append ( copy ) return resolved fmt_cell ( func = None ) \u00b6 Formats any cell that does not already have a formatter applied from arc.color import fg , fx from arc.present import Table table = Table () @table . fmt_cell def fmt ( cell ): return f \" { fg . RED }{ cell }{ fx . CLEAR } \" Source code in /home/runner/work/arc/arc/arc/present/table.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def fmt_cell ( self , func : TableFormatter | None = None ) -> TableFormatter | t . Callable [[ TableFormatter ], TableFormatter ]: \"\"\"Formats any cell that does not already have a formatter applied ```py from arc.color import fg, fx from arc.present import Table table = Table() @table.fmt_cell def fmt(cell): return f\"{fg.RED}{cell}{fx.CLEAR}\" ``` \"\"\" def inner ( func : TableFormatter ) -> TableFormatter : self . _cell_formatter = func return func if func : return inner ( func ) return inner","title":"present.table"},{"location":"reference/present/table/#presenttable","text":"","title":"present.table"},{"location":"reference/present/table/#arc.present.table.Column","text":"Bases: ColumnBase Column Type Source code in /home/runner/work/arc/arc/arc/present/table.py 18 19 20 21 22 class Column ( ColumnBase , total = False ): # pylint: disable=inherit-non-class \"\"\"Column Type\"\"\" justify : drawing . Justification width : int","title":"Column"},{"location":"reference/present/table/#arc.present.table.ColumnBase","text":"Bases: t . TypedDict ColumnBase Type Source code in /home/runner/work/arc/arc/arc/present/table.py 12 13 14 15 class ColumnBase ( t . TypedDict ): # pylint: disable=inherit-non-class \"\"\"ColumnBase Type\"\"\" name : str","title":"ColumnBase"},{"location":"reference/present/table/#arc.present.table.Table","text":"Display information in a table from arc.present.table import Table t = Table ([ \"Name\" , \"Age\" , \"Stand\" ]) t . add_row ([ \"Jonathen Joestar\" , 20 , \"-\" ]) t . add_row ([ \"Joseph Joestar\" , 18 , \"Hermit Purple (in Part 3)\" ]) t . add_row ([ \"Jotaro Kujo\" , 18 , \"Star Platinum\" ]) t . add_row ([ \"Josuke Higashikata\" , 16 , \"Crazy Diamond\" ]) t . add_row ([ \"Giorno Giovanna\" , 15 , \"Gold Experience\" ]) t . add_row ([ \"Joylene Kujo\" , 19 , \"Stone Free\" ]) print ( t ) Will yield: \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Name \u2503 Age \u2503 Stand \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 Jonathen Joestar \u2502 20 \u2502 - \u2502 \u2502 Joseph Joestar \u2502 18 \u2502 Hermit Purple (in Part 3) \u2502 \u2502 Jotaro Kujo \u2502 18 \u2502 Star Platinum \u2502 \u2502 Josuke Higashikata \u2502 16 \u2502 Crazy Diamond \u2502 \u2502 Giorno Giovanna \u2502 15 \u2502 Gold Experience \u2502 \u2502 Joylene Kujo \u2502 19 \u2502 Stone Free \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Source code in /home/runner/work/arc/arc/arc/present/table.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 class Table : \"\"\"Display information in a table ```py from arc.present.table import Table t = Table([\"Name\", \"Age\", \"Stand\"]) t.add_row([\"Jonathen Joestar\", 20, \"-\"]) t.add_row([\"Joseph Joestar\", 18, \"Hermit Purple (in Part 3)\"]) t.add_row([\"Jotaro Kujo\", 18, \"Star Platinum\"]) t.add_row([\"Josuke Higashikata\", 16, \"Crazy Diamond\"]) t.add_row([\"Giorno Giovanna\", 15, \"Gold Experience\"]) t.add_row([\"Joylene Kujo\", 19, \"Stone Free\"]) print(t) ``` Will yield: ```console \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Name \u2503 Age \u2503 Stand \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 Jonathen Joestar \u2502 20 \u2502 - \u2502 \u2502 Joseph Joestar \u2502 18 \u2502 Hermit Purple (in Part 3) \u2502 \u2502 Jotaro Kujo \u2502 18 \u2502 Star Platinum \u2502 \u2502 Josuke Higashikata \u2502 16 \u2502 Crazy Diamond \u2502 \u2502 Giorno Giovanna \u2502 15 \u2502 Gold Experience \u2502 \u2502 Joylene Kujo \u2502 19 \u2502 Stone Free \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 ``` \"\"\" def __init__ ( self , columns : ColumnInput , rows : t . Sequence [ t . Sequence [ t . Any ]] | None = None , default_formatting : bool = True , ) -> None : self . __columns : t . Sequence [ Column ] = self . __resolve_columns ( columns ) self . __rows : list [ Row ] = [] self . _border = drawing . borders [ \"light\" ] self . _head_border = BORDER_HEAVY_TRANS self . _header_cell_formatter : TableFormatter = ( _format_header_cell if default_formatting else _format_cell ) self . _cell_formatter : TableFormatter = _format_cell self . _type_formatters : dict [ type , TableFormatter ] = ( _DEFAULT_TYPE_FORMATTERS if default_formatting else {} ) if rows : self . add_rows ( rows ) def __str__ ( self ) -> str : for col in self . __columns : cells = [ row [ col [ \"name\" ]] for row in self . __rows ] cells . append ( col [ \"name\" ]) col [ \"width\" ] = max ( Ansi . len ( self . _fmt_cell_contents ( cell )) + 2 for cell in cells ) table = \"\" table += self . _fmt_header () table += \" \\n \" for row , has_next_row in has_next ( self . __rows ): table += self . _fmt_row ( row , has_next_row ) if has_next_row : table += \" \\n \" return table def add_row ( self , row : t . Sequence [ t . Any ]) -> None : if len ( row ) > len ( self . __columns ): raise errors . ArcError ( \"Too many values\" ) resolved = {} for col , value in itertools . zip_longest ( self . __columns , row , fillvalue = \"\" ): resolved [ col [ \"name\" ]] = value # type: ignore self . __rows . append ( resolved ) def add_rows ( self , rows : t . Sequence [ t . Sequence [ t . Any ]]) -> None : for row in rows : self . add_row ( row ) def fmt_header_cell ( self , func : TableFormatter | None = None ) -> TableFormatter | t . Callable [[ TableFormatter ], TableFormatter ]: def inner ( func : TableFormatter ) -> TableFormatter : self . _cell_formatter = func return func if func : return inner ( func ) return inner def fmt_cell ( self , func : TableFormatter | None = None ) -> TableFormatter | t . Callable [[ TableFormatter ], TableFormatter ]: \"\"\"Formats any cell that does not already have a formatter applied ```py from arc.color import fg, fx from arc.present import Table table = Table() @table.fmt_cell def fmt(cell): return f\"{fg.RED}{cell}{fx.CLEAR}\" ``` \"\"\" def inner ( func : TableFormatter ) -> TableFormatter : self . _cell_formatter = func return func if func : return inner ( func ) return inner def fmt_type ( self , cls : type ) -> t . Callable [[ TableFormatter ], TableFormatter ]: def inner ( func : t . Callable [[ t . Any ], str ]) -> TableFormatter : self . _type_formatters [ cls ] = func return func return inner def _fmt_header ( self ) -> str : border = self . _head_border header = \"\" header += border [ \"corner\" ][ \"top_left\" ] for idx , col in enumerate ( self . __columns ): header += border [ \"horizontal\" ] * col [ \"width\" ] if idx < len ( self . __columns ) - 1 : header += border [ \"intersect\" ][ \"hori_top\" ] else : header += border [ \"corner\" ][ \"top_right\" ] header += \" \\n \" header += border [ \"vertical\" ] for col in self . __columns : header += self . _fmt_cell ( col [ \"name\" ], col [ \"width\" ], col [ \"justify\" ], header = True , ) header += border [ \"vertical\" ] header += \" \\n \" header += border [ \"intersect\" ][ \"vert_left\" ] for col , has_next_column in has_next ( self . __columns ): header += border [ \"horizontal\" ] * col [ \"width\" ] if has_next_column : header += border [ \"intersect\" ][ \"cross\" ] else : header += border [ \"intersect\" ][ \"vert_right\" ] return header def _fmt_row ( self , row : Row , next_row : bool ) -> str : border = self . _border fmt = \"\" fmt += border [ \"vertical\" ] for col in self . __columns : cell = row . get ( col [ \"name\" ], \"\" ) fmt += self . _fmt_cell ( cell , col [ \"width\" ], col [ \"justify\" ]) fmt += border [ \"vertical\" ] if not next_row : fmt += \" \\n \" fmt += border [ \"corner\" ][ \"bot_left\" ] for col , has_next_column in has_next ( self . __columns ): fmt += border [ \"horizontal\" ] * col [ \"width\" ] if has_next_column : fmt += border [ \"intersect\" ][ \"hori_bot\" ] else : fmt += border [ \"corner\" ][ \"bot_right\" ] return fmt def _fmt_cell ( self , cell : t . Any , width : int , justify : drawing . Justification , header : bool = False , ) -> str : formatted_cell = self . _fmt_cell_contents ( cell , header ) width = width - 2 padding = \" \" * ( width - Ansi . len ( formatted_cell )) if justify == \"left\" : return \" \" + formatted_cell + padding + \" \" elif justify == \"right\" : return \" \" + padding + formatted_cell + \" \" elif justify == \"center\" : padding_width , remainder = divmod ( width - Ansi . len ( formatted_cell ), 2 ) padding = \" \" * padding_width return ( \" \" + padding + formatted_cell + padding + ( \" \" if remainder else \" \" ) ) @functools . cache def _fmt_cell_contents ( self , cell : t . Any , header : bool = False ) -> str : if header : return self . _header_cell_formatter ( cell ) if type ( cell ) in self . _type_formatters : return self . _type_formatters [ type ( cell )]( cell ) else : return self . _cell_formatter ( cell ) @staticmethod def __resolve_columns ( columns : ColumnInput ) -> list [ Column ]: resolved : list [ Column ] = [] for column in columns : copy = DEFAULT_COLUMN . copy () if isinstance ( column , str ): copy . update ({ \"name\" : column }) elif isinstance ( column , dict ): column = t . cast ( Column , column ) copy . update ( column ) # type: ignore else : raise errors . ArcError ( \"Columns must either be a string or a dictionary\" ) resolved . append ( copy ) return resolved","title":"Table"},{"location":"reference/present/table/#arc.present.table.Table.fmt_cell","text":"Formats any cell that does not already have a formatter applied from arc.color import fg , fx from arc.present import Table table = Table () @table . fmt_cell def fmt ( cell ): return f \" { fg . RED }{ cell }{ fx . CLEAR } \" Source code in /home/runner/work/arc/arc/arc/present/table.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def fmt_cell ( self , func : TableFormatter | None = None ) -> TableFormatter | t . Callable [[ TableFormatter ], TableFormatter ]: \"\"\"Formats any cell that does not already have a formatter applied ```py from arc.color import fg, fx from arc.present import Table table = Table() @table.fmt_cell def fmt(cell): return f\"{fg.RED}{cell}{fx.CLEAR}\" ``` \"\"\" def inner ( func : TableFormatter ) -> TableFormatter : self . _cell_formatter = func return func if func : return inner ( func ) return inner","title":"fmt_cell()"},{"location":"reference/present/wrap/","text":"present.wrap \u00b6 TextWrapper \u00b6 Bases: textwrap . TextWrapper Source code in /home/runner/work/arc/arc/arc/present/wrap.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class TextWrapper ( textwrap . TextWrapper ): # Copy of the implementation from textwrap, but replaces len() # with Ansi.len() to support ANSI escape sequences. def _wrap_chunks ( self , chunks : list [ str ]) -> list [ str ]: \"\"\" Wrap a sequence of text chunks and return a list of lines of length 'self.width' or less. (If 'break_long_words' is false, some lines may be longer than this.) Chunks correspond roughly to words and the whitespace between them: each chunk is indivisible (modulo 'break_long_words'), but a line break can come between any two chunks. Chunks should not have internal whitespace; ie. a chunk is either all whitespace or a \"word\". Whitespace chunks will be removed from the beginning and end of lines, but apart from that whitespace is preserved. \"\"\" lines : list [ str ] = [] if self . width <= 0 : raise ValueError ( \"invalid width %r (must be > 0)\" % self . width ) if self . max_lines is not None : if self . max_lines > 1 : indent = self . subsequent_indent else : indent = self . initial_indent if len ( indent ) + len ( self . placeholder . lstrip ()) > self . width : raise ValueError ( \"placeholder too large for max width\" ) # Arrange in reverse order so items can be efficiently popped # from a stack of chucks. chunks . reverse () while chunks : # Start the list of chunks that will make up the current line. # cur_len is just the length of all the chunks in cur_line. cur_line = [] cur_len = 0 # Figure out which static string will prefix this line. if lines : indent = self . subsequent_indent else : indent = self . initial_indent # Maximum width for this line. width = self . width - len ( indent ) # First chunk on line is whitespace -- drop it, unless this # is the very beginning of the text (ie. no lines started yet). if self . drop_whitespace and chunks [ - 1 ] . strip () == \"\" and lines : del chunks [ - 1 ] while chunks : l = Ansi . len ( chunks [ - 1 ]) # Can at least squeeze this chunk onto the current line. if cur_len + l <= width : cur_line . append ( chunks . pop ()) cur_len += l # Nope, this line is full. else : break # The current line is full, and the next chunk is too big to # fit on *any* line (not just this one). if chunks and len ( chunks [ - 1 ]) > width : self . _handle_long_word ( chunks , cur_line , cur_len , width ) cur_len = sum ( map ( len , cur_line )) # If the last chunk on this line is all whitespace, drop it. if self . drop_whitespace and cur_line and cur_line [ - 1 ] . strip () == \"\" : cur_len -= len ( cur_line [ - 1 ]) del cur_line [ - 1 ] if cur_line : if ( self . max_lines is None or len ( lines ) + 1 < self . max_lines or ( not chunks or self . drop_whitespace and len ( chunks ) == 1 and not chunks [ 0 ] . strip () ) and cur_len <= width ): # Convert current line back to a string and store it in # list of all lines (return value). lines . append ( indent + \"\" . join ( cur_line )) else : while cur_line : if ( cur_line [ - 1 ] . strip () and cur_len + len ( self . placeholder ) <= width ): cur_line . append ( self . placeholder ) lines . append ( indent + \"\" . join ( cur_line )) break cur_len -= Ansi . len ( cur_line [ - 1 ]) del cur_line [ - 1 ] else : if lines : prev_line = lines [ - 1 ] . rstrip () if ( Ansi . len ( prev_line ) + len ( self . placeholder ) <= self . width ): lines [ - 1 ] = prev_line + self . placeholder break lines . append ( indent + self . placeholder . lstrip ()) break return lines","title":"present.wrap"},{"location":"reference/present/wrap/#presentwrap","text":"","title":"present.wrap"},{"location":"reference/present/wrap/#arc.present.wrap.TextWrapper","text":"Bases: textwrap . TextWrapper Source code in /home/runner/work/arc/arc/arc/present/wrap.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class TextWrapper ( textwrap . TextWrapper ): # Copy of the implementation from textwrap, but replaces len() # with Ansi.len() to support ANSI escape sequences. def _wrap_chunks ( self , chunks : list [ str ]) -> list [ str ]: \"\"\" Wrap a sequence of text chunks and return a list of lines of length 'self.width' or less. (If 'break_long_words' is false, some lines may be longer than this.) Chunks correspond roughly to words and the whitespace between them: each chunk is indivisible (modulo 'break_long_words'), but a line break can come between any two chunks. Chunks should not have internal whitespace; ie. a chunk is either all whitespace or a \"word\". Whitespace chunks will be removed from the beginning and end of lines, but apart from that whitespace is preserved. \"\"\" lines : list [ str ] = [] if self . width <= 0 : raise ValueError ( \"invalid width %r (must be > 0)\" % self . width ) if self . max_lines is not None : if self . max_lines > 1 : indent = self . subsequent_indent else : indent = self . initial_indent if len ( indent ) + len ( self . placeholder . lstrip ()) > self . width : raise ValueError ( \"placeholder too large for max width\" ) # Arrange in reverse order so items can be efficiently popped # from a stack of chucks. chunks . reverse () while chunks : # Start the list of chunks that will make up the current line. # cur_len is just the length of all the chunks in cur_line. cur_line = [] cur_len = 0 # Figure out which static string will prefix this line. if lines : indent = self . subsequent_indent else : indent = self . initial_indent # Maximum width for this line. width = self . width - len ( indent ) # First chunk on line is whitespace -- drop it, unless this # is the very beginning of the text (ie. no lines started yet). if self . drop_whitespace and chunks [ - 1 ] . strip () == \"\" and lines : del chunks [ - 1 ] while chunks : l = Ansi . len ( chunks [ - 1 ]) # Can at least squeeze this chunk onto the current line. if cur_len + l <= width : cur_line . append ( chunks . pop ()) cur_len += l # Nope, this line is full. else : break # The current line is full, and the next chunk is too big to # fit on *any* line (not just this one). if chunks and len ( chunks [ - 1 ]) > width : self . _handle_long_word ( chunks , cur_line , cur_len , width ) cur_len = sum ( map ( len , cur_line )) # If the last chunk on this line is all whitespace, drop it. if self . drop_whitespace and cur_line and cur_line [ - 1 ] . strip () == \"\" : cur_len -= len ( cur_line [ - 1 ]) del cur_line [ - 1 ] if cur_line : if ( self . max_lines is None or len ( lines ) + 1 < self . max_lines or ( not chunks or self . drop_whitespace and len ( chunks ) == 1 and not chunks [ 0 ] . strip () ) and cur_len <= width ): # Convert current line back to a string and store it in # list of all lines (return value). lines . append ( indent + \"\" . join ( cur_line )) else : while cur_line : if ( cur_line [ - 1 ] . strip () and cur_len + len ( self . placeholder ) <= width ): cur_line . append ( self . placeholder ) lines . append ( indent + \"\" . join ( cur_line )) break cur_len -= Ansi . len ( cur_line [ - 1 ]) del cur_line [ - 1 ] else : if lines : prev_line = lines [ - 1 ] . rstrip () if ( Ansi . len ( prev_line ) + len ( self . placeholder ) <= self . width ): lines [ - 1 ] = prev_line + self . placeholder break lines . append ( indent + self . placeholder . lstrip ()) break return lines","title":"TextWrapper"},{"location":"reference/present/_markdown/markdown_parser/","text":"present._markdown.markdown_parser \u00b6","title":"present._markdown.markdown_parser"},{"location":"reference/present/_markdown/markdown_parser/#present_markdownmarkdown_parser","text":"","title":"present._markdown.markdown_parser"},{"location":"reference/present/_markdown/nodes/","text":"present._markdown.nodes \u00b6","title":"present._markdown.nodes"},{"location":"reference/present/_markdown/nodes/#present_markdownnodes","text":"","title":"present._markdown.nodes"},{"location":"reference/prompt/helpers/","text":"prompt.helpers \u00b6","title":"prompt.helpers"},{"location":"reference/prompt/helpers/#prompthelpers","text":"","title":"prompt.helpers"},{"location":"reference/prompt/prompt/","text":"prompt.prompt \u00b6 Prompt \u00b6 Source code in /home/runner/work/arc/arc/arc/prompt/prompt.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 class Prompt : def __init__ ( self ) -> None : self . out_stream = sys . stdout self . _buffer : list [ str ] = [] self . _prev_buffer : list [ str ] = [] self . _answers : list [ tuple [ BaseQuestion [ t . Any ], t . Any ]] = [] self . _max_line_lengths : dict [ int , int ] = {} @property def answers ( self ) -> list [ tuple [ BaseQuestion [ t . Any ], t . Any ]]: return self . _answers @property def buffered_lines ( self ) -> int : count = 0 for string in self . _buffer : for char in string : if char == \" \\n \" : count += 1 return count def ask ( self , question : BaseQuestion [ T ]) -> T : if isinstance ( question , RawQuestion ): return self . _raw_ask ( question ) elif isinstance ( question , Question ): return self . _standard_ask ( question ) raise RuntimeError ( \"Called Prompt.ask() with an invalid question object\" ) @t . overload def input ( self , prompt : str , ** kwargs : t . Any ) -> str : ... @t . overload def input ( self , prompt : str , convert : type [ T ], ** kwargs : t . Any ) -> T : ... def input ( self , prompt : str , convert : type = str , ** kwargs : t . Any ) -> t . Any : \"\"\"Get input from the user\"\"\" question = InputQuestion [ str ]( prompt , convert , ** kwargs ) return self . ask ( question ) def confirm ( self , prompt : str , ** kwargs : t . Any ) -> bool : \"\"\"Get a yes / no confirmation from the user\"\"\" prompt = f \" { prompt } [ { colorize ( 'y' , fg . GREEN ) } / { colorize ( 'n' , fg . RED ) } ] \" question = ConfirmQuestion ( prompt , ** kwargs ) return self . ask ( question ) def select ( self , prompt : str , options : t . Sequence [ tuple [ T , str ]], ** kwargs : t . Any , ) -> T : \"\"\"Prompt the user to select from a list of options Args: prompt (str): The prompt to display to the user options (t.Sequence[tuple[T, str]]): A list of tuples containing the options. The first entry of the tuple is the value that will be returned, and the second is the text that will be displayed to the user Returns: T: The value of the selected option \"\"\" question = SelectQuestion ( prompt , options , ** kwargs ) return self . ask ( question ) def _standard_ask ( self , question : Question [ t . Any ]) -> t . Any : answer = None get_input : t . Callable [[], str ] = input if question . echo else lambda : getpass ( \"\" ) # type: ignore self . write_many ( question . render ()) self . flush () row , col = Cursor . getpos () self . write ( \" \\r\\n \" , flush = True ) row , col = self . ensure_space ( row , col ) Cursor . setpos ( row , col ) while answer is None : self . write ( clear_line ( \"after\" )) self . flush () user_input = get_input () try : answer = question . handle_answer ( user_input ) except QuestionError as e : self . write ( clear_line ()) self . error ( str ( e ), flush = True ) Cursor . setpos ( row , col ) self . write ( clear_line ()) self . flush () self . _answers . append (( question , answer )) return answer def _raw_ask ( self , question : RawQuestion [ t . Any ]) -> t . Any : row , col = Cursor . getpos () self . write_many ( question . render ()) new_row , col = self . ensure_space ( row , col ) self . scroll_terminal ( new_row - row - 1 ) self . flush () row = new_row Cursor . setpos ( row , col ) full_input : list [ str ] = [ \"\" ] with Cursor . hide (), RawTerminal () as term : while True : if question . is_done : question . on_done ( \" \\n \" . join ( full_input )) break if question . update_occured : Cursor . setpos ( row , col ) self . cycle_buffers () self . write_many ( question . render ()) self . flush () key = self . get_key ( term ) full_input [ - 1 ] += key if key . endswith ( \" \\n \" ): question . on_line ( full_input [ - 1 ]) full_input . append ( \"\" ) else : question . on_key ( key ) self . write ( \" \\n \" ) self . clear_buffers () result = question . result question . result = None self . _answers . append (( question , result )) return result def ensure_space ( self , curr_row : int , curr_col : int ) -> tuple [ int , int ]: total_rows = self . max_height () diff = total_rows - curr_row buffered_lines = self . buffered_lines if diff < buffered_lines : new_lines = buffered_lines - diff curr_row -= new_lines return curr_row , curr_col def max_height ( self ) -> int : return os . get_terminal_size ()[ 1 ] def write ( self , value : t . Any , flush : bool = False ) -> None : text = str ( value ) self . _buffer . append ( text ) if flush : self . flush () def write_front ( self , value : t . Any ) -> None : self . _buffer . insert ( 0 , str ( value )) def write_many ( self , values : t . Iterable [ t . Any ]) -> None : for v in values : self . write ( v ) def flush ( self ) -> None : self . out_stream . write ( \"\" . join ( self . _buffer )) self . out_stream . flush () self . _buffer = [] def cycle_buffers ( self ) -> None : self . _prev_buffer = self . _buffer self . _buffer = [] def clear_buffers ( self ) -> None : self . _prev_buffer = [] self . _buffer = [] def scroll_terminal ( self , lines : int ) -> None : self . write ( f \" \\x1b [ { lines } S\" ) def should_update ( self ) -> bool : return self . _buffer != self . _prev_buffer def get_key ( self , term : RawTerminal ) -> str : seq = term . getch () if seq == ESCAPE : seq += term . getch () # [ seq += term . getch () # Some Character return seq elif seq == \" \\r \" : return \" \\r\\n \" elif seq == CTRL_C : raise SystemExit ( 1 ) else : return seq def error ( self , message : str , ** kwargs : t . Any ) -> None : self . write ( f \" { fg . RED } \u2717 { message }{ fx . CLEAR } \" , ** kwargs ) @classmethod def __depends__ ( self , ctx : Context ) -> \"Prompt\" : return ctx . prompt confirm ( prompt , ** kwargs ) \u00b6 Get a yes / no confirmation from the user Source code in /home/runner/work/arc/arc/arc/prompt/prompt.py 70 71 72 73 74 def confirm ( self , prompt : str , ** kwargs : t . Any ) -> bool : \"\"\"Get a yes / no confirmation from the user\"\"\" prompt = f \" { prompt } [ { colorize ( 'y' , fg . GREEN ) } / { colorize ( 'n' , fg . RED ) } ] \" question = ConfirmQuestion ( prompt , ** kwargs ) return self . ask ( question ) input ( prompt , convert = str , ** kwargs ) \u00b6 Get input from the user Source code in /home/runner/work/arc/arc/arc/prompt/prompt.py 65 66 67 68 def input ( self , prompt : str , convert : type = str , ** kwargs : t . Any ) -> t . Any : \"\"\"Get input from the user\"\"\" question = InputQuestion [ str ]( prompt , convert , ** kwargs ) return self . ask ( question ) select ( prompt , options , ** kwargs ) \u00b6 Prompt the user to select from a list of options Parameters: Name Type Description Default prompt str The prompt to display to the user required options t . Sequence [ tuple [ T , str ]] A list of tuples containing the options. required Returns: Name Type Description T T The value of the selected option Source code in /home/runner/work/arc/arc/arc/prompt/prompt.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def select ( self , prompt : str , options : t . Sequence [ tuple [ T , str ]], ** kwargs : t . Any , ) -> T : \"\"\"Prompt the user to select from a list of options Args: prompt (str): The prompt to display to the user options (t.Sequence[tuple[T, str]]): A list of tuples containing the options. The first entry of the tuple is the value that will be returned, and the second is the text that will be displayed to the user Returns: T: The value of the selected option \"\"\" question = SelectQuestion ( prompt , options , ** kwargs ) return self . ask ( question )","title":"prompt.prompt"},{"location":"reference/prompt/prompt/#promptprompt","text":"","title":"prompt.prompt"},{"location":"reference/prompt/prompt/#arc.prompt.prompt.Prompt","text":"Source code in /home/runner/work/arc/arc/arc/prompt/prompt.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 class Prompt : def __init__ ( self ) -> None : self . out_stream = sys . stdout self . _buffer : list [ str ] = [] self . _prev_buffer : list [ str ] = [] self . _answers : list [ tuple [ BaseQuestion [ t . Any ], t . Any ]] = [] self . _max_line_lengths : dict [ int , int ] = {} @property def answers ( self ) -> list [ tuple [ BaseQuestion [ t . Any ], t . Any ]]: return self . _answers @property def buffered_lines ( self ) -> int : count = 0 for string in self . _buffer : for char in string : if char == \" \\n \" : count += 1 return count def ask ( self , question : BaseQuestion [ T ]) -> T : if isinstance ( question , RawQuestion ): return self . _raw_ask ( question ) elif isinstance ( question , Question ): return self . _standard_ask ( question ) raise RuntimeError ( \"Called Prompt.ask() with an invalid question object\" ) @t . overload def input ( self , prompt : str , ** kwargs : t . Any ) -> str : ... @t . overload def input ( self , prompt : str , convert : type [ T ], ** kwargs : t . Any ) -> T : ... def input ( self , prompt : str , convert : type = str , ** kwargs : t . Any ) -> t . Any : \"\"\"Get input from the user\"\"\" question = InputQuestion [ str ]( prompt , convert , ** kwargs ) return self . ask ( question ) def confirm ( self , prompt : str , ** kwargs : t . Any ) -> bool : \"\"\"Get a yes / no confirmation from the user\"\"\" prompt = f \" { prompt } [ { colorize ( 'y' , fg . GREEN ) } / { colorize ( 'n' , fg . RED ) } ] \" question = ConfirmQuestion ( prompt , ** kwargs ) return self . ask ( question ) def select ( self , prompt : str , options : t . Sequence [ tuple [ T , str ]], ** kwargs : t . Any , ) -> T : \"\"\"Prompt the user to select from a list of options Args: prompt (str): The prompt to display to the user options (t.Sequence[tuple[T, str]]): A list of tuples containing the options. The first entry of the tuple is the value that will be returned, and the second is the text that will be displayed to the user Returns: T: The value of the selected option \"\"\" question = SelectQuestion ( prompt , options , ** kwargs ) return self . ask ( question ) def _standard_ask ( self , question : Question [ t . Any ]) -> t . Any : answer = None get_input : t . Callable [[], str ] = input if question . echo else lambda : getpass ( \"\" ) # type: ignore self . write_many ( question . render ()) self . flush () row , col = Cursor . getpos () self . write ( \" \\r\\n \" , flush = True ) row , col = self . ensure_space ( row , col ) Cursor . setpos ( row , col ) while answer is None : self . write ( clear_line ( \"after\" )) self . flush () user_input = get_input () try : answer = question . handle_answer ( user_input ) except QuestionError as e : self . write ( clear_line ()) self . error ( str ( e ), flush = True ) Cursor . setpos ( row , col ) self . write ( clear_line ()) self . flush () self . _answers . append (( question , answer )) return answer def _raw_ask ( self , question : RawQuestion [ t . Any ]) -> t . Any : row , col = Cursor . getpos () self . write_many ( question . render ()) new_row , col = self . ensure_space ( row , col ) self . scroll_terminal ( new_row - row - 1 ) self . flush () row = new_row Cursor . setpos ( row , col ) full_input : list [ str ] = [ \"\" ] with Cursor . hide (), RawTerminal () as term : while True : if question . is_done : question . on_done ( \" \\n \" . join ( full_input )) break if question . update_occured : Cursor . setpos ( row , col ) self . cycle_buffers () self . write_many ( question . render ()) self . flush () key = self . get_key ( term ) full_input [ - 1 ] += key if key . endswith ( \" \\n \" ): question . on_line ( full_input [ - 1 ]) full_input . append ( \"\" ) else : question . on_key ( key ) self . write ( \" \\n \" ) self . clear_buffers () result = question . result question . result = None self . _answers . append (( question , result )) return result def ensure_space ( self , curr_row : int , curr_col : int ) -> tuple [ int , int ]: total_rows = self . max_height () diff = total_rows - curr_row buffered_lines = self . buffered_lines if diff < buffered_lines : new_lines = buffered_lines - diff curr_row -= new_lines return curr_row , curr_col def max_height ( self ) -> int : return os . get_terminal_size ()[ 1 ] def write ( self , value : t . Any , flush : bool = False ) -> None : text = str ( value ) self . _buffer . append ( text ) if flush : self . flush () def write_front ( self , value : t . Any ) -> None : self . _buffer . insert ( 0 , str ( value )) def write_many ( self , values : t . Iterable [ t . Any ]) -> None : for v in values : self . write ( v ) def flush ( self ) -> None : self . out_stream . write ( \"\" . join ( self . _buffer )) self . out_stream . flush () self . _buffer = [] def cycle_buffers ( self ) -> None : self . _prev_buffer = self . _buffer self . _buffer = [] def clear_buffers ( self ) -> None : self . _prev_buffer = [] self . _buffer = [] def scroll_terminal ( self , lines : int ) -> None : self . write ( f \" \\x1b [ { lines } S\" ) def should_update ( self ) -> bool : return self . _buffer != self . _prev_buffer def get_key ( self , term : RawTerminal ) -> str : seq = term . getch () if seq == ESCAPE : seq += term . getch () # [ seq += term . getch () # Some Character return seq elif seq == \" \\r \" : return \" \\r\\n \" elif seq == CTRL_C : raise SystemExit ( 1 ) else : return seq def error ( self , message : str , ** kwargs : t . Any ) -> None : self . write ( f \" { fg . RED } \u2717 { message }{ fx . CLEAR } \" , ** kwargs ) @classmethod def __depends__ ( self , ctx : Context ) -> \"Prompt\" : return ctx . prompt","title":"Prompt"},{"location":"reference/prompt/prompt/#arc.prompt.prompt.Prompt.confirm","text":"Get a yes / no confirmation from the user Source code in /home/runner/work/arc/arc/arc/prompt/prompt.py 70 71 72 73 74 def confirm ( self , prompt : str , ** kwargs : t . Any ) -> bool : \"\"\"Get a yes / no confirmation from the user\"\"\" prompt = f \" { prompt } [ { colorize ( 'y' , fg . GREEN ) } / { colorize ( 'n' , fg . RED ) } ] \" question = ConfirmQuestion ( prompt , ** kwargs ) return self . ask ( question )","title":"confirm()"},{"location":"reference/prompt/prompt/#arc.prompt.prompt.Prompt.input","text":"Get input from the user Source code in /home/runner/work/arc/arc/arc/prompt/prompt.py 65 66 67 68 def input ( self , prompt : str , convert : type = str , ** kwargs : t . Any ) -> t . Any : \"\"\"Get input from the user\"\"\" question = InputQuestion [ str ]( prompt , convert , ** kwargs ) return self . ask ( question )","title":"input()"},{"location":"reference/prompt/prompt/#arc.prompt.prompt.Prompt.select","text":"Prompt the user to select from a list of options Parameters: Name Type Description Default prompt str The prompt to display to the user required options t . Sequence [ tuple [ T , str ]] A list of tuples containing the options. required Returns: Name Type Description T T The value of the selected option Source code in /home/runner/work/arc/arc/arc/prompt/prompt.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def select ( self , prompt : str , options : t . Sequence [ tuple [ T , str ]], ** kwargs : t . Any , ) -> T : \"\"\"Prompt the user to select from a list of options Args: prompt (str): The prompt to display to the user options (t.Sequence[tuple[T, str]]): A list of tuples containing the options. The first entry of the tuple is the value that will be returned, and the second is the text that will be displayed to the user Returns: T: The value of the selected option \"\"\" question = SelectQuestion ( prompt , options , ** kwargs ) return self . ask ( question )","title":"select()"},{"location":"reference/prompt/prompts/","text":"prompt.prompts \u00b6","title":"prompt.prompts"},{"location":"reference/prompt/prompts/#promptprompts","text":"","title":"prompt.prompts"},{"location":"reference/prompt/questions/","text":"prompt.questions \u00b6 BaseQuestion \u00b6 Bases: ABC , t . Generic [ T ] Base Question class Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 18 19 20 21 22 23 24 25 26 27 28 29 class BaseQuestion ( ABC , t . Generic [ T ]): \"\"\"Base Question class\"\"\" def err ( self , error : str ) -> t . NoReturn : \"\"\"Inform the user that an error has occured when trying to process their answer\"\"\" raise QuestionError ( error ) @abstractmethod def render ( self ) -> t . Iterable [ str ]: \"\"\"Returns an iterable of strings to be printed to the output\"\"\" err ( error ) \u00b6 Inform the user that an error has occured when trying to process their answer Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 21 22 23 24 def err ( self , error : str ) -> t . NoReturn : \"\"\"Inform the user that an error has occured when trying to process their answer\"\"\" raise QuestionError ( error ) render () abstractmethod \u00b6 Returns an iterable of strings to be printed to the output Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 26 27 28 29 @abstractmethod def render ( self ) -> t . Iterable [ str ]: \"\"\"Returns an iterable of strings to be printed to the output\"\"\" ConfirmQuestion \u00b6 Bases: MappedInputQuestion [ bool ] Question to get a yes / no from the user Prompt.confirm() is an alias for asking this question Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class ConfirmQuestion ( MappedInputQuestion [ bool ]): \"\"\"Question to get a yes / no from the user `Prompt.confirm()` is an alias for asking this question \"\"\" def __init__ ( self , prompt : str , ** kwargs : t . Any ) -> None : super () . __init__ ( prompt , mapping = { \"y\" : True , \"yes\" : True , \"n\" : False , \"no\" : False , }, ** kwargs , ) InputQuestion \u00b6 Bases: Question [ T ] Question to request textual input from the user. Similar to using input() with add validations. Prompt.input() is an alias for asking this question Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class InputQuestion ( Question [ T ]): \"\"\"Question to request textual input from the user. Similar to using `input()` with add validations. `Prompt.input()` is an alias for asking this question \"\"\" def __init__ ( self , prompt : str , convert : type [ T ] = None , * , default : T | constants . Constant = constants . MISSING_DEFAULT , echo : bool = True , ) -> None : \"\"\" Args: prompt (str): String to be displayed before the cursor convert (type[T], optional): A type to attempt converting the user input into. Should be a supported arc type. If conversion fails, an error will be emmited and the user will be prompted to enter a value again. default (T | constants.Constant, optional): A default to return if the user does not enter any input (just hits the enter key). If there is no default provided, the user must give some form of input, or exit the program with Ctrl-C echo (bool, optional): Whether to echo the user's input out to the screen. \"\"\" super () . __init__ ( echo ) self . prompt = prompt self . convert_to = convert self . default = default def render ( self ) -> t . Iterable [ str ]: yield self . prompt def handle_answer ( self , value : str ) -> T : if not value : if self . default is not constants . MISSING_DEFAULT : return t . cast ( T , self . default ) else : self . err ( \"Cannot be blank\" ) value = self . validate ( value ) if self . convert_to is None : return t . cast ( T , value ) else : return self . convert ( value , self . convert_to ) def validate ( self , value : str ) -> t . Any : return value def convert ( self , value : str , type : type [ C ]) -> C : try : return arc . convert ( value , type ) except errors . ConversionError as e : self . err ( str ( e )) __init__ ( prompt , convert = None , * , default = constants . MISSING_DEFAULT , echo = True ) \u00b6 Parameters: Name Type Description Default prompt str String to be displayed before the cursor required convert type [ T ] A type to attempt converting the user input into. Should be a supported arc type. If conversion fails, an error will be emmited and the user will be prompted to enter a value again. None default T | constants . Constant A default to return if the user does not enter any input (just hits the enter key). If there is no default provided, the user must give some form of input, or exit the program with Ctrl-C constants.MISSING_DEFAULT echo bool Whether to echo the user's input out to the screen. True Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def __init__ ( self , prompt : str , convert : type [ T ] = None , * , default : T | constants . Constant = constants . MISSING_DEFAULT , echo : bool = True , ) -> None : \"\"\" Args: prompt (str): String to be displayed before the cursor convert (type[T], optional): A type to attempt converting the user input into. Should be a supported arc type. If conversion fails, an error will be emmited and the user will be prompted to enter a value again. default (T | constants.Constant, optional): A default to return if the user does not enter any input (just hits the enter key). If there is no default provided, the user must give some form of input, or exit the program with Ctrl-C echo (bool, optional): Whether to echo the user's input out to the screen. \"\"\" super () . __init__ ( echo ) self . prompt = prompt self . convert_to = convert self . default = default MultipleChoiceQuestion \u00b6 Bases: InputQuestion [ tuple [ int , str ]] Question with multiple possible options MultipleChoiceQuestion([\"Option 1\", \"Option 2\", \"Option 3\",]) [0] Option 1 [1] Option 2 [3] Option 3 Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 class MultipleChoiceQuestion ( InputQuestion [ tuple [ int , str ]]): \"\"\"Question with multiple possible options ``` MultipleChoiceQuestion([\"Option 1\", \"Option 2\", \"Option 3\",]) [0] Option 1 [1] Option 2 [3] Option 3 ``` \"\"\" def __init__ ( self , prompt : str , choices : t . Sequence [ str ], ** kwargs : t . Any ): super () . __init__ ( prompt , ** kwargs ) self . choices = choices def render ( self ) -> t . Iterable [ str ]: yield self . prompt + \" \\n \" for idx , choice in enumerate ( self . choices ): yield f \"[ { idx } ] { choice } \\n \" yield \"> \" def validate ( self , answer : str ) -> tuple [ int , str ]: val = self . convert ( answer , int ) if val < 0 or val >= len ( self . choices ): self . err ( \"Input not in range\" ) return val , self . choices [ val ] RangeQuestion \u00b6 Bases: InputQuestion [ int ] Question for a number in a given range Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class RangeQuestion ( InputQuestion [ int ]): \"\"\"Question for a number in a given range\"\"\" def __init__ ( self , prompt : str , min : int , max : int , ** kwargs : t . Any ): \"\"\" Args: min: the smallest number possible max: the largest number possible \"\"\" super () . __init__ ( prompt , convert = int , ** kwargs ) self . min = min self . max = max def validate ( self , answer : str ) -> int : val = self . convert ( answer , int ) if val < self . min or val > self . max : self . err ( f \"Must be between { self . min } and { self . max } \" ) return val __init__ ( prompt , min , max , ** kwargs ) \u00b6 Parameters: Name Type Description Default min int the smallest number possible required max int the largest number possible required Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 105 106 107 108 109 110 111 112 113 def __init__ ( self , prompt : str , min : int , max : int , ** kwargs : t . Any ): \"\"\" Args: min: the smallest number possible max: the largest number possible \"\"\" super () . __init__ ( prompt , convert = int , ** kwargs ) self . min = min self . max = max SelectQuestion \u00b6 Bases: RawQuestion [ T ] Presents the user with a menu that they can select an option from Prompt.select() is an alias for asking this question Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 class SelectQuestion ( RawQuestion [ T ]): \"\"\"Presents the user with a menu that they can select an option from `Prompt.select()` is an alias for asking this question \"\"\" selected = State ( 0 ) def __init__ ( self , prompt : str , options : t . Sequence [ tuple [ T , str ]], highlight_color : str = fg . ARC_BLUE , ) -> None : super () . __init__ () self . prompt = prompt self . char = \"\u276f\" self . options = self . __normalize_options ( options ) self . highlight_color = highlight_color def on_key ( self , key : str ) -> None : if key == ARROW_UP : self . selected = max ( 0 , self . selected - 1 ) elif key == ARROW_DOWN : self . selected = min ( len ( self . options ) - 1 , self . selected + 1 ) elif key . isnumeric (): index = int ( key ) if index < len ( self . options ): self . selected = index def on_line ( self , _line : str ) -> None : self . done ( self . options [ self . selected ][ 0 ]) def render ( self ) -> t . Iterable [ str ]: yield self . prompt yield \" \\n\\r \" for idx , item in enumerate ( self . options ): label = item [ 1 ] if idx == self . selected : yield colorize ( f \" { self . char } { label } \" , self . highlight_color ) else : yield colorize ( f \" { label } \" , fg . GREY ) yield \" \\r\\n \" def __normalize_options ( self , options : t . Sequence [ T ] | t . Sequence [ tuple [ T , str ]] ) -> t . Sequence [ tuple [ T , str ]]: if isinstance ( options [ 0 ], tuple ): return t . cast ( t . Sequence [ tuple [ T , str ]], options ) options = t . cast ( t . Sequence [ T ], options ) return [( item , str ( item )) for item in options ]","title":"prompt.questions"},{"location":"reference/prompt/questions/#promptquestions","text":"","title":"prompt.questions"},{"location":"reference/prompt/questions/#arc.prompt.questions.BaseQuestion","text":"Bases: ABC , t . Generic [ T ] Base Question class Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 18 19 20 21 22 23 24 25 26 27 28 29 class BaseQuestion ( ABC , t . Generic [ T ]): \"\"\"Base Question class\"\"\" def err ( self , error : str ) -> t . NoReturn : \"\"\"Inform the user that an error has occured when trying to process their answer\"\"\" raise QuestionError ( error ) @abstractmethod def render ( self ) -> t . Iterable [ str ]: \"\"\"Returns an iterable of strings to be printed to the output\"\"\"","title":"BaseQuestion"},{"location":"reference/prompt/questions/#arc.prompt.questions.BaseQuestion.err","text":"Inform the user that an error has occured when trying to process their answer Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 21 22 23 24 def err ( self , error : str ) -> t . NoReturn : \"\"\"Inform the user that an error has occured when trying to process their answer\"\"\" raise QuestionError ( error )","title":"err()"},{"location":"reference/prompt/questions/#arc.prompt.questions.BaseQuestion.render","text":"Returns an iterable of strings to be printed to the output Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 26 27 28 29 @abstractmethod def render ( self ) -> t . Iterable [ str ]: \"\"\"Returns an iterable of strings to be printed to the output\"\"\"","title":"render()"},{"location":"reference/prompt/questions/#arc.prompt.questions.ConfirmQuestion","text":"Bases: MappedInputQuestion [ bool ] Question to get a yes / no from the user Prompt.confirm() is an alias for asking this question Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class ConfirmQuestion ( MappedInputQuestion [ bool ]): \"\"\"Question to get a yes / no from the user `Prompt.confirm()` is an alias for asking this question \"\"\" def __init__ ( self , prompt : str , ** kwargs : t . Any ) -> None : super () . __init__ ( prompt , mapping = { \"y\" : True , \"yes\" : True , \"n\" : False , \"no\" : False , }, ** kwargs , )","title":"ConfirmQuestion"},{"location":"reference/prompt/questions/#arc.prompt.questions.InputQuestion","text":"Bases: Question [ T ] Question to request textual input from the user. Similar to using input() with add validations. Prompt.input() is an alias for asking this question Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class InputQuestion ( Question [ T ]): \"\"\"Question to request textual input from the user. Similar to using `input()` with add validations. `Prompt.input()` is an alias for asking this question \"\"\" def __init__ ( self , prompt : str , convert : type [ T ] = None , * , default : T | constants . Constant = constants . MISSING_DEFAULT , echo : bool = True , ) -> None : \"\"\" Args: prompt (str): String to be displayed before the cursor convert (type[T], optional): A type to attempt converting the user input into. Should be a supported arc type. If conversion fails, an error will be emmited and the user will be prompted to enter a value again. default (T | constants.Constant, optional): A default to return if the user does not enter any input (just hits the enter key). If there is no default provided, the user must give some form of input, or exit the program with Ctrl-C echo (bool, optional): Whether to echo the user's input out to the screen. \"\"\" super () . __init__ ( echo ) self . prompt = prompt self . convert_to = convert self . default = default def render ( self ) -> t . Iterable [ str ]: yield self . prompt def handle_answer ( self , value : str ) -> T : if not value : if self . default is not constants . MISSING_DEFAULT : return t . cast ( T , self . default ) else : self . err ( \"Cannot be blank\" ) value = self . validate ( value ) if self . convert_to is None : return t . cast ( T , value ) else : return self . convert ( value , self . convert_to ) def validate ( self , value : str ) -> t . Any : return value def convert ( self , value : str , type : type [ C ]) -> C : try : return arc . convert ( value , type ) except errors . ConversionError as e : self . err ( str ( e ))","title":"InputQuestion"},{"location":"reference/prompt/questions/#arc.prompt.questions.InputQuestion.__init__","text":"Parameters: Name Type Description Default prompt str String to be displayed before the cursor required convert type [ T ] A type to attempt converting the user input into. Should be a supported arc type. If conversion fails, an error will be emmited and the user will be prompted to enter a value again. None default T | constants . Constant A default to return if the user does not enter any input (just hits the enter key). If there is no default provided, the user must give some form of input, or exit the program with Ctrl-C constants.MISSING_DEFAULT echo bool Whether to echo the user's input out to the screen. True Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def __init__ ( self , prompt : str , convert : type [ T ] = None , * , default : T | constants . Constant = constants . MISSING_DEFAULT , echo : bool = True , ) -> None : \"\"\" Args: prompt (str): String to be displayed before the cursor convert (type[T], optional): A type to attempt converting the user input into. Should be a supported arc type. If conversion fails, an error will be emmited and the user will be prompted to enter a value again. default (T | constants.Constant, optional): A default to return if the user does not enter any input (just hits the enter key). If there is no default provided, the user must give some form of input, or exit the program with Ctrl-C echo (bool, optional): Whether to echo the user's input out to the screen. \"\"\" super () . __init__ ( echo ) self . prompt = prompt self . convert_to = convert self . default = default","title":"__init__()"},{"location":"reference/prompt/questions/#arc.prompt.questions.MultipleChoiceQuestion","text":"Bases: InputQuestion [ tuple [ int , str ]] Question with multiple possible options MultipleChoiceQuestion([\"Option 1\", \"Option 2\", \"Option 3\",]) [0] Option 1 [1] Option 2 [3] Option 3 Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 class MultipleChoiceQuestion ( InputQuestion [ tuple [ int , str ]]): \"\"\"Question with multiple possible options ``` MultipleChoiceQuestion([\"Option 1\", \"Option 2\", \"Option 3\",]) [0] Option 1 [1] Option 2 [3] Option 3 ``` \"\"\" def __init__ ( self , prompt : str , choices : t . Sequence [ str ], ** kwargs : t . Any ): super () . __init__ ( prompt , ** kwargs ) self . choices = choices def render ( self ) -> t . Iterable [ str ]: yield self . prompt + \" \\n \" for idx , choice in enumerate ( self . choices ): yield f \"[ { idx } ] { choice } \\n \" yield \"> \" def validate ( self , answer : str ) -> tuple [ int , str ]: val = self . convert ( answer , int ) if val < 0 or val >= len ( self . choices ): self . err ( \"Input not in range\" ) return val , self . choices [ val ]","title":"MultipleChoiceQuestion"},{"location":"reference/prompt/questions/#arc.prompt.questions.RangeQuestion","text":"Bases: InputQuestion [ int ] Question for a number in a given range Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class RangeQuestion ( InputQuestion [ int ]): \"\"\"Question for a number in a given range\"\"\" def __init__ ( self , prompt : str , min : int , max : int , ** kwargs : t . Any ): \"\"\" Args: min: the smallest number possible max: the largest number possible \"\"\" super () . __init__ ( prompt , convert = int , ** kwargs ) self . min = min self . max = max def validate ( self , answer : str ) -> int : val = self . convert ( answer , int ) if val < self . min or val > self . max : self . err ( f \"Must be between { self . min } and { self . max } \" ) return val","title":"RangeQuestion"},{"location":"reference/prompt/questions/#arc.prompt.questions.RangeQuestion.__init__","text":"Parameters: Name Type Description Default min int the smallest number possible required max int the largest number possible required Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 105 106 107 108 109 110 111 112 113 def __init__ ( self , prompt : str , min : int , max : int , ** kwargs : t . Any ): \"\"\" Args: min: the smallest number possible max: the largest number possible \"\"\" super () . __init__ ( prompt , convert = int , ** kwargs ) self . min = min self . max = max","title":"__init__()"},{"location":"reference/prompt/questions/#arc.prompt.questions.SelectQuestion","text":"Bases: RawQuestion [ T ] Presents the user with a menu that they can select an option from Prompt.select() is an alias for asking this question Source code in /home/runner/work/arc/arc/arc/prompt/questions.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 class SelectQuestion ( RawQuestion [ T ]): \"\"\"Presents the user with a menu that they can select an option from `Prompt.select()` is an alias for asking this question \"\"\" selected = State ( 0 ) def __init__ ( self , prompt : str , options : t . Sequence [ tuple [ T , str ]], highlight_color : str = fg . ARC_BLUE , ) -> None : super () . __init__ () self . prompt = prompt self . char = \"\u276f\" self . options = self . __normalize_options ( options ) self . highlight_color = highlight_color def on_key ( self , key : str ) -> None : if key == ARROW_UP : self . selected = max ( 0 , self . selected - 1 ) elif key == ARROW_DOWN : self . selected = min ( len ( self . options ) - 1 , self . selected + 1 ) elif key . isnumeric (): index = int ( key ) if index < len ( self . options ): self . selected = index def on_line ( self , _line : str ) -> None : self . done ( self . options [ self . selected ][ 0 ]) def render ( self ) -> t . Iterable [ str ]: yield self . prompt yield \" \\n\\r \" for idx , item in enumerate ( self . options ): label = item [ 1 ] if idx == self . selected : yield colorize ( f \" { self . char } { label } \" , self . highlight_color ) else : yield colorize ( f \" { label } \" , fg . GREY ) yield \" \\r\\n \" def __normalize_options ( self , options : t . Sequence [ T ] | t . Sequence [ tuple [ T , str ]] ) -> t . Sequence [ tuple [ T , str ]]: if isinstance ( options [ 0 ], tuple ): return t . cast ( t . Sequence [ tuple [ T , str ]], options ) options = t . cast ( t . Sequence [ T ], options ) return [( item , str ( item )) for item in options ]","title":"SelectQuestion"},{"location":"reference/runtime/app/","text":"runtime.app \u00b6","title":"runtime.app"},{"location":"reference/runtime/app/#runtimeapp","text":"","title":"runtime.app"},{"location":"reference/runtime/context/","text":"runtime.context \u00b6 Context \u00b6 Bases: collections . UserDict [ str , t . Any ] Context is a dict-like object that serves as the shared execution state for all arc component Source code in /home/runner/work/arc/arc/arc/runtime/context.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class Context ( collections . UserDict [ str , t . Any ]): \"\"\"Context is a dict-like object that serves as the shared execution state for all `arc` component \"\"\" @property def root ( self ) -> Command : \"\"\"The root command object. Alias for `ctx[\"arc.root\"]`\"\"\" return self [ \"arc.root\" ] @property def command ( self ) -> Command : \"\"\"The command object being executed. Alias for `ctx[\"arc.command\"]`\"\"\" return self [ \"arc.command\" ] @property def state ( self ) -> dict [ str , t . Any ]: \"\"\"The state object passed in. Alias for `ctx[\"arc.state\"]`\"\"\" return self [ \"arc.state\" ] @property def logger ( self ) -> Logger : \"\"\"The arc logger. Alias for `ctx[\"arc.logger\"]`\"\"\" return self [ \"arc.logger\" ] @property def app ( self ) -> App : \"\"\"The arc app. Alias for `ctx[\"arc.app\"]`\"\"\" return self [ \"arc.app\" ] @property def config ( self ) -> Config : \"\"\"The configuration for this app. Alias for `ctx[\"arc.config\"]`\"\"\" return self [ \"arc.config\" ] @property def prompt ( self ) -> Prompt : \"\"\"The prompt object congigured. Alias for `ctx[\"arc.config\"].prompt`\"\"\" return self . config . prompt def execute ( self , command : Command , ** kwargs : t . Any ) -> t . Any : \"\"\"Execute a command within the context of another command ```py import arc @arc.command def command(ctx: arc.Context): ctx.execute(sub, val=2) @command.subcommand def sub(val: int): print(sub) ``` \"\"\" return self . app . execute ( command , ** kwargs ) def set_origin ( self , param_name : str , origin : str ) -> None : \"\"\"Sets the origin of a parameter\"\"\" origins = self . setdefault ( \"arc.args.origins\" , {}) origins [ param_name ] = origin @t . overload def get_origin ( self , param_name : str ) -> str | None : ... @t . overload def get_origin ( self , param_name : str , default : T ) -> str | T : ... def get_origin ( self , param_name : str , default : T | None = None ) -> str | T | None : \"\"\"Gets the origin of a paramter\"\"\" origins : dict [ str , str ] | None = self . get ( \"arc.args.origins\" ) if not origins : return default return origins . get ( param_name , default ) @classmethod def __depends__ ( cls , ctx : Context ) -> Context : \"\"\"Makes the context a dependency\"\"\" return ctx app : App property \u00b6 The arc app. Alias for ctx[\"arc.app\"] command : Command property \u00b6 The command object being executed. Alias for ctx[\"arc.command\"] config : Config property \u00b6 The configuration for this app. Alias for ctx[\"arc.config\"] logger : Logger property \u00b6 The arc logger. Alias for ctx[\"arc.logger\"] prompt : Prompt property \u00b6 The prompt object congigured. Alias for ctx[\"arc.config\"].prompt root : Command property \u00b6 The root command object. Alias for ctx[\"arc.root\"] state : dict [ str , t . Any ] property \u00b6 The state object passed in. Alias for ctx[\"arc.state\"] __depends__ ( ctx ) classmethod \u00b6 Makes the context a dependency Source code in /home/runner/work/arc/arc/arc/runtime/context.py 99 100 101 102 @classmethod def __depends__ ( cls , ctx : Context ) -> Context : \"\"\"Makes the context a dependency\"\"\" return ctx execute ( command , ** kwargs ) \u00b6 Execute a command within the context of another command import arc @arc . command def command ( ctx : arc . Context ): ctx . execute ( sub , val = 2 ) @command . subcommand def sub ( val : int ): print ( sub ) Source code in /home/runner/work/arc/arc/arc/runtime/context.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def execute ( self , command : Command , ** kwargs : t . Any ) -> t . Any : \"\"\"Execute a command within the context of another command ```py import arc @arc.command def command(ctx: arc.Context): ctx.execute(sub, val=2) @command.subcommand def sub(val: int): print(sub) ``` \"\"\" return self . app . execute ( command , ** kwargs ) get_origin ( param_name , default = None ) \u00b6 Gets the origin of a paramter Source code in /home/runner/work/arc/arc/arc/runtime/context.py 90 91 92 93 94 95 96 97 def get_origin ( self , param_name : str , default : T | None = None ) -> str | T | None : \"\"\"Gets the origin of a paramter\"\"\" origins : dict [ str , str ] | None = self . get ( \"arc.args.origins\" ) if not origins : return default return origins . get ( param_name , default ) set_origin ( param_name , origin ) \u00b6 Sets the origin of a parameter Source code in /home/runner/work/arc/arc/arc/runtime/context.py 77 78 79 80 def set_origin ( self , param_name : str , origin : str ) -> None : \"\"\"Sets the origin of a parameter\"\"\" origins = self . setdefault ( \"arc.args.origins\" , {}) origins [ param_name ] = origin","title":"runtime.context"},{"location":"reference/runtime/context/#runtimecontext","text":"","title":"runtime.context"},{"location":"reference/runtime/context/#arc.runtime.context.Context","text":"Bases: collections . UserDict [ str , t . Any ] Context is a dict-like object that serves as the shared execution state for all arc component Source code in /home/runner/work/arc/arc/arc/runtime/context.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class Context ( collections . UserDict [ str , t . Any ]): \"\"\"Context is a dict-like object that serves as the shared execution state for all `arc` component \"\"\" @property def root ( self ) -> Command : \"\"\"The root command object. Alias for `ctx[\"arc.root\"]`\"\"\" return self [ \"arc.root\" ] @property def command ( self ) -> Command : \"\"\"The command object being executed. Alias for `ctx[\"arc.command\"]`\"\"\" return self [ \"arc.command\" ] @property def state ( self ) -> dict [ str , t . Any ]: \"\"\"The state object passed in. Alias for `ctx[\"arc.state\"]`\"\"\" return self [ \"arc.state\" ] @property def logger ( self ) -> Logger : \"\"\"The arc logger. Alias for `ctx[\"arc.logger\"]`\"\"\" return self [ \"arc.logger\" ] @property def app ( self ) -> App : \"\"\"The arc app. Alias for `ctx[\"arc.app\"]`\"\"\" return self [ \"arc.app\" ] @property def config ( self ) -> Config : \"\"\"The configuration for this app. Alias for `ctx[\"arc.config\"]`\"\"\" return self [ \"arc.config\" ] @property def prompt ( self ) -> Prompt : \"\"\"The prompt object congigured. Alias for `ctx[\"arc.config\"].prompt`\"\"\" return self . config . prompt def execute ( self , command : Command , ** kwargs : t . Any ) -> t . Any : \"\"\"Execute a command within the context of another command ```py import arc @arc.command def command(ctx: arc.Context): ctx.execute(sub, val=2) @command.subcommand def sub(val: int): print(sub) ``` \"\"\" return self . app . execute ( command , ** kwargs ) def set_origin ( self , param_name : str , origin : str ) -> None : \"\"\"Sets the origin of a parameter\"\"\" origins = self . setdefault ( \"arc.args.origins\" , {}) origins [ param_name ] = origin @t . overload def get_origin ( self , param_name : str ) -> str | None : ... @t . overload def get_origin ( self , param_name : str , default : T ) -> str | T : ... def get_origin ( self , param_name : str , default : T | None = None ) -> str | T | None : \"\"\"Gets the origin of a paramter\"\"\" origins : dict [ str , str ] | None = self . get ( \"arc.args.origins\" ) if not origins : return default return origins . get ( param_name , default ) @classmethod def __depends__ ( cls , ctx : Context ) -> Context : \"\"\"Makes the context a dependency\"\"\" return ctx","title":"Context"},{"location":"reference/runtime/context/#arc.runtime.context.Context.app","text":"The arc app. Alias for ctx[\"arc.app\"]","title":"app"},{"location":"reference/runtime/context/#arc.runtime.context.Context.command","text":"The command object being executed. Alias for ctx[\"arc.command\"]","title":"command"},{"location":"reference/runtime/context/#arc.runtime.context.Context.config","text":"The configuration for this app. Alias for ctx[\"arc.config\"]","title":"config"},{"location":"reference/runtime/context/#arc.runtime.context.Context.logger","text":"The arc logger. Alias for ctx[\"arc.logger\"]","title":"logger"},{"location":"reference/runtime/context/#arc.runtime.context.Context.prompt","text":"The prompt object congigured. Alias for ctx[\"arc.config\"].prompt","title":"prompt"},{"location":"reference/runtime/context/#arc.runtime.context.Context.root","text":"The root command object. Alias for ctx[\"arc.root\"]","title":"root"},{"location":"reference/runtime/context/#arc.runtime.context.Context.state","text":"The state object passed in. Alias for ctx[\"arc.state\"]","title":"state"},{"location":"reference/runtime/context/#arc.runtime.context.Context.__depends__","text":"Makes the context a dependency Source code in /home/runner/work/arc/arc/arc/runtime/context.py 99 100 101 102 @classmethod def __depends__ ( cls , ctx : Context ) -> Context : \"\"\"Makes the context a dependency\"\"\" return ctx","title":"__depends__()"},{"location":"reference/runtime/context/#arc.runtime.context.Context.execute","text":"Execute a command within the context of another command import arc @arc . command def command ( ctx : arc . Context ): ctx . execute ( sub , val = 2 ) @command . subcommand def sub ( val : int ): print ( sub ) Source code in /home/runner/work/arc/arc/arc/runtime/context.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def execute ( self , command : Command , ** kwargs : t . Any ) -> t . Any : \"\"\"Execute a command within the context of another command ```py import arc @arc.command def command(ctx: arc.Context): ctx.execute(sub, val=2) @command.subcommand def sub(val: int): print(sub) ``` \"\"\" return self . app . execute ( command , ** kwargs )","title":"execute()"},{"location":"reference/runtime/context/#arc.runtime.context.Context.get_origin","text":"Gets the origin of a paramter Source code in /home/runner/work/arc/arc/arc/runtime/context.py 90 91 92 93 94 95 96 97 def get_origin ( self , param_name : str , default : T | None = None ) -> str | T | None : \"\"\"Gets the origin of a paramter\"\"\" origins : dict [ str , str ] | None = self . get ( \"arc.args.origins\" ) if not origins : return default return origins . get ( param_name , default )","title":"get_origin()"},{"location":"reference/runtime/context/#arc.runtime.context.Context.set_origin","text":"Sets the origin of a parameter Source code in /home/runner/work/arc/arc/arc/runtime/context.py 77 78 79 80 def set_origin ( self , param_name : str , origin : str ) -> None : \"\"\"Sets the origin of a parameter\"\"\" origins = self . setdefault ( \"arc.args.origins\" , {}) origins [ param_name ] = origin","title":"set_origin()"},{"location":"reference/runtime/exec/","text":"runtime.exec \u00b6 Contains all of the middlewares used during execution of a command ApplyParseResultMiddleware \u00b6 Bases: ParamProcessor Update the parameter values with the values found from parsing the input Context Dependencies \u00b6 arc.parse.result arc.args.tree arc.config arc.args.origins Context Additions \u00b6 None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 class ApplyParseResultMiddleware ( ParamProcessor ): \"\"\"Update the parameter values with the values found from parsing the input # Context Dependencies - `arc.parse.result` - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" res : at . ParseResult def __call__ ( self , ctx : Context ) -> t . Any : self . res = ctx [ \"arc.parse.result\" ] return super () . __call__ ( ctx ) def process_missing ( self , param : Param [ t . Any ]) -> t . Any : value : t . Any = self . res . pop ( param . argument_name , constants . MISSING ) self . set_origin ( param , ValueOrigin . COMMAND_LINE ) # NOTE: This is dependent on the fact that the current parser # will return None for append action type parameters that # haven't been given any values. if value is None : if param . is_required : raise errors . MissingOptionValueError ( param ) else : return constants . MISSING return value CompileParamsMiddleware \u00b6 Bases: MiddlewareBase Compile the parameter tree into dictionary that can be used to call the command callback. Context Dependencies \u00b6 arc.args.tree Context Additions \u00b6 arc.args - Dictionary to pass into command callback Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 class CompileParamsMiddleware ( MiddlewareBase ): \"\"\"Compile the parameter tree into dictionary that can be used to call the command callback. # Context Dependencies - `arc.args.tree` # Context Additions - `arc.args` - Dictionary to pass into command callback \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : instance : ParamInstanceTree [ t . Any ] = ctx [ \"arc.args.tree\" ] ctx [ \"arc.args\" ] = instance . compile () ConvertValuesMiddleware \u00b6 Bases: ParamProcessor Performs type conversion on retrieved parameter values Context Dependencies \u00b6 arc.args.tree arc.config arc.args.origins Context Additions \u00b6 None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 class ConvertValuesMiddleware ( ParamProcessor ): \"\"\"Performs type conversion on retrieved parameter values # Context Dependencies - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" def process_not_missing ( self , param : Param [ t . Any ], value : t . Any ) -> t . Any : if value in ( None , constants . MISSING , True , False ) and param . type . origin in ( bool , t . Any , ): return value try : return param . convert ( value ) except errors . ConversionError as e : details = e . details if self . ctx . get_origin ( param . argument_name ) == ValueOrigin . ENV : details = f \"Invalid value in enviroment variable: { self . config . env_prefix }{ param . envvar } \" raise errors . InvalidParamValueError ( str ( e ), param , details ) from e DefaultValueMiddleware \u00b6 Bases: ParamProcessor Retrieves parameter values from the defaults for each parameter Context Dependencies \u00b6 arc.args.tree arc.config arc.args.origins Context Additions \u00b6 None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 class DefaultValueMiddleware ( ParamProcessor ): \"\"\"Retrieves parameter values from the defaults for each parameter # Context Dependencies - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" def process_missing ( self , param : Param [ t . Any ]) -> t . Any : self . set_origin ( param , ValueOrigin . DEFAULT ) return param . default DependancyInjectorMiddleware \u00b6 Bases: ParamProcessor Performs dependcy injection for relavent parameters Context Dependencies \u00b6 arc.args.tree arc.config arc.args.origins Context Additions \u00b6 None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 class DependancyInjectorMiddleware ( ParamProcessor ): \"\"\"Performs dependcy injection for relavent parameters # Context Dependencies - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" def process ( self , param : Param [ t . Any ], value : t . Any ) -> t . Any : param = t . cast ( InjectedParam [ t . Any ], param ) injected = param . get_injected_value ( self . ctx ) self . set_origin ( param , ValueOrigin . INJECTED ) return injected def skip ( self , param : Param [ t . Any ], _value : t . Any ) -> bool : return not param . is_injected ExecMiddleware \u00b6 Bases: DefaultMiddlewareNamespace Container for all default execution middlewares Use it to reference a default exec middleware when adding your own custom middlewares import arc @arc . command def command (): arc . print ( \"hello there\" ) @command . use ( after = arc . ExecMiddleware . ConverValues ) def after_convert ( ctx : arc . Context ): # Runs after type conversion occurs ... Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 class ExecMiddleware ( DefaultMiddlewareNamespace ): \"\"\"Container for all default execution middlewares Use it to reference a default exec middleware when adding your own custom middlewares ```py import arc @arc.command def command(): arc.print(\"hello there\") @command.use(after=arc.ExecMiddleware.ConverValues) def after_convert(ctx: arc.Context): # Runs after type conversion occurs ... ``` \"\"\" ExitStack = ExitStackMiddleware () SetupParam = SetupParamMiddleware () ApplyParseResult = ApplyParseResultMiddleware () GetEnvValue = GetEnvValueMiddleware () GetPromptValue = GetPromptValueMiddleware () GetterValue = GetterValueMiddleware () ConvertValues = ConvertValuesMiddleware () DefaultValue = DefaultValueMiddleware () DependancyInjector = DependancyInjectorMiddleware () RunTypeMiddleware = RunTypeMiddlewareMiddleware () RunCallbacks = RunCallbacksMiddleware () MissingParamsChecker = MissingParamsCheckerMiddleware () CompileParams = CompileParamsMiddleware () OpenResource = OpenResourceMiddleware () _list : list [ Middleware ] = [ ExitStack , SetupParam , ApplyParseResult , GetEnvValue , GetPromptValue , GetterValue , ConvertValues , DefaultValue , DependancyInjector , RunTypeMiddleware , RunCallbacks , MissingParamsChecker , CompileParams , OpenResource , ] ExitStackMiddleware \u00b6 Bases: MiddlewareBase Utility middleware that adds an instance of contextlib.ExitStack to the context. This can be used to open resources (like IO objects) that need to be closed when the program is exiting. Context Dependencies \u00b6 None Context Additions \u00b6 arc.exitstack Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class ExitStackMiddleware ( MiddlewareBase ): \"\"\"Utility middleware that adds an instance of `contextlib.ExitStack` to the context. This can be used to open resources (like IO objects) that need to be closed when the program is exiting. # Context Dependencies None # Context Additions - `arc.exitstack` \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : with contextlib . ExitStack () as stack : ctx [ \"arc.exitstack\" ] = stack yield if length := len ( stack . _exit_callbacks ): # type: ignore ctx . logger . debug ( \"Closing %d resource(s)\" , length ) GetEnvValueMiddleware \u00b6 Bases: ParamProcessor Retrieves parameter values from enviroment variables Context Dependencies \u00b6 arc.args.tree arc.config arc.args.origins Context Additions \u00b6 None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 class GetEnvValueMiddleware ( ParamProcessor ): \"\"\"Retrieves parameter values from enviroment variables # Context Dependencies - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" def process_missing ( self , param : Param [ t . Any ]) -> t . Any : value = self . get_env_value ( param ) self . set_origin ( param , ValueOrigin . ENV ) return value def get_env_value ( self , param : Param [ t . Any ]) -> str | constants . Constant : if not param . envvar : return constants . MISSING return os . getenv ( f \" { self . config . env_prefix }{ param . envvar } \" , constants . MISSING ) GetPromptValueMiddleware \u00b6 Bases: ParamProcessor Retrieves parameter values from user input Context Dependencies \u00b6 arc.args.tree arc.config arc.args.origins Context Additions \u00b6 None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 class GetPromptValueMiddleware ( ParamProcessor ): \"\"\"Retrieves parameter values from user input # Context Dependencies - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" def process_missing ( self , param : Param [ t . Any ]) -> t . Any : value = self . get_prompt_value ( param ) self . set_origin ( param , ValueOrigin . PROMPT ) return value def get_prompt_value ( self , param : Param [ t . Any ]) -> str | constants . Constant : if not param . prompt : return constants . MISSING prompter = getattr ( param . type . resolved_type , \"__prompt__\" , input_prompt ) return api . dispatch_args ( prompter , param , self . ctx ) GetterValueMiddleware \u00b6 Bases: ParamProcessor Retrieves parameter values from the parameter getter function Context Dependencies \u00b6 arc.args.tree arc.config arc.args.origins Context Additions \u00b6 None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 class GetterValueMiddleware ( ParamProcessor ): \"\"\"Retrieves parameter values from the parameter getter function # Context Dependencies - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" def process_missing ( self , param : Param [ t . Any ]) -> t . Any : value = self . get_getter_value ( param ) self . set_origin ( param , ValueOrigin . GETTER ) return value def get_getter_value ( self , param : Param [ t . Any ]) -> t . Any | constants . Constant : getter = param . getter_func if not getter : return constants . MISSING return api . dispatch_args ( getter , param , self . ctx ) MissingParamsCheckerMiddleware \u00b6 Bases: MiddlewareBase Checks to ensure that all params have been given a value Context Dependencies \u00b6 arc.args.tree Context Additions \u00b6 None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 class MissingParamsCheckerMiddleware ( MiddlewareBase ): \"\"\"Checks to ensure that all params have been given a value # Context Dependencies - `arc.args.tree` # Context Additions None \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : tree : ParamInstanceTree [ t . Any ] = ctx [ \"arc.args.tree\" ] missing = [ value . param for value in tree . leaves () if value . value is constants . MISSING and value . param . expose ] if missing : raise arc . errors . MissingArgValueError ( missing ) OpenResourceMiddleware \u00b6 Bases: MiddlewareBase Opens any parameter that is a context manager Context Dependencies \u00b6 arc.args arc.exitstack Context Additions \u00b6 None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 class OpenResourceMiddleware ( MiddlewareBase ): \"\"\"Opens any parameter that is a context manager # Context Dependencies - `arc.args` - `arc.exitstack` # Context Additions None \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : stack : contextlib . ExitStack | None = ctx . get ( \"arc.exitstack\" ) if not stack : return args : dict [ str , t . Any ] = ctx [ \"arc.args\" ] for key , val in args . items (): if isinstance ( val , constants . COLLECTION_TYPES ): cls = type ( val ) args [ key ] = cls ( item if not iscontextmanager ( item ) else stack . enter_context ( item ) for item in val ) if iscontextmanager ( val ): args [ key ] = stack . enter_context ( val ) RunTypeMiddlewareMiddleware \u00b6 Bases: ParamProcessor Execute the registered type middleware for each parameter Context Dependencies \u00b6 arc.args.tree arc.config arc.args.origins Context Additions \u00b6 None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 class RunTypeMiddlewareMiddleware ( ParamProcessor ): \"\"\"Execute the registered type middleware for each parameter # Context Dependencies - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" def process ( self , param : Param [ t . Any ], value : t . Any ) -> t . Any : if value not in ( None , constants . MISSING ): try : value = param . run_middleware ( value , self . ctx ) except errors . ValidationError as e : raise errors . InvalidParamValueError ( str ( e ), param ) from e return value def skip ( self , _param : Param [ t . Any ], _value : t . Any ) -> bool : return False # Don't want to skip any of the params SetupParamMiddleware \u00b6 Bases: MiddlewareBase Performs parameter setup for the given command Context Dependencies \u00b6 arc.command Context Additions \u00b6 arc.args.tree - Tree representing the command's parameters and their realized values arc.args.origins - Dictionary that stores where each parameter value comes from. See Context.get_origin() Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class SetupParamMiddleware ( MiddlewareBase ): \"\"\"Performs parameter setup for the given command # Context Dependencies - `arc.command` # Context Additions `arc.args.tree` - Tree representing the command's parameters and their realized values `arc.args.origins` - Dictionary that stores where each parameter value comes from. See `Context.get_origin()` \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : command : Command = ctx [ \"arc.command\" ] param_instance = command . param_def . create_instance () ctx [ \"arc.args.tree\" ] = param_instance ctx . setdefault ( \"arc.args.origins\" , {}) ctx . logger . debug ( \"Parsed input: %s \" , ctx . get ( \"arc.parse.result\" ))","title":"runtime.exec"},{"location":"reference/runtime/exec/#runtimeexec","text":"Contains all of the middlewares used during execution of a command","title":"runtime.exec"},{"location":"reference/runtime/exec/#arc.runtime.exec.ApplyParseResultMiddleware","text":"Bases: ParamProcessor Update the parameter values with the values found from parsing the input","title":"ApplyParseResultMiddleware"},{"location":"reference/runtime/exec/#arc.runtime.exec.ApplyParseResultMiddleware--context-dependencies","text":"arc.parse.result arc.args.tree arc.config arc.args.origins","title":"Context Dependencies"},{"location":"reference/runtime/exec/#arc.runtime.exec.ApplyParseResultMiddleware--context-additions","text":"None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 class ApplyParseResultMiddleware ( ParamProcessor ): \"\"\"Update the parameter values with the values found from parsing the input # Context Dependencies - `arc.parse.result` - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" res : at . ParseResult def __call__ ( self , ctx : Context ) -> t . Any : self . res = ctx [ \"arc.parse.result\" ] return super () . __call__ ( ctx ) def process_missing ( self , param : Param [ t . Any ]) -> t . Any : value : t . Any = self . res . pop ( param . argument_name , constants . MISSING ) self . set_origin ( param , ValueOrigin . COMMAND_LINE ) # NOTE: This is dependent on the fact that the current parser # will return None for append action type parameters that # haven't been given any values. if value is None : if param . is_required : raise errors . MissingOptionValueError ( param ) else : return constants . MISSING return value","title":"Context Additions"},{"location":"reference/runtime/exec/#arc.runtime.exec.CompileParamsMiddleware","text":"Bases: MiddlewareBase Compile the parameter tree into dictionary that can be used to call the command callback.","title":"CompileParamsMiddleware"},{"location":"reference/runtime/exec/#arc.runtime.exec.CompileParamsMiddleware--context-dependencies","text":"arc.args.tree","title":"Context Dependencies"},{"location":"reference/runtime/exec/#arc.runtime.exec.CompileParamsMiddleware--context-additions","text":"arc.args - Dictionary to pass into command callback Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 class CompileParamsMiddleware ( MiddlewareBase ): \"\"\"Compile the parameter tree into dictionary that can be used to call the command callback. # Context Dependencies - `arc.args.tree` # Context Additions - `arc.args` - Dictionary to pass into command callback \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : instance : ParamInstanceTree [ t . Any ] = ctx [ \"arc.args.tree\" ] ctx [ \"arc.args\" ] = instance . compile ()","title":"Context Additions"},{"location":"reference/runtime/exec/#arc.runtime.exec.ConvertValuesMiddleware","text":"Bases: ParamProcessor Performs type conversion on retrieved parameter values","title":"ConvertValuesMiddleware"},{"location":"reference/runtime/exec/#arc.runtime.exec.ConvertValuesMiddleware--context-dependencies","text":"arc.args.tree arc.config arc.args.origins","title":"Context Dependencies"},{"location":"reference/runtime/exec/#arc.runtime.exec.ConvertValuesMiddleware--context-additions","text":"None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 class ConvertValuesMiddleware ( ParamProcessor ): \"\"\"Performs type conversion on retrieved parameter values # Context Dependencies - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" def process_not_missing ( self , param : Param [ t . Any ], value : t . Any ) -> t . Any : if value in ( None , constants . MISSING , True , False ) and param . type . origin in ( bool , t . Any , ): return value try : return param . convert ( value ) except errors . ConversionError as e : details = e . details if self . ctx . get_origin ( param . argument_name ) == ValueOrigin . ENV : details = f \"Invalid value in enviroment variable: { self . config . env_prefix }{ param . envvar } \" raise errors . InvalidParamValueError ( str ( e ), param , details ) from e","title":"Context Additions"},{"location":"reference/runtime/exec/#arc.runtime.exec.DefaultValueMiddleware","text":"Bases: ParamProcessor Retrieves parameter values from the defaults for each parameter","title":"DefaultValueMiddleware"},{"location":"reference/runtime/exec/#arc.runtime.exec.DefaultValueMiddleware--context-dependencies","text":"arc.args.tree arc.config arc.args.origins","title":"Context Dependencies"},{"location":"reference/runtime/exec/#arc.runtime.exec.DefaultValueMiddleware--context-additions","text":"None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 class DefaultValueMiddleware ( ParamProcessor ): \"\"\"Retrieves parameter values from the defaults for each parameter # Context Dependencies - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" def process_missing ( self , param : Param [ t . Any ]) -> t . Any : self . set_origin ( param , ValueOrigin . DEFAULT ) return param . default","title":"Context Additions"},{"location":"reference/runtime/exec/#arc.runtime.exec.DependancyInjectorMiddleware","text":"Bases: ParamProcessor Performs dependcy injection for relavent parameters","title":"DependancyInjectorMiddleware"},{"location":"reference/runtime/exec/#arc.runtime.exec.DependancyInjectorMiddleware--context-dependencies","text":"arc.args.tree arc.config arc.args.origins","title":"Context Dependencies"},{"location":"reference/runtime/exec/#arc.runtime.exec.DependancyInjectorMiddleware--context-additions","text":"None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 class DependancyInjectorMiddleware ( ParamProcessor ): \"\"\"Performs dependcy injection for relavent parameters # Context Dependencies - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" def process ( self , param : Param [ t . Any ], value : t . Any ) -> t . Any : param = t . cast ( InjectedParam [ t . Any ], param ) injected = param . get_injected_value ( self . ctx ) self . set_origin ( param , ValueOrigin . INJECTED ) return injected def skip ( self , param : Param [ t . Any ], _value : t . Any ) -> bool : return not param . is_injected","title":"Context Additions"},{"location":"reference/runtime/exec/#arc.runtime.exec.ExecMiddleware","text":"Bases: DefaultMiddlewareNamespace Container for all default execution middlewares Use it to reference a default exec middleware when adding your own custom middlewares import arc @arc . command def command (): arc . print ( \"hello there\" ) @command . use ( after = arc . ExecMiddleware . ConverValues ) def after_convert ( ctx : arc . Context ): # Runs after type conversion occurs ... Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 class ExecMiddleware ( DefaultMiddlewareNamespace ): \"\"\"Container for all default execution middlewares Use it to reference a default exec middleware when adding your own custom middlewares ```py import arc @arc.command def command(): arc.print(\"hello there\") @command.use(after=arc.ExecMiddleware.ConverValues) def after_convert(ctx: arc.Context): # Runs after type conversion occurs ... ``` \"\"\" ExitStack = ExitStackMiddleware () SetupParam = SetupParamMiddleware () ApplyParseResult = ApplyParseResultMiddleware () GetEnvValue = GetEnvValueMiddleware () GetPromptValue = GetPromptValueMiddleware () GetterValue = GetterValueMiddleware () ConvertValues = ConvertValuesMiddleware () DefaultValue = DefaultValueMiddleware () DependancyInjector = DependancyInjectorMiddleware () RunTypeMiddleware = RunTypeMiddlewareMiddleware () RunCallbacks = RunCallbacksMiddleware () MissingParamsChecker = MissingParamsCheckerMiddleware () CompileParams = CompileParamsMiddleware () OpenResource = OpenResourceMiddleware () _list : list [ Middleware ] = [ ExitStack , SetupParam , ApplyParseResult , GetEnvValue , GetPromptValue , GetterValue , ConvertValues , DefaultValue , DependancyInjector , RunTypeMiddleware , RunCallbacks , MissingParamsChecker , CompileParams , OpenResource , ]","title":"ExecMiddleware"},{"location":"reference/runtime/exec/#arc.runtime.exec.ExitStackMiddleware","text":"Bases: MiddlewareBase Utility middleware that adds an instance of contextlib.ExitStack to the context. This can be used to open resources (like IO objects) that need to be closed when the program is exiting.","title":"ExitStackMiddleware"},{"location":"reference/runtime/exec/#arc.runtime.exec.ExitStackMiddleware--context-dependencies","text":"None","title":"Context Dependencies"},{"location":"reference/runtime/exec/#arc.runtime.exec.ExitStackMiddleware--context-additions","text":"arc.exitstack Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class ExitStackMiddleware ( MiddlewareBase ): \"\"\"Utility middleware that adds an instance of `contextlib.ExitStack` to the context. This can be used to open resources (like IO objects) that need to be closed when the program is exiting. # Context Dependencies None # Context Additions - `arc.exitstack` \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : with contextlib . ExitStack () as stack : ctx [ \"arc.exitstack\" ] = stack yield if length := len ( stack . _exit_callbacks ): # type: ignore ctx . logger . debug ( \"Closing %d resource(s)\" , length )","title":"Context Additions"},{"location":"reference/runtime/exec/#arc.runtime.exec.GetEnvValueMiddleware","text":"Bases: ParamProcessor Retrieves parameter values from enviroment variables","title":"GetEnvValueMiddleware"},{"location":"reference/runtime/exec/#arc.runtime.exec.GetEnvValueMiddleware--context-dependencies","text":"arc.args.tree arc.config arc.args.origins","title":"Context Dependencies"},{"location":"reference/runtime/exec/#arc.runtime.exec.GetEnvValueMiddleware--context-additions","text":"None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 class GetEnvValueMiddleware ( ParamProcessor ): \"\"\"Retrieves parameter values from enviroment variables # Context Dependencies - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" def process_missing ( self , param : Param [ t . Any ]) -> t . Any : value = self . get_env_value ( param ) self . set_origin ( param , ValueOrigin . ENV ) return value def get_env_value ( self , param : Param [ t . Any ]) -> str | constants . Constant : if not param . envvar : return constants . MISSING return os . getenv ( f \" { self . config . env_prefix }{ param . envvar } \" , constants . MISSING )","title":"Context Additions"},{"location":"reference/runtime/exec/#arc.runtime.exec.GetPromptValueMiddleware","text":"Bases: ParamProcessor Retrieves parameter values from user input","title":"GetPromptValueMiddleware"},{"location":"reference/runtime/exec/#arc.runtime.exec.GetPromptValueMiddleware--context-dependencies","text":"arc.args.tree arc.config arc.args.origins","title":"Context Dependencies"},{"location":"reference/runtime/exec/#arc.runtime.exec.GetPromptValueMiddleware--context-additions","text":"None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 class GetPromptValueMiddleware ( ParamProcessor ): \"\"\"Retrieves parameter values from user input # Context Dependencies - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" def process_missing ( self , param : Param [ t . Any ]) -> t . Any : value = self . get_prompt_value ( param ) self . set_origin ( param , ValueOrigin . PROMPT ) return value def get_prompt_value ( self , param : Param [ t . Any ]) -> str | constants . Constant : if not param . prompt : return constants . MISSING prompter = getattr ( param . type . resolved_type , \"__prompt__\" , input_prompt ) return api . dispatch_args ( prompter , param , self . ctx )","title":"Context Additions"},{"location":"reference/runtime/exec/#arc.runtime.exec.GetterValueMiddleware","text":"Bases: ParamProcessor Retrieves parameter values from the parameter getter function","title":"GetterValueMiddleware"},{"location":"reference/runtime/exec/#arc.runtime.exec.GetterValueMiddleware--context-dependencies","text":"arc.args.tree arc.config arc.args.origins","title":"Context Dependencies"},{"location":"reference/runtime/exec/#arc.runtime.exec.GetterValueMiddleware--context-additions","text":"None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 class GetterValueMiddleware ( ParamProcessor ): \"\"\"Retrieves parameter values from the parameter getter function # Context Dependencies - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" def process_missing ( self , param : Param [ t . Any ]) -> t . Any : value = self . get_getter_value ( param ) self . set_origin ( param , ValueOrigin . GETTER ) return value def get_getter_value ( self , param : Param [ t . Any ]) -> t . Any | constants . Constant : getter = param . getter_func if not getter : return constants . MISSING return api . dispatch_args ( getter , param , self . ctx )","title":"Context Additions"},{"location":"reference/runtime/exec/#arc.runtime.exec.MissingParamsCheckerMiddleware","text":"Bases: MiddlewareBase Checks to ensure that all params have been given a value","title":"MissingParamsCheckerMiddleware"},{"location":"reference/runtime/exec/#arc.runtime.exec.MissingParamsCheckerMiddleware--context-dependencies","text":"arc.args.tree","title":"Context Dependencies"},{"location":"reference/runtime/exec/#arc.runtime.exec.MissingParamsCheckerMiddleware--context-additions","text":"None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 class MissingParamsCheckerMiddleware ( MiddlewareBase ): \"\"\"Checks to ensure that all params have been given a value # Context Dependencies - `arc.args.tree` # Context Additions None \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : tree : ParamInstanceTree [ t . Any ] = ctx [ \"arc.args.tree\" ] missing = [ value . param for value in tree . leaves () if value . value is constants . MISSING and value . param . expose ] if missing : raise arc . errors . MissingArgValueError ( missing )","title":"Context Additions"},{"location":"reference/runtime/exec/#arc.runtime.exec.OpenResourceMiddleware","text":"Bases: MiddlewareBase Opens any parameter that is a context manager","title":"OpenResourceMiddleware"},{"location":"reference/runtime/exec/#arc.runtime.exec.OpenResourceMiddleware--context-dependencies","text":"arc.args arc.exitstack","title":"Context Dependencies"},{"location":"reference/runtime/exec/#arc.runtime.exec.OpenResourceMiddleware--context-additions","text":"None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 class OpenResourceMiddleware ( MiddlewareBase ): \"\"\"Opens any parameter that is a context manager # Context Dependencies - `arc.args` - `arc.exitstack` # Context Additions None \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : stack : contextlib . ExitStack | None = ctx . get ( \"arc.exitstack\" ) if not stack : return args : dict [ str , t . Any ] = ctx [ \"arc.args\" ] for key , val in args . items (): if isinstance ( val , constants . COLLECTION_TYPES ): cls = type ( val ) args [ key ] = cls ( item if not iscontextmanager ( item ) else stack . enter_context ( item ) for item in val ) if iscontextmanager ( val ): args [ key ] = stack . enter_context ( val )","title":"Context Additions"},{"location":"reference/runtime/exec/#arc.runtime.exec.RunTypeMiddlewareMiddleware","text":"Bases: ParamProcessor Execute the registered type middleware for each parameter","title":"RunTypeMiddlewareMiddleware"},{"location":"reference/runtime/exec/#arc.runtime.exec.RunTypeMiddlewareMiddleware--context-dependencies","text":"arc.args.tree arc.config arc.args.origins","title":"Context Dependencies"},{"location":"reference/runtime/exec/#arc.runtime.exec.RunTypeMiddlewareMiddleware--context-additions","text":"None Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 class RunTypeMiddlewareMiddleware ( ParamProcessor ): \"\"\"Execute the registered type middleware for each parameter # Context Dependencies - `arc.args.tree` - `arc.config` - `arc.args.origins` # Context Additions None \"\"\" def process ( self , param : Param [ t . Any ], value : t . Any ) -> t . Any : if value not in ( None , constants . MISSING ): try : value = param . run_middleware ( value , self . ctx ) except errors . ValidationError as e : raise errors . InvalidParamValueError ( str ( e ), param ) from e return value def skip ( self , _param : Param [ t . Any ], _value : t . Any ) -> bool : return False # Don't want to skip any of the params","title":"Context Additions"},{"location":"reference/runtime/exec/#arc.runtime.exec.SetupParamMiddleware","text":"Bases: MiddlewareBase Performs parameter setup for the given command","title":"SetupParamMiddleware"},{"location":"reference/runtime/exec/#arc.runtime.exec.SetupParamMiddleware--context-dependencies","text":"arc.command","title":"Context Dependencies"},{"location":"reference/runtime/exec/#arc.runtime.exec.SetupParamMiddleware--context-additions","text":"arc.args.tree - Tree representing the command's parameters and their realized values arc.args.origins - Dictionary that stores where each parameter value comes from. See Context.get_origin() Source code in /home/runner/work/arc/arc/arc/runtime/exec.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class SetupParamMiddleware ( MiddlewareBase ): \"\"\"Performs parameter setup for the given command # Context Dependencies - `arc.command` # Context Additions `arc.args.tree` - Tree representing the command's parameters and their realized values `arc.args.origins` - Dictionary that stores where each parameter value comes from. See `Context.get_origin()` \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : command : Command = ctx [ \"arc.command\" ] param_instance = command . param_def . create_instance () ctx [ \"arc.args.tree\" ] = param_instance ctx . setdefault ( \"arc.args.origins\" , {}) ctx . logger . debug ( \"Parsed input: %s \" , ctx . get ( \"arc.parse.result\" ))","title":"Context Additions"},{"location":"reference/runtime/init/","text":"runtime.init \u00b6 Contains all of the middlewares used during initialization of a command AddRuntimeParmsMiddleware \u00b6 Bases: MiddlewareBase Adds runtime-params to the root Command object Context Dependencies \u00b6 arc.root Context Additions \u00b6 None Added Parameters \u00b6 --version / -v : If there is a version set in the configuration --autocomplete : If shell completions are enabled Source code in /home/runner/work/arc/arc/arc/runtime/init.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 class AddRuntimeParmsMiddleware ( MiddlewareBase ): \"\"\"Adds runtime-params to the root Command object # Context Dependencies - `arc.root` # Context Additions None # Added Parameters - `--version / -v`: If there is a version set in the configuration - `--autocomplete`: If shell completions are enabled \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : if ctx . config . version : self . __add_version_param ( ctx . root . param_def ) if ctx . config . autocomplete : self . __add_autocomplete_param ( ctx . root . param_def ) def __add_version_param ( self , group : ParamDefinition ) -> None : group . params . insert ( 1 , FlagParam ( \"version\" , short_name = \"v\" , type = TypeInfo . analyze ( bool ), description = \"Displays the app's version number\" , default = False , action = CustomVersionAction , expose = False , ), ) def __add_autocomplete_param ( self , group : ParamDefinition ) -> None : annotation = t . Literal [ 1 ] annotation . __args__ = tuple ( autocompletions . ShellCompletion . shells . keys ()) # type: ignore group . params . insert ( 1 , OptionParam ( \"autocomplete\" , type = TypeInfo . analyze ( annotation ), description = \"Shell completion support\" , action = CustomAutocompleteAction , default = None , expose = False , ), ) AddUsageErrorInfoMiddleware \u00b6 Bases: MiddlewareBase A utility middleware that catches UsageError s and adds information so they can generate a usage error Context Dependencies \u00b6 arc.command (optional): Usage information comes from the current executing Command object Context Additions \u00b6 None Source code in /home/runner/work/arc/arc/arc/runtime/init.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 class AddUsageErrorInfoMiddleware ( MiddlewareBase ): \"\"\"A utility middleware that catches `UsageError`s and adds information so they can generate a usage error # Context Dependencies - `arc.command` (optional): Usage information comes from the current executing [`Command`][arc.define.command.Command] object # Context Additions None \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : try : yield except errors . UsageError as e : command = ctx . get ( \"arc.command\" ) if not command : ctx . logger . debug ( \"UsageError raised, but no command is set in context\" ) if e . command : ctx . logger . debug ( \"UsageError was raised, but a command is already attached\" ) else : e . command = command raise ArgParseMiddleware \u00b6 Bases: MiddlewareBase Middleware that parses the input using the argparse library Context Dependencies \u00b6 arc.command : The command to parse the input for arc.input : The input to parse Context Additions \u00b6 arc.parse.result : The result of the parsing arc.parse.extra : Any extra arguments that were not parsed Source code in /home/runner/work/arc/arc/arc/runtime/init.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 class ArgParseMiddleware ( MiddlewareBase ): \"\"\"Middleware that parses the input using the `argparse` library # Context Dependencies - `arc.command`: The command to parse the input for - `arc.input`: The input to parse # Context Additions - `arc.parse.result`: The result of the parsing - `arc.parse.extra`: Any extra arguments that were not parsed \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : args : list [ str ] = ctx [ \"arc.input\" ] result , extra = self . parse_args ( ctx . command , args ) ctx [ \"arc.parse.result\" ] = result ctx [ \"arc.parse.extra\" ] = extra def parse_args ( self , command : Command , args : list [ str ] ) -> tuple [ at . ParseResult , list [ str ]]: parser = self . create_parser ( command ) return parser . parse_known_intermixed_args ( args ) def create_parser ( self , command : Command ) -> Parser : parser = Parser ( add_help = False ) for param in command . cli_params : parser . add_param ( param , command ) return parser CheckParseResultsMiddleware \u00b6 Bases: MiddlewareBase Checks the results of the input parsing against configutation options. Generates error messages for unrecognized arguments Context Dependencies \u00b6 arc.config arc.parse.extra (optional) Context Additions \u00b6 Source code in /home/runner/work/arc/arc/arc/runtime/init.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 class CheckParseResultsMiddleware ( MiddlewareBase ): \"\"\"Checks the results of the input parsing against configutation options. Generates error messages for unrecognized arguments # Context Dependencies - `arc.config` - `arc.parse.extra` (optional) # Context Additions \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : extra : list [ str ] | None = ctx . get ( \"arc.parse.extra\" ) if extra and not ctx . config . allow_unrecognized_args : raise errors . UnrecognizedArgError ( extra ) CommandFinderMiddleware \u00b6 Bases: MiddlewareBase Middleware that finds the command to execute based on the input. Finds the command by walking the tree of commands from the root and comparing them with each next word in the input Context Dependencies \u00b6 arc.input : The input to find the command from Context Additions \u00b6 arc.command : The command to execute arc.input : The input to pass to the command. Will be what's left of the input after removing the command path Source code in /home/runner/work/arc/arc/arc/runtime/init.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class CommandFinderMiddleware ( MiddlewareBase ): \"\"\"Middleware that finds the command to execute based on the input. Finds the command by walking the tree of commands from the root and comparing them with each next word in the input # Context Dependencies - `arc.input`: The input to find the command from # Context Additions - `arc.command`: The command to execute - `arc.input`: The input to pass to the command. Will be what's left of the input after removing the command path \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : args : list [ str ] = ctx [ \"arc.input\" ] command , command_args = ctx . root . find_command ( args ) ctx [ \"arc.command\" ] = command ctx [ \"arc.input\" ] = command_args InitMiddleware \u00b6 Bases: DefaultMiddlewareNamespace Namespace for all the default init middlewares Use it to reference a default init middleware when adding your own custom middlewares import arc @arc . command def command (): arc . print ( \"hello there\" ) # To add your own init middlewares, you need to # create the App object explicitly app = arc . App ( command ) @app . use ( before = arc . InitMiddleware . Parser ) def before_parse ( ctx : arc . Context ): # Will run before the middleware that performs the parsing operation ... app () Source code in /home/runner/work/arc/arc/arc/runtime/init.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 class InitMiddleware ( DefaultMiddlewareNamespace ): \"\"\"Namespace for all the default init middlewares Use it to reference a default init middleware when adding your own custom middlewares ```py import arc @arc.command def command(): arc.print(\"hello there\") # To add your own init middlewares, you need to # create the App object explicitly app = arc.App(command) @app.use(before=arc.InitMiddleware.Parser) def before_parse(ctx: arc.Context): # Will run before the middleware that performs the parsing operation ... app() ``` \"\"\" StartTime = StartTimeMiddleware () LoadPlugins = LoadPluginsMiddleware () PerformDevChecks = PerformDevChecksMiddleware () AddRuntimeParms = AddRuntimeParmsMiddleware () AddUsageErrorInfo = AddUsageErrorInfoMiddleware () NormalizeInput = NormalizeInputMiddleware () CommandFinder = CommandFinderMiddleware () Parser = ArgParseMiddleware () CheckParseResult = CheckParseResultsMiddleware () _list : list [ Middleware ] = [ StartTime , LoadPlugins , PerformDevChecks , AddRuntimeParms , AddUsageErrorInfo , NormalizeInput , CommandFinder , Parser , CheckParseResult , ] LoadPluginsMiddleware \u00b6 Bases: MiddlewareBase Utility Middleware that loads plugins defined in the configuration into the application and calls their hooks Context Dependencies \u00b6 arc.config - Configuration object arc.app - Application object Context Additions \u00b6 None Source code in /home/runner/work/arc/arc/arc/runtime/init.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class LoadPluginsMiddleware ( MiddlewareBase ): \"\"\"Utility Middleware that loads plugins defined in the configuration into the application and calls their hooks # Context Dependencies - `arc.config` - Configuration object - `arc.app` - Application object # Context Additions None \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : ctx . logger . debug ( \"Loading plugins...\" ) app = ctx . app app . plugins . paths ( * ctx . config . plugins . paths ) app . plugins . groups ( * ctx . config . plugins . groups ) app . plugins . entrypoints ( * ctx . config . plugins . entrypoints ) if app . plugins : ctx . logger . debug ( \"Plugins loaded: %s \" , \", \" . join ( app . plugins )) ctx . logger . debug ( \"Calling plugin hooks...\" ) for name , p in app . plugins . items (): ctx . logger . debug ( \" Calling plugin hook: %s \" , name ) p ( ctx ) NormalizeInputMiddleware \u00b6 Bases: MiddlewareBase Middleware that normalizes different input sources. If input is provided when command is called, it will be normalized to an list. If input is not provided, sys.argv is used. Context Dependencies \u00b6 arc.input (optional): Only exists if input was provided in the call to the command Context Additions \u00b6 arc.input : Adds it if it's not already there, normalizes it if it is there Source code in /home/runner/work/arc/arc/arc/runtime/init.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 class NormalizeInputMiddleware ( MiddlewareBase ): \"\"\"Middleware that normalizes different input sources. If input is provided when command is called, it will be normalized to an list. If input is not provided, `sys.argv` is used. # Context Dependencies - `arc.input` (optional): Only exists if input was provided in the call to the command # Context Additions - `arc.input`: Adds it if it's not already there, normalizes it if it is there \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : args : at . InputArgs = ctx . get ( \"arc.input\" ) if args is None : ctx . logger . debug ( \"Using sys.argv as input: %s \" , sys . argv [ 1 :]) args = sys . argv [ 1 :] elif isinstance ( args , str ): args = shlex . split ( args ) ctx . logger . debug ( \"Using provided string as input. Shlex output: %s \" , args ) else : ctx . logger . debug ( \"Using provided iterable as input: %s \" , args ) args = list ( args ) ctx [ \"arc.input\" ] = args PerformDevChecksMiddleware \u00b6 Bases: MiddlewareBase A utility middleware that performs some development checks. Will be disabled in production mode. Context Dependencies \u00b6 arc.root - Root Command object to start checks from arc.concig - Checks Configuration for enviroment Context Additions \u00b6 None Source code in /home/runner/work/arc/arc/arc/runtime/init.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class PerformDevChecksMiddleware ( MiddlewareBase ): \"\"\"A utility middleware that performs some development checks. Will be disabled in production mode. # Context Dependencies - `arc.root` - Root Command object to start checks from - `arc.concig` - Checks Configuration for enviroment # Context Additions None \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : if ctx . config . environment == \"development\" : ctx . logger . debug ( \"Performing dev checks...\" ) ctx . logger . debug ( \" Checking all command parameters\" ) for command in ctx . root : if \"param_def\" not in command . __dict__ : command . param_def del command . param_def StartTimeMiddleware \u00b6 Bases: MiddlewareBase Utility Middleware that tracks how long execution takes Context Dependencies \u00b6 None Context Additions \u00b6 arc.debug.start - datetime representing the start of execution arc.debug.end - datetime representing the end of execution. Source code in /home/runner/work/arc/arc/arc/runtime/init.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class StartTimeMiddleware ( MiddlewareBase ): \"\"\"Utility Middleware that tracks how long execution takes # Context Dependencies None # Context Additions - `arc.debug.start` - datetime representing the start of execution - `arc.debug.end` - datetime representing the end of execution. \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : start = datetime . now () ctx [ \"arc.debug.start\" ] = start try : yield finally : end = datetime . now () ctx [ \"arc.debug.end\" ] = end diff = end - start ctx . logger . debug ( f \"Execution took: { diff . total_seconds () : .4f } s\" )","title":"runtime.init"},{"location":"reference/runtime/init/#runtimeinit","text":"Contains all of the middlewares used during initialization of a command","title":"runtime.init"},{"location":"reference/runtime/init/#arc.runtime.init.AddRuntimeParmsMiddleware","text":"Bases: MiddlewareBase Adds runtime-params to the root Command object","title":"AddRuntimeParmsMiddleware"},{"location":"reference/runtime/init/#arc.runtime.init.AddRuntimeParmsMiddleware--context-dependencies","text":"arc.root","title":"Context Dependencies"},{"location":"reference/runtime/init/#arc.runtime.init.AddRuntimeParmsMiddleware--context-additions","text":"None","title":"Context Additions"},{"location":"reference/runtime/init/#arc.runtime.init.AddRuntimeParmsMiddleware--added-parameters","text":"--version / -v : If there is a version set in the configuration --autocomplete : If shell completions are enabled Source code in /home/runner/work/arc/arc/arc/runtime/init.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 class AddRuntimeParmsMiddleware ( MiddlewareBase ): \"\"\"Adds runtime-params to the root Command object # Context Dependencies - `arc.root` # Context Additions None # Added Parameters - `--version / -v`: If there is a version set in the configuration - `--autocomplete`: If shell completions are enabled \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : if ctx . config . version : self . __add_version_param ( ctx . root . param_def ) if ctx . config . autocomplete : self . __add_autocomplete_param ( ctx . root . param_def ) def __add_version_param ( self , group : ParamDefinition ) -> None : group . params . insert ( 1 , FlagParam ( \"version\" , short_name = \"v\" , type = TypeInfo . analyze ( bool ), description = \"Displays the app's version number\" , default = False , action = CustomVersionAction , expose = False , ), ) def __add_autocomplete_param ( self , group : ParamDefinition ) -> None : annotation = t . Literal [ 1 ] annotation . __args__ = tuple ( autocompletions . ShellCompletion . shells . keys ()) # type: ignore group . params . insert ( 1 , OptionParam ( \"autocomplete\" , type = TypeInfo . analyze ( annotation ), description = \"Shell completion support\" , action = CustomAutocompleteAction , default = None , expose = False , ), )","title":"Added Parameters"},{"location":"reference/runtime/init/#arc.runtime.init.AddUsageErrorInfoMiddleware","text":"Bases: MiddlewareBase A utility middleware that catches UsageError s and adds information so they can generate a usage error","title":"AddUsageErrorInfoMiddleware"},{"location":"reference/runtime/init/#arc.runtime.init.AddUsageErrorInfoMiddleware--context-dependencies","text":"arc.command (optional): Usage information comes from the current executing Command object","title":"Context Dependencies"},{"location":"reference/runtime/init/#arc.runtime.init.AddUsageErrorInfoMiddleware--context-additions","text":"None Source code in /home/runner/work/arc/arc/arc/runtime/init.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 class AddUsageErrorInfoMiddleware ( MiddlewareBase ): \"\"\"A utility middleware that catches `UsageError`s and adds information so they can generate a usage error # Context Dependencies - `arc.command` (optional): Usage information comes from the current executing [`Command`][arc.define.command.Command] object # Context Additions None \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : try : yield except errors . UsageError as e : command = ctx . get ( \"arc.command\" ) if not command : ctx . logger . debug ( \"UsageError raised, but no command is set in context\" ) if e . command : ctx . logger . debug ( \"UsageError was raised, but a command is already attached\" ) else : e . command = command raise","title":"Context Additions"},{"location":"reference/runtime/init/#arc.runtime.init.ArgParseMiddleware","text":"Bases: MiddlewareBase Middleware that parses the input using the argparse library","title":"ArgParseMiddleware"},{"location":"reference/runtime/init/#arc.runtime.init.ArgParseMiddleware--context-dependencies","text":"arc.command : The command to parse the input for arc.input : The input to parse","title":"Context Dependencies"},{"location":"reference/runtime/init/#arc.runtime.init.ArgParseMiddleware--context-additions","text":"arc.parse.result : The result of the parsing arc.parse.extra : Any extra arguments that were not parsed Source code in /home/runner/work/arc/arc/arc/runtime/init.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 class ArgParseMiddleware ( MiddlewareBase ): \"\"\"Middleware that parses the input using the `argparse` library # Context Dependencies - `arc.command`: The command to parse the input for - `arc.input`: The input to parse # Context Additions - `arc.parse.result`: The result of the parsing - `arc.parse.extra`: Any extra arguments that were not parsed \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : args : list [ str ] = ctx [ \"arc.input\" ] result , extra = self . parse_args ( ctx . command , args ) ctx [ \"arc.parse.result\" ] = result ctx [ \"arc.parse.extra\" ] = extra def parse_args ( self , command : Command , args : list [ str ] ) -> tuple [ at . ParseResult , list [ str ]]: parser = self . create_parser ( command ) return parser . parse_known_intermixed_args ( args ) def create_parser ( self , command : Command ) -> Parser : parser = Parser ( add_help = False ) for param in command . cli_params : parser . add_param ( param , command ) return parser","title":"Context Additions"},{"location":"reference/runtime/init/#arc.runtime.init.CheckParseResultsMiddleware","text":"Bases: MiddlewareBase Checks the results of the input parsing against configutation options. Generates error messages for unrecognized arguments","title":"CheckParseResultsMiddleware"},{"location":"reference/runtime/init/#arc.runtime.init.CheckParseResultsMiddleware--context-dependencies","text":"arc.config arc.parse.extra (optional)","title":"Context Dependencies"},{"location":"reference/runtime/init/#arc.runtime.init.CheckParseResultsMiddleware--context-additions","text":"Source code in /home/runner/work/arc/arc/arc/runtime/init.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 class CheckParseResultsMiddleware ( MiddlewareBase ): \"\"\"Checks the results of the input parsing against configutation options. Generates error messages for unrecognized arguments # Context Dependencies - `arc.config` - `arc.parse.extra` (optional) # Context Additions \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : extra : list [ str ] | None = ctx . get ( \"arc.parse.extra\" ) if extra and not ctx . config . allow_unrecognized_args : raise errors . UnrecognizedArgError ( extra )","title":"Context Additions"},{"location":"reference/runtime/init/#arc.runtime.init.CommandFinderMiddleware","text":"Bases: MiddlewareBase Middleware that finds the command to execute based on the input. Finds the command by walking the tree of commands from the root and comparing them with each next word in the input","title":"CommandFinderMiddleware"},{"location":"reference/runtime/init/#arc.runtime.init.CommandFinderMiddleware--context-dependencies","text":"arc.input : The input to find the command from","title":"Context Dependencies"},{"location":"reference/runtime/init/#arc.runtime.init.CommandFinderMiddleware--context-additions","text":"arc.command : The command to execute arc.input : The input to pass to the command. Will be what's left of the input after removing the command path Source code in /home/runner/work/arc/arc/arc/runtime/init.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class CommandFinderMiddleware ( MiddlewareBase ): \"\"\"Middleware that finds the command to execute based on the input. Finds the command by walking the tree of commands from the root and comparing them with each next word in the input # Context Dependencies - `arc.input`: The input to find the command from # Context Additions - `arc.command`: The command to execute - `arc.input`: The input to pass to the command. Will be what's left of the input after removing the command path \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : args : list [ str ] = ctx [ \"arc.input\" ] command , command_args = ctx . root . find_command ( args ) ctx [ \"arc.command\" ] = command ctx [ \"arc.input\" ] = command_args","title":"Context Additions"},{"location":"reference/runtime/init/#arc.runtime.init.InitMiddleware","text":"Bases: DefaultMiddlewareNamespace Namespace for all the default init middlewares Use it to reference a default init middleware when adding your own custom middlewares import arc @arc . command def command (): arc . print ( \"hello there\" ) # To add your own init middlewares, you need to # create the App object explicitly app = arc . App ( command ) @app . use ( before = arc . InitMiddleware . Parser ) def before_parse ( ctx : arc . Context ): # Will run before the middleware that performs the parsing operation ... app () Source code in /home/runner/work/arc/arc/arc/runtime/init.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 class InitMiddleware ( DefaultMiddlewareNamespace ): \"\"\"Namespace for all the default init middlewares Use it to reference a default init middleware when adding your own custom middlewares ```py import arc @arc.command def command(): arc.print(\"hello there\") # To add your own init middlewares, you need to # create the App object explicitly app = arc.App(command) @app.use(before=arc.InitMiddleware.Parser) def before_parse(ctx: arc.Context): # Will run before the middleware that performs the parsing operation ... app() ``` \"\"\" StartTime = StartTimeMiddleware () LoadPlugins = LoadPluginsMiddleware () PerformDevChecks = PerformDevChecksMiddleware () AddRuntimeParms = AddRuntimeParmsMiddleware () AddUsageErrorInfo = AddUsageErrorInfoMiddleware () NormalizeInput = NormalizeInputMiddleware () CommandFinder = CommandFinderMiddleware () Parser = ArgParseMiddleware () CheckParseResult = CheckParseResultsMiddleware () _list : list [ Middleware ] = [ StartTime , LoadPlugins , PerformDevChecks , AddRuntimeParms , AddUsageErrorInfo , NormalizeInput , CommandFinder , Parser , CheckParseResult , ]","title":"InitMiddleware"},{"location":"reference/runtime/init/#arc.runtime.init.LoadPluginsMiddleware","text":"Bases: MiddlewareBase Utility Middleware that loads plugins defined in the configuration into the application and calls their hooks","title":"LoadPluginsMiddleware"},{"location":"reference/runtime/init/#arc.runtime.init.LoadPluginsMiddleware--context-dependencies","text":"arc.config - Configuration object arc.app - Application object","title":"Context Dependencies"},{"location":"reference/runtime/init/#arc.runtime.init.LoadPluginsMiddleware--context-additions","text":"None Source code in /home/runner/work/arc/arc/arc/runtime/init.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class LoadPluginsMiddleware ( MiddlewareBase ): \"\"\"Utility Middleware that loads plugins defined in the configuration into the application and calls their hooks # Context Dependencies - `arc.config` - Configuration object - `arc.app` - Application object # Context Additions None \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : ctx . logger . debug ( \"Loading plugins...\" ) app = ctx . app app . plugins . paths ( * ctx . config . plugins . paths ) app . plugins . groups ( * ctx . config . plugins . groups ) app . plugins . entrypoints ( * ctx . config . plugins . entrypoints ) if app . plugins : ctx . logger . debug ( \"Plugins loaded: %s \" , \", \" . join ( app . plugins )) ctx . logger . debug ( \"Calling plugin hooks...\" ) for name , p in app . plugins . items (): ctx . logger . debug ( \" Calling plugin hook: %s \" , name ) p ( ctx )","title":"Context Additions"},{"location":"reference/runtime/init/#arc.runtime.init.NormalizeInputMiddleware","text":"Bases: MiddlewareBase Middleware that normalizes different input sources. If input is provided when command is called, it will be normalized to an list. If input is not provided, sys.argv is used.","title":"NormalizeInputMiddleware"},{"location":"reference/runtime/init/#arc.runtime.init.NormalizeInputMiddleware--context-dependencies","text":"arc.input (optional): Only exists if input was provided in the call to the command","title":"Context Dependencies"},{"location":"reference/runtime/init/#arc.runtime.init.NormalizeInputMiddleware--context-additions","text":"arc.input : Adds it if it's not already there, normalizes it if it is there Source code in /home/runner/work/arc/arc/arc/runtime/init.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 class NormalizeInputMiddleware ( MiddlewareBase ): \"\"\"Middleware that normalizes different input sources. If input is provided when command is called, it will be normalized to an list. If input is not provided, `sys.argv` is used. # Context Dependencies - `arc.input` (optional): Only exists if input was provided in the call to the command # Context Additions - `arc.input`: Adds it if it's not already there, normalizes it if it is there \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : args : at . InputArgs = ctx . get ( \"arc.input\" ) if args is None : ctx . logger . debug ( \"Using sys.argv as input: %s \" , sys . argv [ 1 :]) args = sys . argv [ 1 :] elif isinstance ( args , str ): args = shlex . split ( args ) ctx . logger . debug ( \"Using provided string as input. Shlex output: %s \" , args ) else : ctx . logger . debug ( \"Using provided iterable as input: %s \" , args ) args = list ( args ) ctx [ \"arc.input\" ] = args","title":"Context Additions"},{"location":"reference/runtime/init/#arc.runtime.init.PerformDevChecksMiddleware","text":"Bases: MiddlewareBase A utility middleware that performs some development checks. Will be disabled in production mode.","title":"PerformDevChecksMiddleware"},{"location":"reference/runtime/init/#arc.runtime.init.PerformDevChecksMiddleware--context-dependencies","text":"arc.root - Root Command object to start checks from arc.concig - Checks Configuration for enviroment","title":"Context Dependencies"},{"location":"reference/runtime/init/#arc.runtime.init.PerformDevChecksMiddleware--context-additions","text":"None Source code in /home/runner/work/arc/arc/arc/runtime/init.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class PerformDevChecksMiddleware ( MiddlewareBase ): \"\"\"A utility middleware that performs some development checks. Will be disabled in production mode. # Context Dependencies - `arc.root` - Root Command object to start checks from - `arc.concig` - Checks Configuration for enviroment # Context Additions None \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : if ctx . config . environment == \"development\" : ctx . logger . debug ( \"Performing dev checks...\" ) ctx . logger . debug ( \" Checking all command parameters\" ) for command in ctx . root : if \"param_def\" not in command . __dict__ : command . param_def del command . param_def","title":"Context Additions"},{"location":"reference/runtime/init/#arc.runtime.init.StartTimeMiddleware","text":"Bases: MiddlewareBase Utility Middleware that tracks how long execution takes","title":"StartTimeMiddleware"},{"location":"reference/runtime/init/#arc.runtime.init.StartTimeMiddleware--context-dependencies","text":"None","title":"Context Dependencies"},{"location":"reference/runtime/init/#arc.runtime.init.StartTimeMiddleware--context-additions","text":"arc.debug.start - datetime representing the start of execution arc.debug.end - datetime representing the end of execution. Source code in /home/runner/work/arc/arc/arc/runtime/init.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class StartTimeMiddleware ( MiddlewareBase ): \"\"\"Utility Middleware that tracks how long execution takes # Context Dependencies None # Context Additions - `arc.debug.start` - datetime representing the start of execution - `arc.debug.end` - datetime representing the end of execution. \"\"\" def __call__ ( self , ctx : Context ) -> t . Any : start = datetime . now () ctx [ \"arc.debug.start\" ] = start try : yield finally : end = datetime . now () ctx [ \"arc.debug.end\" ] = end diff = end - start ctx . logger . debug ( f \"Execution took: { diff . total_seconds () : .4f } s\" )","title":"Context Additions"},{"location":"reference/runtime/middleware/","text":"runtime.middleware \u00b6 DefaultMiddlewareNamespace \u00b6 Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 235 236 237 238 239 240 241 242 243 244 245 246 247 class DefaultMiddlewareNamespace : _list : list [ Middleware ] @classmethod def all ( cls ) -> list [ Middleware ]: \"\"\"Returns a list of all default middlewares\"\"\" return cls . _list @classmethod def regsiter ( cls , name : str , middleware : Middleware ) -> None : \"\"\"Register a new default middleware.\"\"\" cls . _list . append ( middleware ) setattr ( cls , name , middleware ) all () classmethod \u00b6 Returns a list of all default middlewares Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 238 239 240 241 @classmethod def all ( cls ) -> list [ Middleware ]: \"\"\"Returns a list of all default middlewares\"\"\" return cls . _list regsiter ( name , middleware ) classmethod \u00b6 Register a new default middleware. Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 243 244 245 246 247 @classmethod def regsiter ( cls , name : str , middleware : Middleware ) -> None : \"\"\"Register a new default middleware.\"\"\" cls . _list . append ( middleware ) setattr ( cls , name , middleware ) MiddlewareManager \u00b6 Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 class MiddlewareManager : def __init__ ( self , middlewares : t . Sequence [ Middleware ]): self . _stack = MiddlewareStack ( middlewares ) @t . overload def use ( self , handler : None = None , * , pos : int | None = None , replace : Middleware | None = None , before : Middleware | None = None , after : Middleware | None = None , ) -> t . Callable [[ Middleware ], Middleware ]: ... @t . overload def use ( self , handler : Middleware , * , pos : int | None = None , replace : Middleware | None = None , before : Middleware | None = None , after : Middleware | None = None , ) -> Middleware : ... @t . overload def use ( self , handler : t . Sequence [ Middleware ], * , pos : int | None = None , replace : Middleware | None = None , before : Middleware | None = None , after : Middleware | None = None , ) -> t . Sequence [ Middleware ]: ... def use ( self , handler : t . Any = None , * , pos : int | None = None , replace : Middleware | None = None , before : Middleware | None = None , after : Middleware | None = None , ) -> t . Any : \"\"\"Register a middleware with this object. Args: handler (callable, optional): Callable to register as a middleware. Can optionally receive an array of middlewares. pos (int | None, optional): Index in the middleware stack to insert this middleware. Defaults to None. replace (Middleware | None, optional): A middleware you want to replace with this middleware. Defaults to None. before (Middleware | None, optional): Insert the provided `handler` before this middleware. Defaults to None. after (Middleware | None, optional): Insert the provided `handler` after this middleware. Defaults to None. \"\"\" def ensure_single_operation () -> None : ops = [ op for op in ( pos , replace , before , after ) if op is not None ] if len ( ops ) > 1 : raise errors . InternalError ( \"Cannot provide multiple operations for a single middleware\" ) def inner ( handler : Middleware ) -> Middleware : ensure_single_operation () if pos is not None : self . _stack . insert ( pos , handler ) elif replace : idx = self . _stack . index ( replace ) self . _stack [ idx ] = handler elif before : idx = self . _stack . index ( before ) self . _stack . insert ( idx - 1 , handler ) elif after : idx = self . _stack . index ( after ) self . _stack . insert ( idx + 1 , handler ) else : self . _stack . append ( handler ) return handler if handler : if callable ( handler ): return inner ( handler ) else : return [ inner ( f ) for f in handler ] return inner @t . overload def handle ( # type: ignore self , * exceptions : type [ E ] ) -> t . Callable [[ ErrorHandler [ E ]], ErrorHandler [ E ]]: ... @t . overload def handle ( self , handler : ErrorHandler [ E ], * exceptions : type [ BaseException ] ) -> ErrorHandler [ E ]: ... @t . overload def handle ( self , handler : t . Sequence [ ErrorHandler [ E ]], * exceptions : type [ E ] ) -> list [ ErrorHandler [ E ]]: ... def handle ( self , handler : t . Any | type = None , * exceptions : t . Any ) -> t . Any : \"\"\"Register an exception handler to this object Args: handler (ErrorHandler, optional): Error handler callback, receives the context and the exception object. \"\"\" def inner ( func : ErrorHandler [ E ]) -> ErrorHandler [ E ]: @self . use def error_handler ( ctx : Context ) -> t . Any : try : yield except exceptions as e : return func ( ctx , e ) return func if issubclass ( handler , BaseException ): exceptions = ( handler , * exceptions ) return inner elif callable ( handler ): return inner ( handler ) else : return [ inner ( f ) for f in handler ] handle ( handler = None , * exceptions ) \u00b6 Register an exception handler to this object Parameters: Name Type Description Default handler ErrorHandler Error handler callback, receives the context and the exception object. None Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def handle ( self , handler : t . Any | type = None , * exceptions : t . Any ) -> t . Any : \"\"\"Register an exception handler to this object Args: handler (ErrorHandler, optional): Error handler callback, receives the context and the exception object. \"\"\" def inner ( func : ErrorHandler [ E ]) -> ErrorHandler [ E ]: @self . use def error_handler ( ctx : Context ) -> t . Any : try : yield except exceptions as e : return func ( ctx , e ) return func if issubclass ( handler , BaseException ): exceptions = ( handler , * exceptions ) return inner elif callable ( handler ): return inner ( handler ) else : return [ inner ( f ) for f in handler ] use ( handler = None , * , pos = None , replace = None , before = None , after = None ) \u00b6 Register a middleware with this object. Parameters: Name Type Description Default handler callable Callable to register as a middleware. Can optionally receive an array of middlewares. None pos int | None Index in the middleware stack to insert this middleware. Defaults to None. None replace Middleware | None A middleware you want to replace with this middleware. Defaults to None. None before Middleware | None Insert the provided handler before this middleware. Defaults to None. None after Middleware | None Insert the provided handler after this middleware. Defaults to None. None Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def use ( self , handler : t . Any = None , * , pos : int | None = None , replace : Middleware | None = None , before : Middleware | None = None , after : Middleware | None = None , ) -> t . Any : \"\"\"Register a middleware with this object. Args: handler (callable, optional): Callable to register as a middleware. Can optionally receive an array of middlewares. pos (int | None, optional): Index in the middleware stack to insert this middleware. Defaults to None. replace (Middleware | None, optional): A middleware you want to replace with this middleware. Defaults to None. before (Middleware | None, optional): Insert the provided `handler` before this middleware. Defaults to None. after (Middleware | None, optional): Insert the provided `handler` after this middleware. Defaults to None. \"\"\" def ensure_single_operation () -> None : ops = [ op for op in ( pos , replace , before , after ) if op is not None ] if len ( ops ) > 1 : raise errors . InternalError ( \"Cannot provide multiple operations for a single middleware\" ) def inner ( handler : Middleware ) -> Middleware : ensure_single_operation () if pos is not None : self . _stack . insert ( pos , handler ) elif replace : idx = self . _stack . index ( replace ) self . _stack [ idx ] = handler elif before : idx = self . _stack . index ( before ) self . _stack . insert ( idx - 1 , handler ) elif after : idx = self . _stack . index ( after ) self . _stack . insert ( idx + 1 , handler ) else : self . _stack . append ( handler ) return handler if handler : if callable ( handler ): return inner ( handler ) else : return [ inner ( f ) for f in handler ] return inner MiddlewareStack \u00b6 Bases: collections . UserList [ Middleware ] Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class MiddlewareStack ( collections . UserList [ Middleware ]): __gens : list [ t . Generator [ None , t . Any , None ]] def __repr__ ( self ) -> str : return f \"MiddlewareStack( { self . data !r} )\" def start ( self , ctx : Context ) -> Context : self . __gens = [] for handler in self : res = handler ( ctx ) if isinstance ( res , types . GeneratorType ): self . __gens . append ( res ) res = next ( res ) res = t . cast ( t . Union [ \"Context\" , None ], res ) if res is not None : ctx = res return ctx def close ( self , result : t . Any ) -> t . Any : \"\"\"Closes each callback by calling `next()` on them\"\"\" for gen in reversed ( self . __gens ): try : gen . send ( result ) except StopIteration as e : if e . value is not None : result = e . value return result def throw ( self , exception : Exception ) -> None : \"\"\"Used if an error occurs in command execution. Notifies each of the callbacks that an error occured. Args: exception: The exception that occured within the executing command Raises: exception: if none of the callbacks handle the exception, re-raises \"\"\" exc_type = type ( exception ) trace = exception . __traceback__ exception_handled = False for gen in reversed ( self . __gens ): try : if exception_handled : try : next ( gen ) except StopIteration : ... else : gen . throw ( exc_type , exception , trace ) except StopIteration : exception_handled = True except Exception as e : exception = e exc_type = type ( e ) trace = e . __traceback__ if not exception_handled : raise exception def try_remove ( self , m : Middleware ) -> None : try : self . remove ( m ) except ValueError : ... close ( result ) \u00b6 Closes each callback by calling next() on them Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 50 51 52 53 54 55 56 57 58 59 def close ( self , result : t . Any ) -> t . Any : \"\"\"Closes each callback by calling `next()` on them\"\"\" for gen in reversed ( self . __gens ): try : gen . send ( result ) except StopIteration as e : if e . value is not None : result = e . value return result throw ( exception ) \u00b6 Used if an error occurs in command execution. Notifies each of the callbacks that an error occured. Parameters: Name Type Description Default exception Exception The exception that occured within the executing command required Raises: Type Description exception if none of the callbacks handle the exception, re-raises Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def throw ( self , exception : Exception ) -> None : \"\"\"Used if an error occurs in command execution. Notifies each of the callbacks that an error occured. Args: exception: The exception that occured within the executing command Raises: exception: if none of the callbacks handle the exception, re-raises \"\"\" exc_type = type ( exception ) trace = exception . __traceback__ exception_handled = False for gen in reversed ( self . __gens ): try : if exception_handled : try : next ( gen ) except StopIteration : ... else : gen . throw ( exc_type , exception , trace ) except StopIteration : exception_handled = True except Exception as e : exception = e exc_type = type ( e ) trace = e . __traceback__ if not exception_handled : raise exception","title":"runtime.middleware"},{"location":"reference/runtime/middleware/#runtimemiddleware","text":"","title":"runtime.middleware"},{"location":"reference/runtime/middleware/#arc.runtime.middleware.DefaultMiddlewareNamespace","text":"Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 235 236 237 238 239 240 241 242 243 244 245 246 247 class DefaultMiddlewareNamespace : _list : list [ Middleware ] @classmethod def all ( cls ) -> list [ Middleware ]: \"\"\"Returns a list of all default middlewares\"\"\" return cls . _list @classmethod def regsiter ( cls , name : str , middleware : Middleware ) -> None : \"\"\"Register a new default middleware.\"\"\" cls . _list . append ( middleware ) setattr ( cls , name , middleware )","title":"DefaultMiddlewareNamespace"},{"location":"reference/runtime/middleware/#arc.runtime.middleware.DefaultMiddlewareNamespace.all","text":"Returns a list of all default middlewares Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 238 239 240 241 @classmethod def all ( cls ) -> list [ Middleware ]: \"\"\"Returns a list of all default middlewares\"\"\" return cls . _list","title":"all()"},{"location":"reference/runtime/middleware/#arc.runtime.middleware.DefaultMiddlewareNamespace.regsiter","text":"Register a new default middleware. Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 243 244 245 246 247 @classmethod def regsiter ( cls , name : str , middleware : Middleware ) -> None : \"\"\"Register a new default middleware.\"\"\" cls . _list . append ( middleware ) setattr ( cls , name , middleware )","title":"regsiter()"},{"location":"reference/runtime/middleware/#arc.runtime.middleware.MiddlewareManager","text":"Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 class MiddlewareManager : def __init__ ( self , middlewares : t . Sequence [ Middleware ]): self . _stack = MiddlewareStack ( middlewares ) @t . overload def use ( self , handler : None = None , * , pos : int | None = None , replace : Middleware | None = None , before : Middleware | None = None , after : Middleware | None = None , ) -> t . Callable [[ Middleware ], Middleware ]: ... @t . overload def use ( self , handler : Middleware , * , pos : int | None = None , replace : Middleware | None = None , before : Middleware | None = None , after : Middleware | None = None , ) -> Middleware : ... @t . overload def use ( self , handler : t . Sequence [ Middleware ], * , pos : int | None = None , replace : Middleware | None = None , before : Middleware | None = None , after : Middleware | None = None , ) -> t . Sequence [ Middleware ]: ... def use ( self , handler : t . Any = None , * , pos : int | None = None , replace : Middleware | None = None , before : Middleware | None = None , after : Middleware | None = None , ) -> t . Any : \"\"\"Register a middleware with this object. Args: handler (callable, optional): Callable to register as a middleware. Can optionally receive an array of middlewares. pos (int | None, optional): Index in the middleware stack to insert this middleware. Defaults to None. replace (Middleware | None, optional): A middleware you want to replace with this middleware. Defaults to None. before (Middleware | None, optional): Insert the provided `handler` before this middleware. Defaults to None. after (Middleware | None, optional): Insert the provided `handler` after this middleware. Defaults to None. \"\"\" def ensure_single_operation () -> None : ops = [ op for op in ( pos , replace , before , after ) if op is not None ] if len ( ops ) > 1 : raise errors . InternalError ( \"Cannot provide multiple operations for a single middleware\" ) def inner ( handler : Middleware ) -> Middleware : ensure_single_operation () if pos is not None : self . _stack . insert ( pos , handler ) elif replace : idx = self . _stack . index ( replace ) self . _stack [ idx ] = handler elif before : idx = self . _stack . index ( before ) self . _stack . insert ( idx - 1 , handler ) elif after : idx = self . _stack . index ( after ) self . _stack . insert ( idx + 1 , handler ) else : self . _stack . append ( handler ) return handler if handler : if callable ( handler ): return inner ( handler ) else : return [ inner ( f ) for f in handler ] return inner @t . overload def handle ( # type: ignore self , * exceptions : type [ E ] ) -> t . Callable [[ ErrorHandler [ E ]], ErrorHandler [ E ]]: ... @t . overload def handle ( self , handler : ErrorHandler [ E ], * exceptions : type [ BaseException ] ) -> ErrorHandler [ E ]: ... @t . overload def handle ( self , handler : t . Sequence [ ErrorHandler [ E ]], * exceptions : type [ E ] ) -> list [ ErrorHandler [ E ]]: ... def handle ( self , handler : t . Any | type = None , * exceptions : t . Any ) -> t . Any : \"\"\"Register an exception handler to this object Args: handler (ErrorHandler, optional): Error handler callback, receives the context and the exception object. \"\"\" def inner ( func : ErrorHandler [ E ]) -> ErrorHandler [ E ]: @self . use def error_handler ( ctx : Context ) -> t . Any : try : yield except exceptions as e : return func ( ctx , e ) return func if issubclass ( handler , BaseException ): exceptions = ( handler , * exceptions ) return inner elif callable ( handler ): return inner ( handler ) else : return [ inner ( f ) for f in handler ]","title":"MiddlewareManager"},{"location":"reference/runtime/middleware/#arc.runtime.middleware.MiddlewareManager.handle","text":"Register an exception handler to this object Parameters: Name Type Description Default handler ErrorHandler Error handler callback, receives the context and the exception object. None Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def handle ( self , handler : t . Any | type = None , * exceptions : t . Any ) -> t . Any : \"\"\"Register an exception handler to this object Args: handler (ErrorHandler, optional): Error handler callback, receives the context and the exception object. \"\"\" def inner ( func : ErrorHandler [ E ]) -> ErrorHandler [ E ]: @self . use def error_handler ( ctx : Context ) -> t . Any : try : yield except exceptions as e : return func ( ctx , e ) return func if issubclass ( handler , BaseException ): exceptions = ( handler , * exceptions ) return inner elif callable ( handler ): return inner ( handler ) else : return [ inner ( f ) for f in handler ]","title":"handle()"},{"location":"reference/runtime/middleware/#arc.runtime.middleware.MiddlewareManager.use","text":"Register a middleware with this object. Parameters: Name Type Description Default handler callable Callable to register as a middleware. Can optionally receive an array of middlewares. None pos int | None Index in the middleware stack to insert this middleware. Defaults to None. None replace Middleware | None A middleware you want to replace with this middleware. Defaults to None. None before Middleware | None Insert the provided handler before this middleware. Defaults to None. None after Middleware | None Insert the provided handler after this middleware. Defaults to None. None Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def use ( self , handler : t . Any = None , * , pos : int | None = None , replace : Middleware | None = None , before : Middleware | None = None , after : Middleware | None = None , ) -> t . Any : \"\"\"Register a middleware with this object. Args: handler (callable, optional): Callable to register as a middleware. Can optionally receive an array of middlewares. pos (int | None, optional): Index in the middleware stack to insert this middleware. Defaults to None. replace (Middleware | None, optional): A middleware you want to replace with this middleware. Defaults to None. before (Middleware | None, optional): Insert the provided `handler` before this middleware. Defaults to None. after (Middleware | None, optional): Insert the provided `handler` after this middleware. Defaults to None. \"\"\" def ensure_single_operation () -> None : ops = [ op for op in ( pos , replace , before , after ) if op is not None ] if len ( ops ) > 1 : raise errors . InternalError ( \"Cannot provide multiple operations for a single middleware\" ) def inner ( handler : Middleware ) -> Middleware : ensure_single_operation () if pos is not None : self . _stack . insert ( pos , handler ) elif replace : idx = self . _stack . index ( replace ) self . _stack [ idx ] = handler elif before : idx = self . _stack . index ( before ) self . _stack . insert ( idx - 1 , handler ) elif after : idx = self . _stack . index ( after ) self . _stack . insert ( idx + 1 , handler ) else : self . _stack . append ( handler ) return handler if handler : if callable ( handler ): return inner ( handler ) else : return [ inner ( f ) for f in handler ] return inner","title":"use()"},{"location":"reference/runtime/middleware/#arc.runtime.middleware.MiddlewareStack","text":"Bases: collections . UserList [ Middleware ] Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class MiddlewareStack ( collections . UserList [ Middleware ]): __gens : list [ t . Generator [ None , t . Any , None ]] def __repr__ ( self ) -> str : return f \"MiddlewareStack( { self . data !r} )\" def start ( self , ctx : Context ) -> Context : self . __gens = [] for handler in self : res = handler ( ctx ) if isinstance ( res , types . GeneratorType ): self . __gens . append ( res ) res = next ( res ) res = t . cast ( t . Union [ \"Context\" , None ], res ) if res is not None : ctx = res return ctx def close ( self , result : t . Any ) -> t . Any : \"\"\"Closes each callback by calling `next()` on them\"\"\" for gen in reversed ( self . __gens ): try : gen . send ( result ) except StopIteration as e : if e . value is not None : result = e . value return result def throw ( self , exception : Exception ) -> None : \"\"\"Used if an error occurs in command execution. Notifies each of the callbacks that an error occured. Args: exception: The exception that occured within the executing command Raises: exception: if none of the callbacks handle the exception, re-raises \"\"\" exc_type = type ( exception ) trace = exception . __traceback__ exception_handled = False for gen in reversed ( self . __gens ): try : if exception_handled : try : next ( gen ) except StopIteration : ... else : gen . throw ( exc_type , exception , trace ) except StopIteration : exception_handled = True except Exception as e : exception = e exc_type = type ( e ) trace = e . __traceback__ if not exception_handled : raise exception def try_remove ( self , m : Middleware ) -> None : try : self . remove ( m ) except ValueError : ...","title":"MiddlewareStack"},{"location":"reference/runtime/middleware/#arc.runtime.middleware.MiddlewareStack.close","text":"Closes each callback by calling next() on them Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 50 51 52 53 54 55 56 57 58 59 def close ( self , result : t . Any ) -> t . Any : \"\"\"Closes each callback by calling `next()` on them\"\"\" for gen in reversed ( self . __gens ): try : gen . send ( result ) except StopIteration as e : if e . value is not None : result = e . value return result","title":"close()"},{"location":"reference/runtime/middleware/#arc.runtime.middleware.MiddlewareStack.throw","text":"Used if an error occurs in command execution. Notifies each of the callbacks that an error occured. Parameters: Name Type Description Default exception Exception The exception that occured within the executing command required Raises: Type Description exception if none of the callbacks handle the exception, re-raises Source code in /home/runner/work/arc/arc/arc/runtime/middleware.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def throw ( self , exception : Exception ) -> None : \"\"\"Used if an error occurs in command execution. Notifies each of the callbacks that an error occured. Args: exception: The exception that occured within the executing command Raises: exception: if none of the callbacks handle the exception, re-raises \"\"\" exc_type = type ( exception ) trace = exception . __traceback__ exception_handled = False for gen in reversed ( self . __gens ): try : if exception_handled : try : next ( gen ) except StopIteration : ... else : gen . throw ( exc_type , exception , trace ) except StopIteration : exception_handled = True except Exception as e : exception = e exc_type = type ( e ) trace = e . __traceback__ if not exception_handled : raise exception","title":"throw()"},{"location":"reference/runtime/plugin/","text":"runtime.plugin \u00b6 EntryPointsPluginLoader \u00b6 Bases: PluginLoader Loads plugins from entry point groups https://packaging.python.org/en/latest/specifications/entry-points/ Source code in /home/runner/work/arc/arc/arc/runtime/plugin.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class EntryPointsPluginLoader ( PluginLoader ): \"\"\"Loads plugins from entry point groups https://packaging.python.org/en/latest/specifications/entry-points/ \"\"\" def __init__ ( self , manager : PluginManager , locations : t . Iterable [ str ], filter : str , ) -> None : self . filter = filter super () . __init__ ( manager , locations ) def load ( self ) -> None : for entry_point in self . __get_entry_points ( self . locations ): plugin = entry_point . load () self . manager . register ( entry_point . name , plugin ) def __get_entry_points ( self , locations : t . Iterable [ str ] ) -> t . Iterator [ metadata . EntryPoint ]: for location in locations : for entry_point in metadata . entry_points ( ** { self . filter : location }): yield entry_point # type: ignore PathPluginLoader \u00b6 Bases: PluginLoader Loads plugins from a a set of file paths Source code in /home/runner/work/arc/arc/arc/runtime/plugin.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 class PathPluginLoader ( PluginLoader ): \"\"\"Loads plugins from a a set of file paths\"\"\" def load ( self ) -> None : for path in self . __get_paths ( self . locations ): plugin = self . __load_plugin ( path ) if plugin : self . manager . register ( str ( path ), plugin ) def __get_paths ( self , paths : t . Iterable [ str ]) -> t . Iterator [ Path ]: for filepath in paths : path = self . path ( filepath ) if not path : continue if path . name . startswith ( \"__\" ): continue if path . is_dir (): yield from self . __get_paths ( path . iterdir ()) # type: ignore else : yield path def __load_plugin ( self , path : Path ) -> Plugin | None : sys . path . append ( str ( path . parent )) module = import_module ( path . stem ) return getattr ( module , \"plugin\" , None ) @staticmethod def path ( filepath : str ) -> t . Optional [ Path ]: path = Path ( filepath ) path = path . expanduser () . resolve () if path . exists (): return path return None","title":"runtime.plugin"},{"location":"reference/runtime/plugin/#runtimeplugin","text":"","title":"runtime.plugin"},{"location":"reference/runtime/plugin/#arc.runtime.plugin.EntryPointsPluginLoader","text":"Bases: PluginLoader Loads plugins from entry point groups https://packaging.python.org/en/latest/specifications/entry-points/ Source code in /home/runner/work/arc/arc/arc/runtime/plugin.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class EntryPointsPluginLoader ( PluginLoader ): \"\"\"Loads plugins from entry point groups https://packaging.python.org/en/latest/specifications/entry-points/ \"\"\" def __init__ ( self , manager : PluginManager , locations : t . Iterable [ str ], filter : str , ) -> None : self . filter = filter super () . __init__ ( manager , locations ) def load ( self ) -> None : for entry_point in self . __get_entry_points ( self . locations ): plugin = entry_point . load () self . manager . register ( entry_point . name , plugin ) def __get_entry_points ( self , locations : t . Iterable [ str ] ) -> t . Iterator [ metadata . EntryPoint ]: for location in locations : for entry_point in metadata . entry_points ( ** { self . filter : location }): yield entry_point # type: ignore","title":"EntryPointsPluginLoader"},{"location":"reference/runtime/plugin/#arc.runtime.plugin.PathPluginLoader","text":"Bases: PluginLoader Loads plugins from a a set of file paths Source code in /home/runner/work/arc/arc/arc/runtime/plugin.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 class PathPluginLoader ( PluginLoader ): \"\"\"Loads plugins from a a set of file paths\"\"\" def load ( self ) -> None : for path in self . __get_paths ( self . locations ): plugin = self . __load_plugin ( path ) if plugin : self . manager . register ( str ( path ), plugin ) def __get_paths ( self , paths : t . Iterable [ str ]) -> t . Iterator [ Path ]: for filepath in paths : path = self . path ( filepath ) if not path : continue if path . name . startswith ( \"__\" ): continue if path . is_dir (): yield from self . __get_paths ( path . iterdir ()) # type: ignore else : yield path def __load_plugin ( self , path : Path ) -> Plugin | None : sys . path . append ( str ( path . parent )) module = import_module ( path . stem ) return getattr ( module , \"plugin\" , None ) @staticmethod def path ( filepath : str ) -> t . Optional [ Path ]: path = Path ( filepath ) path = path . expanduser () . resolve () if path . exists (): return path return None","title":"PathPluginLoader"},{"location":"reference/types/aliases/","text":"types.aliases \u00b6 Module for all Alias types. Alias types are types that handle to conversion for other types. All builtin types (int, str, float, etc...) have a corresponding Alias type. Alias \u00b6 Parent class for all aliases. Stores references to all known alias types and handles resolving them. Additionally, it provides a convenience wrapper for alias types by implementing a custom cls.__convert__() that calls cls.convert() for non-parameterized types and cls.g_convert() for generic types. Source code in /home/runner/work/arc/arc/arc/types/aliases.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class Alias : \"\"\"Parent class for all aliases. Stores references to all known alias types and handles resolving them. Additionally, it provides a convenience wrapper for alias types by implementing a custom `cls.__convert__()` that calls `cls.convert()` for non-parameterized types and `cls.g_convert()` for generic types. \"\"\" aliases : dict [ Annotation , type [ TypeProtocol ]] = {} alias_for : t . ClassVar [ AliasFor | tuple [ AliasFor ]] = None # type: ignore name : t . ClassVar [ t . Optional [ str ]] = None convert : t . Callable [ ... , t . Any ] g_convert : t . Callable [ ... , t . Any ] @classmethod def __convert__ ( cls , value : str , typ : TypeInfo [ T ]) -> T : if cls . name : typ . name = cls . name if not typ . sub_types : obj = api . dispatch_args ( cls . convert , value , typ ) else : obj = api . dispatch_args ( cls . g_convert , value , typ ) return obj def __init_subclass__ ( cls , of : t . Optional [ AliasFor | tuple [ AliasFor ]] = None ): if of : cls . alias_for = of if isinstance ( cls . alias_for , tuple ): aliases = cls . alias_for else : aliases = ( cls . alias_for ,) for alias in aliases : Alias . aliases [ alias ] = cls # type: ignore @classmethod def resolve ( cls , annotation : Annotation ) -> type [ TypeProtocol ]: \"\"\"Handles resolving alias types\"\"\" if safe . issubclass ( annotation , TypeProtocol ): return t . cast ( type [ TypeProtocol ], annotation ) elif annotation in cls . aliases : # Type is a key # We perform this check once before hand # because some typing types don't have # the mro() method return cls . aliases [ annotation ] else : assert isinstance ( annotation , type ), f \" { annotation } is not a type\" # Type is a subclass of a key for parent in annotation . mro (): if parent in cls . aliases : return cls . aliases [ parent ] name = colorize ( annotation . __name__ , fg . YELLOW ) raise TypeError ( f \" { name } is not a valid type. \" f \"Please ensure that { name } conforms to the custom type protocol \" f \"or that there is a alias type registered for it: \" \"https://arc.seancollings.dev/usage/parameters/types/custom-types\" ) resolve ( annotation ) classmethod \u00b6 Handles resolving alias types Source code in /home/runner/work/arc/arc/arc/types/aliases.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 @classmethod def resolve ( cls , annotation : Annotation ) -> type [ TypeProtocol ]: \"\"\"Handles resolving alias types\"\"\" if safe . issubclass ( annotation , TypeProtocol ): return t . cast ( type [ TypeProtocol ], annotation ) elif annotation in cls . aliases : # Type is a key # We perform this check once before hand # because some typing types don't have # the mro() method return cls . aliases [ annotation ] else : assert isinstance ( annotation , type ), f \" { annotation } is not a type\" # Type is a subclass of a key for parent in annotation . mro (): if parent in cls . aliases : return cls . aliases [ parent ] name = colorize ( annotation . __name__ , fg . YELLOW ) raise TypeError ( f \" { name } is not a valid type. \" f \"Please ensure that { name } conforms to the custom type protocol \" f \"or that there is a alias type registered for it: \" \"https://arc.seancollings.dev/usage/parameters/types/custom-types\" )","title":"types.aliases"},{"location":"reference/types/aliases/#typesaliases","text":"Module for all Alias types. Alias types are types that handle to conversion for other types. All builtin types (int, str, float, etc...) have a corresponding Alias type.","title":"types.aliases"},{"location":"reference/types/aliases/#arc.types.aliases.Alias","text":"Parent class for all aliases. Stores references to all known alias types and handles resolving them. Additionally, it provides a convenience wrapper for alias types by implementing a custom cls.__convert__() that calls cls.convert() for non-parameterized types and cls.g_convert() for generic types. Source code in /home/runner/work/arc/arc/arc/types/aliases.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class Alias : \"\"\"Parent class for all aliases. Stores references to all known alias types and handles resolving them. Additionally, it provides a convenience wrapper for alias types by implementing a custom `cls.__convert__()` that calls `cls.convert()` for non-parameterized types and `cls.g_convert()` for generic types. \"\"\" aliases : dict [ Annotation , type [ TypeProtocol ]] = {} alias_for : t . ClassVar [ AliasFor | tuple [ AliasFor ]] = None # type: ignore name : t . ClassVar [ t . Optional [ str ]] = None convert : t . Callable [ ... , t . Any ] g_convert : t . Callable [ ... , t . Any ] @classmethod def __convert__ ( cls , value : str , typ : TypeInfo [ T ]) -> T : if cls . name : typ . name = cls . name if not typ . sub_types : obj = api . dispatch_args ( cls . convert , value , typ ) else : obj = api . dispatch_args ( cls . g_convert , value , typ ) return obj def __init_subclass__ ( cls , of : t . Optional [ AliasFor | tuple [ AliasFor ]] = None ): if of : cls . alias_for = of if isinstance ( cls . alias_for , tuple ): aliases = cls . alias_for else : aliases = ( cls . alias_for ,) for alias in aliases : Alias . aliases [ alias ] = cls # type: ignore @classmethod def resolve ( cls , annotation : Annotation ) -> type [ TypeProtocol ]: \"\"\"Handles resolving alias types\"\"\" if safe . issubclass ( annotation , TypeProtocol ): return t . cast ( type [ TypeProtocol ], annotation ) elif annotation in cls . aliases : # Type is a key # We perform this check once before hand # because some typing types don't have # the mro() method return cls . aliases [ annotation ] else : assert isinstance ( annotation , type ), f \" { annotation } is not a type\" # Type is a subclass of a key for parent in annotation . mro (): if parent in cls . aliases : return cls . aliases [ parent ] name = colorize ( annotation . __name__ , fg . YELLOW ) raise TypeError ( f \" { name } is not a valid type. \" f \"Please ensure that { name } conforms to the custom type protocol \" f \"or that there is a alias type registered for it: \" \"https://arc.seancollings.dev/usage/parameters/types/custom-types\" )","title":"Alias"},{"location":"reference/types/aliases/#arc.types.aliases.Alias.resolve","text":"Handles resolving alias types Source code in /home/runner/work/arc/arc/arc/types/aliases.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 @classmethod def resolve ( cls , annotation : Annotation ) -> type [ TypeProtocol ]: \"\"\"Handles resolving alias types\"\"\" if safe . issubclass ( annotation , TypeProtocol ): return t . cast ( type [ TypeProtocol ], annotation ) elif annotation in cls . aliases : # Type is a key # We perform this check once before hand # because some typing types don't have # the mro() method return cls . aliases [ annotation ] else : assert isinstance ( annotation , type ), f \" { annotation } is not a type\" # Type is a subclass of a key for parent in annotation . mro (): if parent in cls . aliases : return cls . aliases [ parent ] name = colorize ( annotation . __name__ , fg . YELLOW ) raise TypeError ( f \" { name } is not a valid type. \" f \"Please ensure that { name } conforms to the custom type protocol \" f \"or that there is a alias type registered for it: \" \"https://arc.seancollings.dev/usage/parameters/types/custom-types\" )","title":"resolve()"},{"location":"reference/types/convert/","text":"types.convert \u00b6 convert_type ( protocol , value , info ) \u00b6 Uses protocol to convert value Source code in /home/runner/work/arc/arc/arc/types/convert.py 14 15 16 17 18 19 20 def convert_type ( protocol : type [ TypeProtocol ], value : t . Any , info : types . TypeInfo [ T ], ) -> T : \"\"\"Uses `protocol` to convert `value`\"\"\" return api . dispatch_args ( protocol . __convert__ , value , info )","title":"types.convert"},{"location":"reference/types/convert/#typesconvert","text":"","title":"types.convert"},{"location":"reference/types/convert/#arc.types.convert.convert_type","text":"Uses protocol to convert value Source code in /home/runner/work/arc/arc/arc/types/convert.py 14 15 16 17 18 19 20 def convert_type ( protocol : type [ TypeProtocol ], value : t . Any , info : types . TypeInfo [ T ], ) -> T : \"\"\"Uses `protocol` to convert `value`\"\"\" return api . dispatch_args ( protocol . __convert__ , value , info )","title":"convert_type()"},{"location":"reference/types/dates/","text":"types.dates \u00b6","title":"types.dates"},{"location":"reference/types/dates/#typesdates","text":"","title":"types.dates"},{"location":"reference/types/default/","text":"types.default \u00b6","title":"types.default"},{"location":"reference/types/default/#typesdefault","text":"","title":"types.default"},{"location":"reference/types/file/","text":"types.file \u00b6 Stdin = t . Union [ t . Annotated [ Stream , Stream . Args ( sys . stdin )], io . StringIO ] module-attribute \u00b6 Read input from command line, or from stdin if - is passed as the argument File \u00b6 Bases: t . IO [ str ] , abc . ABC Obtains a handler to a file. Handles the access to the file, and gurantees that it is closed before exiting. Example \u00b6 @arc . command def command ( file : File . Read ): arc . print ( file . read ()) There are constants defined on File (like File.Read above) for all common actions ( Read , Write , Append , ReadWrite , etc...). View all of them below. If none of the pre-defiend constants match your needs, you can customize it with an Annotated type. @arc . command def command ( file : Annotated [ File , File . Args ( ... )]): arc . print ( file . read ()) File.Args 's call signature matches that of open (minus the filename), so all of the same properties apply File is Abstract and cannot be instantiated on it's own Source code in /home/runner/work/arc/arc/arc/types/file.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class File ( t . IO [ str ], abc . ABC ): \"\"\"Obtains a handler to a file. Handles the access to the file, and gurantees that it is closed before exiting. ## Example ```py @arc.command def command(file: File.Read): arc.print(file.read()) ``` There are constants defined on `File` (like `File.Read` above) for all common actions (`Read`, `Write`, `Append`, `ReadWrite`, etc...). View all of them below. If none of the pre-defiend constants match your needs, you can customize it with an `Annotated` type. ```py @arc.command def command(file: Annotated[File, File.Args(...)]): arc.print(file.read()) ``` `File.Args`'s call signature matches that of `open` (minus the filename), so all of the same properties apply `File` is Abstract and cannot be instantiated on it's own \"\"\" class Args ( TypeArg ): __slots__ = ( \"mode\" , \"buffering\" , \"encoding\" , \"errors\" , \"newline\" , \"closefd\" , \"opener\" , ) def __init__ ( self , mode : str = Default ( \"r\" ), buffering : int = Default ( - 1 ), encoding : t . Optional [ str ] = Default ( None ), errors : OpenErrors = Default ( None ), newline : OpenNewline = Default ( None ), closefd : bool = Default ( True ), opener : t . Optional [ t . Callable [ ... , t . Any ]] = Default ( None ), ): self . mode = mode self . buffering = buffering self . encoding = encoding self . errors = errors self . newline = newline self . closefd = closefd self . opener = opener Read = t . Annotated [ t . TextIO , Args ( mode = \"r\" )] \"\"\"Equivalent to `open(filename, \"r\")`\"\"\" Write = t . Annotated [ t . TextIO , Args ( mode = \"w\" )] \"\"\"Equivalent to `open(filename, \"w\")`\"\"\" ReadWrite = t . Annotated [ t . TextIO , Args ( mode = \"r+\" )] \"\"\"Equivalent to `open(filename, \"r+\")`\"\"\" CreateWrite = t . Annotated [ t . TextIO , Args ( mode = \"x\" )] \"\"\"Equivalent to `open(filename, \"x\")`\"\"\" Append = t . Annotated [ t . TextIO , Args ( mode = \"a\" )] \"\"\"Equivalent to `open(filename, \"a\")`\"\"\" AppendRead = t . Annotated [ t . TextIO , Args ( mode = \"a+\" )] \"\"\"Equivalent to `open(filename, \"a+\")`\"\"\" BinaryRead = t . Annotated [ t . BinaryIO , Args ( \"rb\" )] \"\"\"Equivalent to `open(filename, \"rb\")`\"\"\" BinaryWrite = t . Annotated [ t . BinaryIO , Args ( \"wb\" )] \"\"\"Equivalent to `open(filename, \"wb\")`\"\"\" BinaryReadWrite = t . Annotated [ t . BinaryIO , Args ( \"rb+\" )] \"\"\"Equivalent to `open(filename, \"rb+\")`\"\"\" BinaryCreateWrite = t . Annotated [ t . BinaryIO , Args ( \"xb\" )] \"\"\"Equivalent to `open(filename, \"xb\")`\"\"\" BinaryAppend = t . Annotated [ t . BinaryIO , Args ( \"ab\" )] \"\"\"Equivalent to `open(filename, \"ab\")`\"\"\" BinaryAppendRead = t . Annotated [ t . BinaryIO , Args ( \"ab+\" )] \"\"\"Equivalent to `open(filename, \"ab+\")`\"\"\" Append = t . Annotated [ t . TextIO , Args ( mode = 'a' )] class-attribute instance-attribute \u00b6 Equivalent to open(filename, \"a\") AppendRead = t . Annotated [ t . TextIO , Args ( mode = 'a+' )] class-attribute instance-attribute \u00b6 Equivalent to open(filename, \"a+\") BinaryAppend = t . Annotated [ t . BinaryIO , Args ( 'ab' )] class-attribute instance-attribute \u00b6 Equivalent to open(filename, \"ab\") BinaryAppendRead = t . Annotated [ t . BinaryIO , Args ( 'ab+' )] class-attribute instance-attribute \u00b6 Equivalent to open(filename, \"ab+\") BinaryCreateWrite = t . Annotated [ t . BinaryIO , Args ( 'xb' )] class-attribute instance-attribute \u00b6 Equivalent to open(filename, \"xb\") BinaryRead = t . Annotated [ t . BinaryIO , Args ( 'rb' )] class-attribute instance-attribute \u00b6 Equivalent to open(filename, \"rb\") BinaryReadWrite = t . Annotated [ t . BinaryIO , Args ( 'rb+' )] class-attribute instance-attribute \u00b6 Equivalent to open(filename, \"rb+\") BinaryWrite = t . Annotated [ t . BinaryIO , Args ( 'wb' )] class-attribute instance-attribute \u00b6 Equivalent to open(filename, \"wb\") CreateWrite = t . Annotated [ t . TextIO , Args ( mode = 'x' )] class-attribute instance-attribute \u00b6 Equivalent to open(filename, \"x\") Read = t . Annotated [ t . TextIO , Args ( mode = 'r' )] class-attribute instance-attribute \u00b6 Equivalent to open(filename, \"r\") ReadWrite = t . Annotated [ t . TextIO , Args ( mode = 'r+' )] class-attribute instance-attribute \u00b6 Equivalent to open(filename, \"r+\") Write = t . Annotated [ t . TextIO , Args ( mode = 'w' )] class-attribute instance-attribute \u00b6 Equivalent to open(filename, \"w\") StdinFile \u00b6 Bases: Stream Read input from a file, or from a stdin if '-' is passed as the argument Source code in /home/runner/work/arc/arc/arc/types/file.py 153 154 155 156 157 158 159 160 161 162 163 class StdinFile ( Stream ): \"\"\"Read input from a file, or from a stdin if '-' is passed as the argument\"\"\" @classmethod def __convert__ ( cls , value : str , info : TypeInfo [ t . Any ]) -> \"t.IO[str]\" : try : return convert_type ( _info . resolved_type , value , _info ) except errors . ConversionError as e : raise errors . ConversionError ( value , f \"expected file or '-' to read from stdin\" ) from e","title":"types.file"},{"location":"reference/types/file/#typesfile","text":"","title":"types.file"},{"location":"reference/types/file/#arc.types.file.Stdin","text":"Read input from command line, or from stdin if - is passed as the argument","title":"Stdin"},{"location":"reference/types/file/#arc.types.file.File","text":"Bases: t . IO [ str ] , abc . ABC Obtains a handler to a file. Handles the access to the file, and gurantees that it is closed before exiting.","title":"File"},{"location":"reference/types/file/#arc.types.file.File--example","text":"@arc . command def command ( file : File . Read ): arc . print ( file . read ()) There are constants defined on File (like File.Read above) for all common actions ( Read , Write , Append , ReadWrite , etc...). View all of them below. If none of the pre-defiend constants match your needs, you can customize it with an Annotated type. @arc . command def command ( file : Annotated [ File , File . Args ( ... )]): arc . print ( file . read ()) File.Args 's call signature matches that of open (minus the filename), so all of the same properties apply File is Abstract and cannot be instantiated on it's own Source code in /home/runner/work/arc/arc/arc/types/file.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class File ( t . IO [ str ], abc . ABC ): \"\"\"Obtains a handler to a file. Handles the access to the file, and gurantees that it is closed before exiting. ## Example ```py @arc.command def command(file: File.Read): arc.print(file.read()) ``` There are constants defined on `File` (like `File.Read` above) for all common actions (`Read`, `Write`, `Append`, `ReadWrite`, etc...). View all of them below. If none of the pre-defiend constants match your needs, you can customize it with an `Annotated` type. ```py @arc.command def command(file: Annotated[File, File.Args(...)]): arc.print(file.read()) ``` `File.Args`'s call signature matches that of `open` (minus the filename), so all of the same properties apply `File` is Abstract and cannot be instantiated on it's own \"\"\" class Args ( TypeArg ): __slots__ = ( \"mode\" , \"buffering\" , \"encoding\" , \"errors\" , \"newline\" , \"closefd\" , \"opener\" , ) def __init__ ( self , mode : str = Default ( \"r\" ), buffering : int = Default ( - 1 ), encoding : t . Optional [ str ] = Default ( None ), errors : OpenErrors = Default ( None ), newline : OpenNewline = Default ( None ), closefd : bool = Default ( True ), opener : t . Optional [ t . Callable [ ... , t . Any ]] = Default ( None ), ): self . mode = mode self . buffering = buffering self . encoding = encoding self . errors = errors self . newline = newline self . closefd = closefd self . opener = opener Read = t . Annotated [ t . TextIO , Args ( mode = \"r\" )] \"\"\"Equivalent to `open(filename, \"r\")`\"\"\" Write = t . Annotated [ t . TextIO , Args ( mode = \"w\" )] \"\"\"Equivalent to `open(filename, \"w\")`\"\"\" ReadWrite = t . Annotated [ t . TextIO , Args ( mode = \"r+\" )] \"\"\"Equivalent to `open(filename, \"r+\")`\"\"\" CreateWrite = t . Annotated [ t . TextIO , Args ( mode = \"x\" )] \"\"\"Equivalent to `open(filename, \"x\")`\"\"\" Append = t . Annotated [ t . TextIO , Args ( mode = \"a\" )] \"\"\"Equivalent to `open(filename, \"a\")`\"\"\" AppendRead = t . Annotated [ t . TextIO , Args ( mode = \"a+\" )] \"\"\"Equivalent to `open(filename, \"a+\")`\"\"\" BinaryRead = t . Annotated [ t . BinaryIO , Args ( \"rb\" )] \"\"\"Equivalent to `open(filename, \"rb\")`\"\"\" BinaryWrite = t . Annotated [ t . BinaryIO , Args ( \"wb\" )] \"\"\"Equivalent to `open(filename, \"wb\")`\"\"\" BinaryReadWrite = t . Annotated [ t . BinaryIO , Args ( \"rb+\" )] \"\"\"Equivalent to `open(filename, \"rb+\")`\"\"\" BinaryCreateWrite = t . Annotated [ t . BinaryIO , Args ( \"xb\" )] \"\"\"Equivalent to `open(filename, \"xb\")`\"\"\" BinaryAppend = t . Annotated [ t . BinaryIO , Args ( \"ab\" )] \"\"\"Equivalent to `open(filename, \"ab\")`\"\"\" BinaryAppendRead = t . Annotated [ t . BinaryIO , Args ( \"ab+\" )] \"\"\"Equivalent to `open(filename, \"ab+\")`\"\"\"","title":"Example"},{"location":"reference/types/file/#arc.types.file.File.Append","text":"Equivalent to open(filename, \"a\")","title":"Append"},{"location":"reference/types/file/#arc.types.file.File.AppendRead","text":"Equivalent to open(filename, \"a+\")","title":"AppendRead"},{"location":"reference/types/file/#arc.types.file.File.BinaryAppend","text":"Equivalent to open(filename, \"ab\")","title":"BinaryAppend"},{"location":"reference/types/file/#arc.types.file.File.BinaryAppendRead","text":"Equivalent to open(filename, \"ab+\")","title":"BinaryAppendRead"},{"location":"reference/types/file/#arc.types.file.File.BinaryCreateWrite","text":"Equivalent to open(filename, \"xb\")","title":"BinaryCreateWrite"},{"location":"reference/types/file/#arc.types.file.File.BinaryRead","text":"Equivalent to open(filename, \"rb\")","title":"BinaryRead"},{"location":"reference/types/file/#arc.types.file.File.BinaryReadWrite","text":"Equivalent to open(filename, \"rb+\")","title":"BinaryReadWrite"},{"location":"reference/types/file/#arc.types.file.File.BinaryWrite","text":"Equivalent to open(filename, \"wb\")","title":"BinaryWrite"},{"location":"reference/types/file/#arc.types.file.File.CreateWrite","text":"Equivalent to open(filename, \"x\")","title":"CreateWrite"},{"location":"reference/types/file/#arc.types.file.File.Read","text":"Equivalent to open(filename, \"r\")","title":"Read"},{"location":"reference/types/file/#arc.types.file.File.ReadWrite","text":"Equivalent to open(filename, \"r+\")","title":"ReadWrite"},{"location":"reference/types/file/#arc.types.file.File.Write","text":"Equivalent to open(filename, \"w\")","title":"Write"},{"location":"reference/types/file/#arc.types.file.StdinFile","text":"Bases: Stream Read input from a file, or from a stdin if '-' is passed as the argument Source code in /home/runner/work/arc/arc/arc/types/file.py 153 154 155 156 157 158 159 160 161 162 163 class StdinFile ( Stream ): \"\"\"Read input from a file, or from a stdin if '-' is passed as the argument\"\"\" @classmethod def __convert__ ( cls , value : str , info : TypeInfo [ t . Any ]) -> \"t.IO[str]\" : try : return convert_type ( _info . resolved_type , value , _info ) except errors . ConversionError as e : raise errors . ConversionError ( value , f \"expected file or '-' to read from stdin\" ) from e","title":"StdinFile"},{"location":"reference/types/network/","text":"types.network \u00b6","title":"types.network"},{"location":"reference/types/network/#typesnetwork","text":"","title":"types.network"},{"location":"reference/types/numbers/","text":"types.numbers \u00b6","title":"types.numbers"},{"location":"reference/types/numbers/#typesnumbers","text":"","title":"types.numbers"},{"location":"reference/types/path/","text":"types.path \u00b6","title":"types.path"},{"location":"reference/types/path/#typespath","text":"","title":"types.path"},{"location":"reference/types/semver/","text":"types.semver \u00b6 SemVer \u00b6 Read-only representation a semantically versioned string. Reference: https://semver.org/spec/v2.0.0.html Source code in /home/runner/work/arc/arc/arc/types/semver.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 class SemVer : \"\"\"Read-only representation a semantically versioned string. Reference: https://semver.org/spec/v2.0.0.html\"\"\" _prerelease_prefix = \"-\" _build_prefix = \"+\" _metadata_sep = \".\" def __init__ ( self , major : int = 0 , minor : int = 0 , patch : int = 0 , prerelease : t . Optional [ str ] = None , build : t . Optional [ str ] = None , ): self . _major : int = major self . _minor : int = minor self . _patch : int = patch self . _prerelease : tuple [ str , ... ] = ( tuple ( prerelease . split ( self . _metadata_sep )) if prerelease else tuple () ) self . _build : tuple [ str , ... ] = ( tuple ( build . split ( self . _metadata_sep )) if build else tuple () ) def __str__ ( self ) -> str : string = f \" { self . major } . { self . minor } . { self . patch } \" if self . prerelease : string += ( f \" { self . _prerelease_prefix }{ self . _metadata_sep . join ( self . prerelease ) } \" ) if self . build : string += f \" { self . _build_prefix }{ self . _metadata_sep . join ( self . build ) } \" return string def __repr__ ( self ) -> str : return f \"SemVer( { str ( self ) !r} )\" def __iter__ ( self ) -> t . Iterator [ t . Any ]: yield from ( a for a in self . tuple () if a ) @property def major ( self ) -> int : return self . _major @property def minor ( self ) -> int : return self . _minor @property def patch ( self ) -> int : return self . _patch @property def prerelease ( self ) -> tuple [ str , ... ]: return self . _prerelease @property def build ( self ) -> tuple [ str , ... ]: return self . _build # Comparison Operators -------------------------------------------------------------------- def compare ( self , other : object ) -> CompareReturn : \"\"\"Compares `self` with `other` Args: other (SemVer): the second version for comparison Returns: at.CompareReturn: is negative if self < other, zero if self == other and strictly positive if self > other \"\"\" if not isinstance ( other , SemVer ): return NotImplemented tup1 , tup2 = self . tuple (), other . tuple () # Their version numbers are different, # no need to check the prerelease data comp = cmp ( tup1 [: 3 ], tup2 [: 3 ]) if comp : return comp # Their version numbers are the same # and we need to compare the prerelease data pr1 , pr2 = self . prerelease , other . prerelease # No prerelease data for one or both versions if not comp and not pr1 and not pr2 : return comp elif not pr1 : return 1 elif not pr2 : return - 1 pr1 = tuple ( int ( p ) if p . isnumeric () else p for p in pr1 ) # type: ignore pr2 = tuple ( int ( p ) if p . isnumeric () else p for p in pr2 ) # type: ignore for part1 , part2 in zip ( pr1 , pr2 ): comp = self . _cmp_prerelease_tag ( part1 , part2 ) if comp : return comp return cmp ( len ( pr1 ), len ( pr2 )) def _cmp_prerelease_tag ( self , a : t . Union [ str , int ], b : t . Union [ str , int ] ) -> CompareReturn : \"\"\"Compares two prerelease tags given the following conditions: - Identifiers consisting of only digits are compared numerically. - Identifiers with letters or hyphens are compared lexically in ASCII sort order. - Numeric identifiers always have lower precedence than non-numeric identifiers. \"\"\" # Compared numerically if isinstance ( a , int ) and isinstance ( b , int ): return cmp ( a , b ) # Numeric identifiers have lower priority elif isinstance ( a , int ): return - 1 elif isinstance ( b , int ): return 1 # Compared lexically return cmp ( a , b ) def __eq__ ( self , other : object ) -> bool : return self . compare ( other ) == 0 def __ne__ ( self , other : object ) -> bool : return self . compare ( other ) != 0 def __lt__ ( self , other : object ) -> bool : return self . compare ( other ) == - 1 def __le__ ( self , other : object ) -> bool : return self . compare ( other ) <= 0 def __gt__ ( self , other : object ) -> bool : return self . compare ( other ) == 1 def __ge__ ( self , other : object ) -> bool : return self . compare ( other ) >= 0 # Utility Functions ----------------------------------------------------------------------- def tuple ( self ) -> tuple [ int , int , int , tuple [ str , ... ], tuple [ str , ... ]]: return ( self . major , self . minor , self . patch , self . prerelease , self . build ) def dict ( self ) -> dict [ str , t . Any ]: return { \"major\" : self . major , \"minor\" : self . minor , \"patch\" : self . patch , \"prerelease\" : self . prerelease , \"build\" : self . build , } def bump_major ( self ) -> SemVer : cls = type ( self ) return cls ( self . major + 1 ) def bump_minor ( self ) -> SemVer : cls = type ( self ) return cls ( self . major , self . minor + 1 ) def bump_patch ( self ) -> SemVer : cls = type ( self ) return cls ( self . major , self . minor , self . patch + 1 ) # Conversion Utilities -------------------------------------------------------------------- @classmethod def parse ( cls , string : str ) -> SemVer : match = SEMVAR_REGEX . match ( string ) if not match : raise ValueError ( \"Invalid semantic version string\" ) groups = match . groupdict () return cls ( major = int ( groups [ \"major\" ]), minor = int ( groups [ \"minor\" ]), patch = int ( groups [ \"patch\" ]), prerelease = groups [ \"prerelease\" ], build = groups [ \"build\" ], ) @classmethod def __convert__ ( cls , value : str ) -> SemVer : try : return cls . parse ( value ) except ValueError as e : raise errors . ConversionError ( value , str ( e )) from e compare ( other ) \u00b6 Compares self with other Parameters: Name Type Description Default other SemVer the second version for comparison required Returns: Type Description CompareReturn at.CompareReturn: is negative if self < other, zero if self == other and strictly positive if self > other Source code in /home/runner/work/arc/arc/arc/types/semver.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def compare ( self , other : object ) -> CompareReturn : \"\"\"Compares `self` with `other` Args: other (SemVer): the second version for comparison Returns: at.CompareReturn: is negative if self < other, zero if self == other and strictly positive if self > other \"\"\" if not isinstance ( other , SemVer ): return NotImplemented tup1 , tup2 = self . tuple (), other . tuple () # Their version numbers are different, # no need to check the prerelease data comp = cmp ( tup1 [: 3 ], tup2 [: 3 ]) if comp : return comp # Their version numbers are the same # and we need to compare the prerelease data pr1 , pr2 = self . prerelease , other . prerelease # No prerelease data for one or both versions if not comp and not pr1 and not pr2 : return comp elif not pr1 : return 1 elif not pr2 : return - 1 pr1 = tuple ( int ( p ) if p . isnumeric () else p for p in pr1 ) # type: ignore pr2 = tuple ( int ( p ) if p . isnumeric () else p for p in pr2 ) # type: ignore for part1 , part2 in zip ( pr1 , pr2 ): comp = self . _cmp_prerelease_tag ( part1 , part2 ) if comp : return comp return cmp ( len ( pr1 ), len ( pr2 )) cmp ( a , b ) \u00b6 Compare two values Parameters: Name Type Description Default a Any First value required b Any Second value required Returns: Type Description CompareReturn a < b => -1 CompareReturn a == b => 0 CompareReturn a > b => 1 Source code in /home/runner/work/arc/arc/arc/types/semver.py 11 12 13 14 15 16 17 18 19 20 21 22 23 def cmp ( a : t . Any , b : t . Any ) -> CompareReturn : \"\"\"Compare two values Args: a (Any): First value b (Any): Second value Returns: - `a < b => -1` - `a == b => 0` - `a > b => 1` \"\"\" return ( a > b ) - ( a < b )","title":"types.semver"},{"location":"reference/types/semver/#typessemver","text":"","title":"types.semver"},{"location":"reference/types/semver/#arc.types.semver.SemVer","text":"Read-only representation a semantically versioned string. Reference: https://semver.org/spec/v2.0.0.html Source code in /home/runner/work/arc/arc/arc/types/semver.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 class SemVer : \"\"\"Read-only representation a semantically versioned string. Reference: https://semver.org/spec/v2.0.0.html\"\"\" _prerelease_prefix = \"-\" _build_prefix = \"+\" _metadata_sep = \".\" def __init__ ( self , major : int = 0 , minor : int = 0 , patch : int = 0 , prerelease : t . Optional [ str ] = None , build : t . Optional [ str ] = None , ): self . _major : int = major self . _minor : int = minor self . _patch : int = patch self . _prerelease : tuple [ str , ... ] = ( tuple ( prerelease . split ( self . _metadata_sep )) if prerelease else tuple () ) self . _build : tuple [ str , ... ] = ( tuple ( build . split ( self . _metadata_sep )) if build else tuple () ) def __str__ ( self ) -> str : string = f \" { self . major } . { self . minor } . { self . patch } \" if self . prerelease : string += ( f \" { self . _prerelease_prefix }{ self . _metadata_sep . join ( self . prerelease ) } \" ) if self . build : string += f \" { self . _build_prefix }{ self . _metadata_sep . join ( self . build ) } \" return string def __repr__ ( self ) -> str : return f \"SemVer( { str ( self ) !r} )\" def __iter__ ( self ) -> t . Iterator [ t . Any ]: yield from ( a for a in self . tuple () if a ) @property def major ( self ) -> int : return self . _major @property def minor ( self ) -> int : return self . _minor @property def patch ( self ) -> int : return self . _patch @property def prerelease ( self ) -> tuple [ str , ... ]: return self . _prerelease @property def build ( self ) -> tuple [ str , ... ]: return self . _build # Comparison Operators -------------------------------------------------------------------- def compare ( self , other : object ) -> CompareReturn : \"\"\"Compares `self` with `other` Args: other (SemVer): the second version for comparison Returns: at.CompareReturn: is negative if self < other, zero if self == other and strictly positive if self > other \"\"\" if not isinstance ( other , SemVer ): return NotImplemented tup1 , tup2 = self . tuple (), other . tuple () # Their version numbers are different, # no need to check the prerelease data comp = cmp ( tup1 [: 3 ], tup2 [: 3 ]) if comp : return comp # Their version numbers are the same # and we need to compare the prerelease data pr1 , pr2 = self . prerelease , other . prerelease # No prerelease data for one or both versions if not comp and not pr1 and not pr2 : return comp elif not pr1 : return 1 elif not pr2 : return - 1 pr1 = tuple ( int ( p ) if p . isnumeric () else p for p in pr1 ) # type: ignore pr2 = tuple ( int ( p ) if p . isnumeric () else p for p in pr2 ) # type: ignore for part1 , part2 in zip ( pr1 , pr2 ): comp = self . _cmp_prerelease_tag ( part1 , part2 ) if comp : return comp return cmp ( len ( pr1 ), len ( pr2 )) def _cmp_prerelease_tag ( self , a : t . Union [ str , int ], b : t . Union [ str , int ] ) -> CompareReturn : \"\"\"Compares two prerelease tags given the following conditions: - Identifiers consisting of only digits are compared numerically. - Identifiers with letters or hyphens are compared lexically in ASCII sort order. - Numeric identifiers always have lower precedence than non-numeric identifiers. \"\"\" # Compared numerically if isinstance ( a , int ) and isinstance ( b , int ): return cmp ( a , b ) # Numeric identifiers have lower priority elif isinstance ( a , int ): return - 1 elif isinstance ( b , int ): return 1 # Compared lexically return cmp ( a , b ) def __eq__ ( self , other : object ) -> bool : return self . compare ( other ) == 0 def __ne__ ( self , other : object ) -> bool : return self . compare ( other ) != 0 def __lt__ ( self , other : object ) -> bool : return self . compare ( other ) == - 1 def __le__ ( self , other : object ) -> bool : return self . compare ( other ) <= 0 def __gt__ ( self , other : object ) -> bool : return self . compare ( other ) == 1 def __ge__ ( self , other : object ) -> bool : return self . compare ( other ) >= 0 # Utility Functions ----------------------------------------------------------------------- def tuple ( self ) -> tuple [ int , int , int , tuple [ str , ... ], tuple [ str , ... ]]: return ( self . major , self . minor , self . patch , self . prerelease , self . build ) def dict ( self ) -> dict [ str , t . Any ]: return { \"major\" : self . major , \"minor\" : self . minor , \"patch\" : self . patch , \"prerelease\" : self . prerelease , \"build\" : self . build , } def bump_major ( self ) -> SemVer : cls = type ( self ) return cls ( self . major + 1 ) def bump_minor ( self ) -> SemVer : cls = type ( self ) return cls ( self . major , self . minor + 1 ) def bump_patch ( self ) -> SemVer : cls = type ( self ) return cls ( self . major , self . minor , self . patch + 1 ) # Conversion Utilities -------------------------------------------------------------------- @classmethod def parse ( cls , string : str ) -> SemVer : match = SEMVAR_REGEX . match ( string ) if not match : raise ValueError ( \"Invalid semantic version string\" ) groups = match . groupdict () return cls ( major = int ( groups [ \"major\" ]), minor = int ( groups [ \"minor\" ]), patch = int ( groups [ \"patch\" ]), prerelease = groups [ \"prerelease\" ], build = groups [ \"build\" ], ) @classmethod def __convert__ ( cls , value : str ) -> SemVer : try : return cls . parse ( value ) except ValueError as e : raise errors . ConversionError ( value , str ( e )) from e","title":"SemVer"},{"location":"reference/types/semver/#arc.types.semver.SemVer.compare","text":"Compares self with other Parameters: Name Type Description Default other SemVer the second version for comparison required Returns: Type Description CompareReturn at.CompareReturn: is negative if self < other, zero if self == other and strictly positive if self > other Source code in /home/runner/work/arc/arc/arc/types/semver.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def compare ( self , other : object ) -> CompareReturn : \"\"\"Compares `self` with `other` Args: other (SemVer): the second version for comparison Returns: at.CompareReturn: is negative if self < other, zero if self == other and strictly positive if self > other \"\"\" if not isinstance ( other , SemVer ): return NotImplemented tup1 , tup2 = self . tuple (), other . tuple () # Their version numbers are different, # no need to check the prerelease data comp = cmp ( tup1 [: 3 ], tup2 [: 3 ]) if comp : return comp # Their version numbers are the same # and we need to compare the prerelease data pr1 , pr2 = self . prerelease , other . prerelease # No prerelease data for one or both versions if not comp and not pr1 and not pr2 : return comp elif not pr1 : return 1 elif not pr2 : return - 1 pr1 = tuple ( int ( p ) if p . isnumeric () else p for p in pr1 ) # type: ignore pr2 = tuple ( int ( p ) if p . isnumeric () else p for p in pr2 ) # type: ignore for part1 , part2 in zip ( pr1 , pr2 ): comp = self . _cmp_prerelease_tag ( part1 , part2 ) if comp : return comp return cmp ( len ( pr1 ), len ( pr2 ))","title":"compare()"},{"location":"reference/types/semver/#arc.types.semver.cmp","text":"Compare two values Parameters: Name Type Description Default a Any First value required b Any Second value required Returns: Type Description CompareReturn a < b => -1 CompareReturn a == b => 0 CompareReturn a > b => 1 Source code in /home/runner/work/arc/arc/arc/types/semver.py 11 12 13 14 15 16 17 18 19 20 21 22 23 def cmp ( a : t . Any , b : t . Any ) -> CompareReturn : \"\"\"Compare two values Args: a (Any): First value b (Any): Second value Returns: - `a < b => -1` - `a == b => 0` - `a > b => 1` \"\"\" return ( a > b ) - ( a < b )","title":"cmp()"},{"location":"reference/types/state/","text":"types.state \u00b6 State \u00b6 Bases: collections . UserDict [ str , t . Any ] State object Source code in /home/runner/work/arc/arc/arc/types/state.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class State ( collections . UserDict [ str , t . Any ]): \"\"\"State object\"\"\" def __repr__ ( self ) -> str : values = \", \" . join ( f \" { key } = { value !r} \" for key , value in self . data . items ()) return f \" { self . __class__ . __name__ } ( { values } )\" def __getattr__ ( self , attr : str ) -> t . Any : try : return self . data [ attr ] except KeyError as e : raise AttributeError ( str ( e )) from e def __setattr__ ( self , name : str , value : t . Any ) -> None : if name == \"data\" : super () . __setattr__ ( name , value ) else : self . data [ name ] = value @classmethod def __depends__ ( cls , ctx : Context ) -> State : state = cls () state . data = ctx [ \"arc.state\" ] return state","title":"types.state"},{"location":"reference/types/state/#typesstate","text":"","title":"types.state"},{"location":"reference/types/state/#arc.types.state.State","text":"Bases: collections . UserDict [ str , t . Any ] State object Source code in /home/runner/work/arc/arc/arc/types/state.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class State ( collections . UserDict [ str , t . Any ]): \"\"\"State object\"\"\" def __repr__ ( self ) -> str : values = \", \" . join ( f \" { key } = { value !r} \" for key , value in self . data . items ()) return f \" { self . __class__ . __name__ } ( { values } )\" def __getattr__ ( self , attr : str ) -> t . Any : try : return self . data [ attr ] except KeyError as e : raise AttributeError ( str ( e )) from e def __setattr__ ( self , name : str , value : t . Any ) -> None : if name == \"data\" : super () . __setattr__ ( name , value ) else : self . data [ name ] = value @classmethod def __depends__ ( cls , ctx : Context ) -> State : state = cls () state . data = ctx [ \"arc.state\" ] return state","title":"State"},{"location":"reference/types/strings/","text":"types.strings \u00b6 Char = t . Annotated [ str , Len ( 1 )] module-attribute \u00b6 String than can only be length 1 Email = t . Annotated [ str , Matches ( email_regex , message = 'is not a valid email address' )] module-attribute \u00b6 String type with email validation Password \u00b6 Bases: UserString For Secret Strings. When prompted for input, the user's input will not be echoed to the screen. Additionally, the string will be obscured when printed. For example: from typing import Annotated import arc from arc.types import Password @arc . command def command ( password : Password ): print ( password ) # This would be obscured print ( password . data ) # This would be the actual password Source code in /home/runner/work/arc/arc/arc/types/strings.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Password ( UserString ): \"\"\"For Secret Strings. When prompted for input, the user's input will not be echoed to the screen. Additionally, the string will be obscured when printed. For example: ```py from typing import Annotated import arc from arc.types import Password @arc.command def command(password: Password): print(password) # This would be obscured print(password.data) # This would be the actual password ``` \"\"\" def __str__ ( self ) -> str : return \"*\" * len ( self ) def __repr__ ( self ) -> str : return \"Password()\" @classmethod def __prompt__ ( cls , param : Param [ str ], ctx : Context ) -> str : return input_prompt ( param , ctx , echo = False ) @classmethod def __convert__ ( cls , value : str ) -> Password : return cls ( value )","title":"types.strings"},{"location":"reference/types/strings/#typesstrings","text":"","title":"types.strings"},{"location":"reference/types/strings/#arc.types.strings.Char","text":"String than can only be length 1","title":"Char"},{"location":"reference/types/strings/#arc.types.strings.Email","text":"String type with email validation","title":"Email"},{"location":"reference/types/strings/#arc.types.strings.Password","text":"Bases: UserString For Secret Strings. When prompted for input, the user's input will not be echoed to the screen. Additionally, the string will be obscured when printed. For example: from typing import Annotated import arc from arc.types import Password @arc . command def command ( password : Password ): print ( password ) # This would be obscured print ( password . data ) # This would be the actual password Source code in /home/runner/work/arc/arc/arc/types/strings.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Password ( UserString ): \"\"\"For Secret Strings. When prompted for input, the user's input will not be echoed to the screen. Additionally, the string will be obscured when printed. For example: ```py from typing import Annotated import arc from arc.types import Password @arc.command def command(password: Password): print(password) # This would be obscured print(password.data) # This would be the actual password ``` \"\"\" def __str__ ( self ) -> str : return \"*\" * len ( self ) def __repr__ ( self ) -> str : return \"Password()\" @classmethod def __prompt__ ( cls , param : Param [ str ], ctx : Context ) -> str : return input_prompt ( param , ctx , echo = False ) @classmethod def __convert__ ( cls , value : str ) -> Password : return cls ( value )","title":"Password"},{"location":"reference/types/type_arg/","text":"types.type_arg \u00b6 TypeArg \u00b6 A type argument that can be used to annotate a type. This is used to provide additional information neccessary to convert a type. Source code in /home/runner/work/arc/arc/arc/types/type_arg.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class TypeArg : \"\"\"A type argument that can be used to annotate a type. This is used to provide additional information neccessary to convert a type.\"\"\" __slots__ : tuple [ str , ... ] def __repr__ ( self ) -> str : values = \", \" . join ( [ f \" { member } = { repr ( getattr ( self , member )) } \" for member in self . __slots__ ] ) return f \" { type ( self ) . __name__ } ( { values } )\" def __setattr__ ( self , __name : str , __value : t . Any ) -> None : raise TypeError ( f \" { type ( self ) } is readonly\" ) def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , TypeArg ): return NotImplemented return all ( getattr ( self , attr ) == getattr ( other , attr ) for attr in self . __slots__ ) def __iter__ ( self ) -> t . Iterator [ t . Tuple [ str , t . Any ]]: for slot in self . __slots__ : yield slot , getattr ( self , slot ) def __or__ ( self , other : TypeArg ) -> TypeArg : merged : dict [ str , t . Any ] = {} for ( attr , value ), ( _ , other_value ) in zip ( self , other ): if isdefault ( other_value ): merged [ attr ] = value else : merged [ attr ] = other_value return type ( self )( ** merged ) def __hash__ ( self ) -> int : return id ( self ) def __init_subclass__ ( cls ) -> None : init : t . Callable [ ... , None ] = getattr ( cls , \"__init__\" ) setattr : t . Callable [ ... , None ] = cls . __setattr__ def __init__ ( self : object , * args : t . Any , ** kwargs : t . Any ) -> None : cls . __setattr__ = object . __setattr__ # type: ignore init ( self , * args , ** kwargs ) cls . __setattr__ = setattr # type: ignore cls . __init__ = __init__ # type: ignore def dict ( self , unwrap_defaults : bool = True ) -> dict [ str , t . Any ]: return { attr : unwrap ( getattr ( self , attr )) if unwrap_defaults else getattr ( self , attr ) for attr in self . __slots__ } @staticmethod def ensure ( arg : T | None , name : str ) -> T : if not arg : raise errors . TypeArgError ( f \" { name } requires a type argument\" ) return arg","title":"types.type_arg"},{"location":"reference/types/type_arg/#typestype_arg","text":"","title":"types.type_arg"},{"location":"reference/types/type_arg/#arc.types.type_arg.TypeArg","text":"A type argument that can be used to annotate a type. This is used to provide additional information neccessary to convert a type. Source code in /home/runner/work/arc/arc/arc/types/type_arg.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class TypeArg : \"\"\"A type argument that can be used to annotate a type. This is used to provide additional information neccessary to convert a type.\"\"\" __slots__ : tuple [ str , ... ] def __repr__ ( self ) -> str : values = \", \" . join ( [ f \" { member } = { repr ( getattr ( self , member )) } \" for member in self . __slots__ ] ) return f \" { type ( self ) . __name__ } ( { values } )\" def __setattr__ ( self , __name : str , __value : t . Any ) -> None : raise TypeError ( f \" { type ( self ) } is readonly\" ) def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , TypeArg ): return NotImplemented return all ( getattr ( self , attr ) == getattr ( other , attr ) for attr in self . __slots__ ) def __iter__ ( self ) -> t . Iterator [ t . Tuple [ str , t . Any ]]: for slot in self . __slots__ : yield slot , getattr ( self , slot ) def __or__ ( self , other : TypeArg ) -> TypeArg : merged : dict [ str , t . Any ] = {} for ( attr , value ), ( _ , other_value ) in zip ( self , other ): if isdefault ( other_value ): merged [ attr ] = value else : merged [ attr ] = other_value return type ( self )( ** merged ) def __hash__ ( self ) -> int : return id ( self ) def __init_subclass__ ( cls ) -> None : init : t . Callable [ ... , None ] = getattr ( cls , \"__init__\" ) setattr : t . Callable [ ... , None ] = cls . __setattr__ def __init__ ( self : object , * args : t . Any , ** kwargs : t . Any ) -> None : cls . __setattr__ = object . __setattr__ # type: ignore init ( self , * args , ** kwargs ) cls . __setattr__ = setattr # type: ignore cls . __init__ = __init__ # type: ignore def dict ( self , unwrap_defaults : bool = True ) -> dict [ str , t . Any ]: return { attr : unwrap ( getattr ( self , attr )) if unwrap_defaults else getattr ( self , attr ) for attr in self . __slots__ } @staticmethod def ensure ( arg : T | None , name : str ) -> T : if not arg : raise errors . TypeArgError ( f \" { name } requires a type argument\" ) return arg","title":"TypeArg"},{"location":"reference/types/type_info/","text":"types.type_info \u00b6 TypeInfo \u00b6 Bases: t . Generic [ T ] Source code in /home/runner/work/arc/arc/arc/types/type_info.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class TypeInfo ( t . Generic [ T ]): def __init__ ( self , original_type : at . Annotation , origin : type [ T ], sub_types : tuple [ TypeInfo [ t . Any ], ... ], annotations : tuple [ t . Any , ... ], name : str | None = None , ): self . original_type = original_type self . origin : t . Any = origin self . sub_types = sub_types self . annotations = annotations self . name = ( name or getattr ( self . origin , \"name\" , None ) or getattr ( self . origin , \"__name__\" , None ) or str ( self . origin ) ) @cached_property def type_arg ( self ) -> TypeArg | None : args = ( a for a in self . annotations if isinstance ( a , TypeArg )) try : curr = next ( args ) except StopIteration : return None for arg in args : curr |= arg return curr @cached_property def middleware ( self ) -> list [ at . TypeMiddleware ]: return [ a for a in self . annotations if callable ( a )] @cached_property def resolved_type ( self ) -> type [ at . TypeProtocol ]: return Alias . resolve ( self . origin ) @property def is_union_type ( self ) -> bool : \"\"\"The type is `Union[T...]`\"\"\" return self . origin in ( t . Union , types . UnionType ) @property def is_optional_type ( self ) -> bool : \"\"\"The type is `Optional[T]`\"\"\" return ( self . origin in ( t . Union , types . UnionType ) and len ( self . sub_types ) == 2 and self . sub_types [ - 1 ] . original_type is type ( None ) ) @property def is_collection_type ( self ) -> bool : return self . origin in COLLECTION_TYPES @classmethod def analyze ( cls , annotation : at . Annotation ) -> TypeInfo [ T ]: \"\"\"Create a `TypeInfo` object based on a type annotation\"\"\" original_type = annotation origin = t . get_origin ( annotation ) or annotation annotated_args : tuple [ t . Any , ... ] = tuple () if origin is t . Annotated : args = t . get_args ( annotation ) annotation = args [ 0 ] origin = t . get_origin ( annotation ) or annotation annotated_args = args [ 1 :] sub_types = tuple ( cls . analyze ( arg ) for arg in t . get_args ( annotation )) return cls ( original_type = original_type , origin = origin , # type: ignore sub_types = sub_types , annotations = annotated_args , ) is_optional_type : bool property \u00b6 The type is Optional[T] is_union_type : bool property \u00b6 The type is Union[T...] analyze ( annotation ) classmethod \u00b6 Create a TypeInfo object based on a type annotation Source code in /home/runner/work/arc/arc/arc/types/type_info.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @classmethod def analyze ( cls , annotation : at . Annotation ) -> TypeInfo [ T ]: \"\"\"Create a `TypeInfo` object based on a type annotation\"\"\" original_type = annotation origin = t . get_origin ( annotation ) or annotation annotated_args : tuple [ t . Any , ... ] = tuple () if origin is t . Annotated : args = t . get_args ( annotation ) annotation = args [ 0 ] origin = t . get_origin ( annotation ) or annotation annotated_args = args [ 1 :] sub_types = tuple ( cls . analyze ( arg ) for arg in t . get_args ( annotation )) return cls ( original_type = original_type , origin = origin , # type: ignore sub_types = sub_types , annotations = annotated_args , )","title":"types.type_info"},{"location":"reference/types/type_info/#typestype_info","text":"","title":"types.type_info"},{"location":"reference/types/type_info/#arc.types.type_info.TypeInfo","text":"Bases: t . Generic [ T ] Source code in /home/runner/work/arc/arc/arc/types/type_info.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class TypeInfo ( t . Generic [ T ]): def __init__ ( self , original_type : at . Annotation , origin : type [ T ], sub_types : tuple [ TypeInfo [ t . Any ], ... ], annotations : tuple [ t . Any , ... ], name : str | None = None , ): self . original_type = original_type self . origin : t . Any = origin self . sub_types = sub_types self . annotations = annotations self . name = ( name or getattr ( self . origin , \"name\" , None ) or getattr ( self . origin , \"__name__\" , None ) or str ( self . origin ) ) @cached_property def type_arg ( self ) -> TypeArg | None : args = ( a for a in self . annotations if isinstance ( a , TypeArg )) try : curr = next ( args ) except StopIteration : return None for arg in args : curr |= arg return curr @cached_property def middleware ( self ) -> list [ at . TypeMiddleware ]: return [ a for a in self . annotations if callable ( a )] @cached_property def resolved_type ( self ) -> type [ at . TypeProtocol ]: return Alias . resolve ( self . origin ) @property def is_union_type ( self ) -> bool : \"\"\"The type is `Union[T...]`\"\"\" return self . origin in ( t . Union , types . UnionType ) @property def is_optional_type ( self ) -> bool : \"\"\"The type is `Optional[T]`\"\"\" return ( self . origin in ( t . Union , types . UnionType ) and len ( self . sub_types ) == 2 and self . sub_types [ - 1 ] . original_type is type ( None ) ) @property def is_collection_type ( self ) -> bool : return self . origin in COLLECTION_TYPES @classmethod def analyze ( cls , annotation : at . Annotation ) -> TypeInfo [ T ]: \"\"\"Create a `TypeInfo` object based on a type annotation\"\"\" original_type = annotation origin = t . get_origin ( annotation ) or annotation annotated_args : tuple [ t . Any , ... ] = tuple () if origin is t . Annotated : args = t . get_args ( annotation ) annotation = args [ 0 ] origin = t . get_origin ( annotation ) or annotation annotated_args = args [ 1 :] sub_types = tuple ( cls . analyze ( arg ) for arg in t . get_args ( annotation )) return cls ( original_type = original_type , origin = origin , # type: ignore sub_types = sub_types , annotations = annotated_args , )","title":"TypeInfo"},{"location":"reference/types/type_info/#arc.types.type_info.TypeInfo.is_optional_type","text":"The type is Optional[T]","title":"is_optional_type"},{"location":"reference/types/type_info/#arc.types.type_info.TypeInfo.is_union_type","text":"The type is Union[T...]","title":"is_union_type"},{"location":"reference/types/type_info/#arc.types.type_info.TypeInfo.analyze","text":"Create a TypeInfo object based on a type annotation Source code in /home/runner/work/arc/arc/arc/types/type_info.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @classmethod def analyze ( cls , annotation : at . Annotation ) -> TypeInfo [ T ]: \"\"\"Create a `TypeInfo` object based on a type annotation\"\"\" original_type = annotation origin = t . get_origin ( annotation ) or annotation annotated_args : tuple [ t . Any , ... ] = tuple () if origin is t . Annotated : args = t . get_args ( annotation ) annotation = args [ 0 ] origin = t . get_origin ( annotation ) or annotation annotated_args = args [ 1 :] sub_types = tuple ( cls . analyze ( arg ) for arg in t . get_args ( annotation )) return cls ( original_type = original_type , origin = origin , # type: ignore sub_types = sub_types , annotations = annotated_args , )","title":"analyze()"},{"location":"reference/types/users/","text":"types.users \u00b6","title":"types.users"},{"location":"reference/types/users/#typesusers","text":"","title":"types.users"},{"location":"reference/types/middleware/observers/","text":"types.middleware.observers \u00b6 Log \u00b6 Type middleware to log the value provided Example \u00b6 import typing as t import arc from arc.types.middleware import Log arc . configure ( environment = \"development\" ) @arc . command def command ( val : t . Annotated [ int , Log ()], flag_name : t . Annotated [ bool , Log ()], ): arc . print ( \"hello there!\" ) command () Source code in /home/runner/work/arc/arc/arc/types/middleware/observers.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class Log : \"\"\"Type middleware to log the value provided ## Example ```py import typing as t import arc from arc.types.middleware import Log arc.configure(environment=\"development\") @arc.command def command( val: t.Annotated[int, Log()], flag_name: t.Annotated[bool, Log()], ): arc.print(\"hello there!\") command() ``` \"\"\" def __init__ ( self , level : int = logging . INFO , name_kind : t . Literal [ \"arg\" , \"param\" , \"cli\" ] = \"arg\" , ) -> None : self . level = level self . name_kind = name_kind def __call__ ( self , value : t . Any , ctx : Context | None = None , param : Param [ t . Any ] | None = None , ) -> t . Any : if param and ctx : names = { \"arg\" : param . argument_name , \"param\" : param . param_name , \"cli\" : param . cli_name , } origin = ctx . get_origin ( param . argument_name , \"default\" ) name = names . get ( self . name_kind , param . argument_name ) ctx . logger . log ( self . level , f \" { name } = { value } ( { origin } )\" ) return value","title":"types.middleware.observers"},{"location":"reference/types/middleware/observers/#typesmiddlewareobservers","text":"","title":"types.middleware.observers"},{"location":"reference/types/middleware/observers/#arc.types.middleware.observers.Log","text":"Type middleware to log the value provided","title":"Log"},{"location":"reference/types/middleware/observers/#arc.types.middleware.observers.Log--example","text":"import typing as t import arc from arc.types.middleware import Log arc . configure ( environment = \"development\" ) @arc . command def command ( val : t . Annotated [ int , Log ()], flag_name : t . Annotated [ bool , Log ()], ): arc . print ( \"hello there!\" ) command () Source code in /home/runner/work/arc/arc/arc/types/middleware/observers.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class Log : \"\"\"Type middleware to log the value provided ## Example ```py import typing as t import arc from arc.types.middleware import Log arc.configure(environment=\"development\") @arc.command def command( val: t.Annotated[int, Log()], flag_name: t.Annotated[bool, Log()], ): arc.print(\"hello there!\") command() ``` \"\"\" def __init__ ( self , level : int = logging . INFO , name_kind : t . Literal [ \"arg\" , \"param\" , \"cli\" ] = \"arg\" , ) -> None : self . level = level self . name_kind = name_kind def __call__ ( self , value : t . Any , ctx : Context | None = None , param : Param [ t . Any ] | None = None , ) -> t . Any : if param and ctx : names = { \"arg\" : param . argument_name , \"param\" : param . param_name , \"cli\" : param . cli_name , } origin = ctx . get_origin ( param . argument_name , \"default\" ) name = names . get ( self . name_kind , param . argument_name ) ctx . logger . log ( self . level , f \" { name } = { value } ( { origin } )\" ) return value","title":"Example"},{"location":"reference/types/middleware/transformers/","text":"types.middleware.transformers \u00b6 Pad \u00b6 Type transformation to pad a value to length with padding . Ensures that value will be at least length long. padding should be the same type as value, so the concatenation functions properly Type Constraints \u00b6 Support len() Support + for concatenation (like str or list ) Example \u00b6 import arc from arc.types.middleware import Pad @arc . command def command ( val : Annotated [ str , Pad ( 6 , 'b' )]) arc . print ( val ) command () $ python example.py a abbbbbb Source code in /home/runner/work/arc/arc/arc/types/middleware/transformers.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class Pad : \"\"\"Type transformation to pad a value to `length` with `padding`. Ensures that value will be at least `length` long. `padding` should be the same type as value, so the concatenation functions properly ## Type Constraints - Support `len()` - Support `+` for concatenation (like `str` or `list`) ## Example ```py import arc from arc.types.middleware import Pad @arc.command def command(val: Annotated[str, Pad(6, 'b')]) arc.print(val) command() ``` ```console $ python example.py a abbbbbb ``` \"\"\" def __init__ ( self , length : int , padding : t . Any , side : t . Literal [ \"left\" , \"right\" ] = \"right\" ): self . length = length self . padding = padding self . side = side def __call__ ( self , value : PadProtocol ) -> PadProtocol : if self . side == \"right\" : while len ( value ) < self . length : value += self . padding else : while len ( value ) < self . length : value = self . padding + value return value Round \u00b6 Type Tranformation to round given input to ndigits Type Contraints \u00b6 Supports round() Example \u00b6 import arc from arc.types.middleware import Round @arc . command def command ( val : Annotated [ float , Round ( 2 )]) arc . print ( val ) command () $ python example.py 1 .123456789 1.23 Source code in /home/runner/work/arc/arc/arc/types/middleware/transformers.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Round : \"\"\"Type Tranformation to round given input to `ndigits` ## Type Contraints - Supports `round()` ## Example ```py import arc from arc.types.middleware import Round @arc.command def command(val: Annotated[float, Round(2)]) arc.print(val) command() ``` ```console $ python example.py 1.123456789 1.23 ``` \"\"\" __slots__ = ( \"ndigits\" ,) def __init__ ( self , ndigits : int ) -> None : self . ndigits = ndigits def __call__ ( self , value : t . SupportsRound [ t . Any ]) -> t . SupportsRound [ t . Any ]: return round ( value , self . ndigits ) Truncate \u00b6 Type transformation to truncate a value to length Type Constraints \u00b6 Support list-like slice access Example \u00b6 import arc from arc.types.middleware import Truncate @arc . command def command ( val : Annotated [ str , Truncate ( 6 )]) arc . print ( val ) command () $ python example.py 'string longer than 6 chars' string Source code in /home/runner/work/arc/arc/arc/types/middleware/transformers.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class Truncate : \"\"\"Type transformation to truncate a value to `length` ## Type Constraints - Support list-like slice access ## Example ```py import arc from arc.types.middleware import Truncate @arc.command def command(val: Annotated[str, Truncate(6)]) arc.print(val) command() ``` ```console $ python example.py 'string longer than 6 chars' string ``` \"\"\" def __init__ ( self , length : int ): self . length = length def __call__ ( self , value : SupportsSlice ) -> SupportsSlice : return value [ 0 : self . length ]","title":"types.middleware.transformers"},{"location":"reference/types/middleware/transformers/#typesmiddlewaretransformers","text":"","title":"types.middleware.transformers"},{"location":"reference/types/middleware/transformers/#arc.types.middleware.transformers.Pad","text":"Type transformation to pad a value to length with padding . Ensures that value will be at least length long. padding should be the same type as value, so the concatenation functions properly","title":"Pad"},{"location":"reference/types/middleware/transformers/#arc.types.middleware.transformers.Pad--type-constraints","text":"Support len() Support + for concatenation (like str or list )","title":"Type Constraints"},{"location":"reference/types/middleware/transformers/#arc.types.middleware.transformers.Pad--example","text":"import arc from arc.types.middleware import Pad @arc . command def command ( val : Annotated [ str , Pad ( 6 , 'b' )]) arc . print ( val ) command () $ python example.py a abbbbbb Source code in /home/runner/work/arc/arc/arc/types/middleware/transformers.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class Pad : \"\"\"Type transformation to pad a value to `length` with `padding`. Ensures that value will be at least `length` long. `padding` should be the same type as value, so the concatenation functions properly ## Type Constraints - Support `len()` - Support `+` for concatenation (like `str` or `list`) ## Example ```py import arc from arc.types.middleware import Pad @arc.command def command(val: Annotated[str, Pad(6, 'b')]) arc.print(val) command() ``` ```console $ python example.py a abbbbbb ``` \"\"\" def __init__ ( self , length : int , padding : t . Any , side : t . Literal [ \"left\" , \"right\" ] = \"right\" ): self . length = length self . padding = padding self . side = side def __call__ ( self , value : PadProtocol ) -> PadProtocol : if self . side == \"right\" : while len ( value ) < self . length : value += self . padding else : while len ( value ) < self . length : value = self . padding + value return value","title":"Example"},{"location":"reference/types/middleware/transformers/#arc.types.middleware.transformers.Round","text":"Type Tranformation to round given input to ndigits","title":"Round"},{"location":"reference/types/middleware/transformers/#arc.types.middleware.transformers.Round--type-contraints","text":"Supports round()","title":"Type Contraints"},{"location":"reference/types/middleware/transformers/#arc.types.middleware.transformers.Round--example","text":"import arc from arc.types.middleware import Round @arc . command def command ( val : Annotated [ float , Round ( 2 )]) arc . print ( val ) command () $ python example.py 1 .123456789 1.23 Source code in /home/runner/work/arc/arc/arc/types/middleware/transformers.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Round : \"\"\"Type Tranformation to round given input to `ndigits` ## Type Contraints - Supports `round()` ## Example ```py import arc from arc.types.middleware import Round @arc.command def command(val: Annotated[float, Round(2)]) arc.print(val) command() ``` ```console $ python example.py 1.123456789 1.23 ``` \"\"\" __slots__ = ( \"ndigits\" ,) def __init__ ( self , ndigits : int ) -> None : self . ndigits = ndigits def __call__ ( self , value : t . SupportsRound [ t . Any ]) -> t . SupportsRound [ t . Any ]: return round ( value , self . ndigits )","title":"Example"},{"location":"reference/types/middleware/transformers/#arc.types.middleware.transformers.Truncate","text":"Type transformation to truncate a value to length","title":"Truncate"},{"location":"reference/types/middleware/transformers/#arc.types.middleware.transformers.Truncate--type-constraints","text":"Support list-like slice access","title":"Type Constraints"},{"location":"reference/types/middleware/transformers/#arc.types.middleware.transformers.Truncate--example","text":"import arc from arc.types.middleware import Truncate @arc . command def command ( val : Annotated [ str , Truncate ( 6 )]) arc . print ( val ) command () $ python example.py 'string longer than 6 chars' string Source code in /home/runner/work/arc/arc/arc/types/middleware/transformers.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class Truncate : \"\"\"Type transformation to truncate a value to `length` ## Type Constraints - Support list-like slice access ## Example ```py import arc from arc.types.middleware import Truncate @arc.command def command(val: Annotated[str, Truncate(6)]) arc.print(val) command() ``` ```console $ python example.py 'string longer than 6 chars' string ``` \"\"\" def __init__ ( self , length : int ): self . length = length def __call__ ( self , value : SupportsSlice ) -> SupportsSlice : return value [ 0 : self . length ]","title":"Example"},{"location":"reference/types/middleware/validators/","text":"types.middleware.validators \u00b6 Between \u00b6 Validator to ensure that a value falls within a particular range Type Constraints \u00b6 Supports Comparison (<, >, ==) Source code in /home/runner/work/arc/arc/arc/types/middleware/validators.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 class Between : \"\"\"Validator to ensure that a value falls within a particular range ## Type Constraints - Supports Comparison (<, >, ==) \"\"\" def __init__ ( self , lower : SupportsComparison , upper : SupportsComparison ): self . lower = lower self . upper = upper def __call__ ( self , value : SupportsComparison ) -> SupportsComparison : if value <= self . lower or value >= self . upper : raise errors . ValidationError ( f \"must be between { self . lower } and { self . upper } \" ) return value GreaterThan \u00b6 Validator to limit the maximum size of a value Type Constraints \u00b6 Supports Comparison (<, >, ==) Source code in /home/runner/work/arc/arc/arc/types/middleware/validators.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 class GreaterThan : \"\"\"Validator to limit the maximum size of a value ## Type Constraints - Supports Comparison (<, >, ==) \"\"\" def __init__ ( self , smallest : SupportsComparison ): self . smallest = smallest def __call__ ( self , value : SupportsComparison ) -> SupportsComparison : if value <= self . smallest : raise errors . ValidationError ( f \"must be greater than { self . smallest } \" ) return value Len \u00b6 Validator for the length of a value. Len(4) - Value must be length 4 Len(1, 4) - Value must be from length 1 to 4 Type Constraints \u00b6 Supports len() Note : If you find yourself doing something similar to Annotated[list[int], Len(2)] , it's generally going to be a bettter idea to do: tuple[int, int] Source code in /home/runner/work/arc/arc/arc/types/middleware/validators.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class Len : \"\"\"Validator for the length of a value. - `Len(4)` - Value must be length 4 - `Len(1, 4)` - Value must be from length 1 to 4 ## Type Constraints - Supports `len()` **Note**: If you find yourself doing something similar to `Annotated[list[int], Len(2)]`, it's generally going to be a bettter idea to do: `tuple[int, int]` \"\"\" def __init__ ( self , min : int , max : int | None = None ): self . min = min self . max = max def __call__ ( self , value : SupportsLen , ctx : Context | None = None , param : Param [ t . Any ] | None = None , ) -> SupportsLen : length = len ( value ) if self . max : if length < self . min or length > self . max : if param and param . type . is_collection_type : raise errors . ValidationError ( f \"expects between { self . min } and { self . max } arguments\" ) raise errors . ValidationError ( f \"must have a length between { self . min } and { self . max } \" ) elif length != self . min : if param and param . type . is_collection_type : raise errors . ValidationError ( f \"expects { self . min } arguments\" ) raise errors . ValidationError ( f \"must have a length equal to { self . min } \" ) return value LessThan \u00b6 Validator to limit the minimum size of a value Type Constraints \u00b6 Supports Comparison (<, >, ==) Source code in /home/runner/work/arc/arc/arc/types/middleware/validators.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 class LessThan : \"\"\"Validator to limit the minimum size of a value ## Type Constraints - Supports Comparison (<, >, ==) \"\"\" def __init__ ( self , largest : SupportsComparison ): self . largest = largest def __call__ ( self , value : SupportsComparison ) -> SupportsComparison : if value >= self . largest : raise errors . ValidationError ( f \"must be less than { self . largest } \" ) return value Matches \u00b6 Validator to match a regular expression. Type Constraints \u00b6 Matches against str(value) , so the type must have a sensible string representation Source code in /home/runner/work/arc/arc/arc/types/middleware/validators.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Matches : \"\"\"Validator to match a regular expression. ## Type Constraints - Matches against `str(value)`, so the type must have a sensible string representation \"\"\" def __init__ ( self , pattern : str | re . Pattern [ str ], flags : int = 0 , message : str = \"does not match expected format: {pattern} \" , ): self . pattern = pattern self . flags = flags self . message = message def __call__ ( self , value : t . Any ) -> t . Any : if not re . match ( self . pattern , str ( value ), self . flags ): raise errors . ValidationError ( self . message . format ( pattern = self . pattern , value = value , ) ) return value","title":"types.middleware.validators"},{"location":"reference/types/middleware/validators/#typesmiddlewarevalidators","text":"","title":"types.middleware.validators"},{"location":"reference/types/middleware/validators/#arc.types.middleware.validators.Between","text":"Validator to ensure that a value falls within a particular range","title":"Between"},{"location":"reference/types/middleware/validators/#arc.types.middleware.validators.Between--type-constraints","text":"Supports Comparison (<, >, ==) Source code in /home/runner/work/arc/arc/arc/types/middleware/validators.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 class Between : \"\"\"Validator to ensure that a value falls within a particular range ## Type Constraints - Supports Comparison (<, >, ==) \"\"\" def __init__ ( self , lower : SupportsComparison , upper : SupportsComparison ): self . lower = lower self . upper = upper def __call__ ( self , value : SupportsComparison ) -> SupportsComparison : if value <= self . lower or value >= self . upper : raise errors . ValidationError ( f \"must be between { self . lower } and { self . upper } \" ) return value","title":"Type Constraints"},{"location":"reference/types/middleware/validators/#arc.types.middleware.validators.GreaterThan","text":"Validator to limit the maximum size of a value","title":"GreaterThan"},{"location":"reference/types/middleware/validators/#arc.types.middleware.validators.GreaterThan--type-constraints","text":"Supports Comparison (<, >, ==) Source code in /home/runner/work/arc/arc/arc/types/middleware/validators.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 class GreaterThan : \"\"\"Validator to limit the maximum size of a value ## Type Constraints - Supports Comparison (<, >, ==) \"\"\" def __init__ ( self , smallest : SupportsComparison ): self . smallest = smallest def __call__ ( self , value : SupportsComparison ) -> SupportsComparison : if value <= self . smallest : raise errors . ValidationError ( f \"must be greater than { self . smallest } \" ) return value","title":"Type Constraints"},{"location":"reference/types/middleware/validators/#arc.types.middleware.validators.Len","text":"Validator for the length of a value. Len(4) - Value must be length 4 Len(1, 4) - Value must be from length 1 to 4","title":"Len"},{"location":"reference/types/middleware/validators/#arc.types.middleware.validators.Len--type-constraints","text":"Supports len() Note : If you find yourself doing something similar to Annotated[list[int], Len(2)] , it's generally going to be a bettter idea to do: tuple[int, int] Source code in /home/runner/work/arc/arc/arc/types/middleware/validators.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class Len : \"\"\"Validator for the length of a value. - `Len(4)` - Value must be length 4 - `Len(1, 4)` - Value must be from length 1 to 4 ## Type Constraints - Supports `len()` **Note**: If you find yourself doing something similar to `Annotated[list[int], Len(2)]`, it's generally going to be a bettter idea to do: `tuple[int, int]` \"\"\" def __init__ ( self , min : int , max : int | None = None ): self . min = min self . max = max def __call__ ( self , value : SupportsLen , ctx : Context | None = None , param : Param [ t . Any ] | None = None , ) -> SupportsLen : length = len ( value ) if self . max : if length < self . min or length > self . max : if param and param . type . is_collection_type : raise errors . ValidationError ( f \"expects between { self . min } and { self . max } arguments\" ) raise errors . ValidationError ( f \"must have a length between { self . min } and { self . max } \" ) elif length != self . min : if param and param . type . is_collection_type : raise errors . ValidationError ( f \"expects { self . min } arguments\" ) raise errors . ValidationError ( f \"must have a length equal to { self . min } \" ) return value","title":"Type Constraints"},{"location":"reference/types/middleware/validators/#arc.types.middleware.validators.LessThan","text":"Validator to limit the minimum size of a value","title":"LessThan"},{"location":"reference/types/middleware/validators/#arc.types.middleware.validators.LessThan--type-constraints","text":"Supports Comparison (<, >, ==) Source code in /home/runner/work/arc/arc/arc/types/middleware/validators.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 class LessThan : \"\"\"Validator to limit the minimum size of a value ## Type Constraints - Supports Comparison (<, >, ==) \"\"\" def __init__ ( self , largest : SupportsComparison ): self . largest = largest def __call__ ( self , value : SupportsComparison ) -> SupportsComparison : if value >= self . largest : raise errors . ValidationError ( f \"must be less than { self . largest } \" ) return value","title":"Type Constraints"},{"location":"reference/types/middleware/validators/#arc.types.middleware.validators.Matches","text":"Validator to match a regular expression.","title":"Matches"},{"location":"reference/types/middleware/validators/#arc.types.middleware.validators.Matches--type-constraints","text":"Matches against str(value) , so the type must have a sensible string representation Source code in /home/runner/work/arc/arc/arc/types/middleware/validators.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Matches : \"\"\"Validator to match a regular expression. ## Type Constraints - Matches against `str(value)`, so the type must have a sensible string representation \"\"\" def __init__ ( self , pattern : str | re . Pattern [ str ], flags : int = 0 , message : str = \"does not match expected format: {pattern} \" , ): self . pattern = pattern self . flags = flags self . message = message def __call__ ( self , value : t . Any ) -> t . Any : if not re . match ( self . pattern , str ( value ), self . flags ): raise errors . ValidationError ( self . message . format ( pattern = self . pattern , value = value , ) ) return value","title":"Type Constraints"},{"location":"usage/classful-commands/","text":"Command can also be defined with a class, instead of a function. For example, this command: examples/hello.py import arc @arc . command def hello ( name : str ): \"\"\"Greets someone by name\"\"\" arc . print ( f \"Hello { name } !\" ) hello () Could be written as: examples/classful.py import arc @arc . command class hello : \"\"\"Greets a person by name\"\"\" name : str = arc . Argument ( desc = \"Name of the person to greet\" , default = \"world\" ) def handle ( self ): arc . print ( f \"Hello, { self . name } !\" ) hello () $ python classful.py Joseph Hello, Joseph! $ python classful.py --help USAGE classful.py [-h] [name] DESCRIPTION Greets a person by name ARGUMENTS name Name of the person to greet (default: world) OPTIONS --help (-h) Displays this help message","title":"Classful Commands"},{"location":"usage/command-state/","text":"arc . State is arc's primary way for sharing global data all throughout your application. State is a dictionary of key-value pairs that you pass when executing you application. A command can then request access to the state object by annotating a argument with State examples/state.py import arc @arc . command def command ( state : arc . State ): # arc.State is a dict-like object, so it can be accessed # like a dictionary, or it can be accessed via attributes arc . print ( state . value ) arc . print ( state [ \"value\" ]) command ( state = { \"value\" : 1 }) $ python state.py 1 1 Note that because the State type has a special meaning it will not be exposed to the external interface $ python state.py --help USAGE state.py [-h] OPTIONS --help (-h) Displays this help message Subclassing State \u00b6 State may also be sub-classed, and still maintain the same unique behavior. This is useful for providing additional functionality via attached methods, or provide type hinting support for static analyzers like mypy. examples/state_inherit.py import arc class MyState ( arc . State ): name : str def punch ( self ): arc . print ( f \"ORA ORA, { self . name } \" ) @arc . command def punch ( state : MyState ): state . punch () punch ( state = { \"name\" : \"DIO\" }) $ python state_inherit.py ORA ORA, DIO","title":"Command State"},{"location":"usage/command-state/#subclassing-state","text":"State may also be sub-classed, and still maintain the same unique behavior. This is useful for providing additional functionality via attached methods, or provide type hinting support for static analyzers like mypy. examples/state_inherit.py import arc class MyState ( arc . State ): name : str def punch ( self ): arc . print ( f \"ORA ORA, { self . name } \" ) @arc . command def punch ( state : MyState ): state . punch () punch ( state = { \"name\" : \"DIO\" }) $ python state_inherit.py ORA ORA, DIO","title":"Subclassing State"},{"location":"usage/documentation-generation/","text":"Every arc application / command comes with a builtin --help flag. Example \u00b6 hello.py import arc @arc . command def hello ( name : str ): \"\"\"Greets someone by name\"\"\" arc . print ( f \"Hello { name } !\" ) hello () $ python hello.py --help USAGE hello.py [-h] name DESCRIPTION Greets someone by name ARGUMENTS name OPTIONS --help (-h) Displays this help message Parameter Documentation \u00b6 Command parameters are documented using the desc argument of Argument / Option / Flag . The following command: arguments_documentation.py import arc @arc . command def cli ( firstname : str = arc . Argument ( desc = \"Someone's first name\" ), lastname : str = arc . Option ( default = \"Johnson\" , desc = \"Someone's last name. Optional\" ), reverse : bool = arc . Flag ( desc = \"print the name out in reverse\" ), ): \"\"\"Parameter documentation\"\"\" cli () Will produce the following help output: $ python arguments_documentation.py --help USAGE arguments_documentation.py [-h] [--lastname LASTNAME] [--reverse] firstname DESCRIPTION Parameter documentation ARGUMENTS firstname Someone's first name OPTIONS --help (-h) Displays this help message --lastname Someone's last name. Optional (default: Johnson) --reverse print the name out in reverse Formatting \u00b6 arc supports a markdown-like syntax for formatting help output. Example \u00b6 examples/formatting_help.py import arc @arc . command def command (): \"\"\"**Command description**. Any text before the first section heading will be considered the command description. # Section Heading You can add a section heading to your help text by using a line that starts with a hash followed by a space. Any sections you define will be included in the help text below the auto-generated sections. Paragraphs are separated by blank lines. `arc` will handle wrapping the text for pargraphs automatically. # Lists You can create lists by using the following syntax: - This is a list item - This is another list item - This is a third list item # Unformatted text You can add unformatted text by surrounding the text with three backticks ``` arc will not perform any formatting of this text. This lets you fully control how the text is displayed (Like tabbing it in!) ``` `arc` actually takes advantage of this fact to have more more control over how the Argument and Options are displayed in the help text. \"\"\" command () Syntax \u00b6 The following syntax is supported: Syntax Description **bold** Bolds Text *italic* Italicizes Text ~~strikethrough~~ Strikethrough Text __underline__ Underlines Text `code` Inline Code Block. Useful for when you want to indicate how to run another command [www.example.com] Marks text as a link. Colors it with config.present.color.accent and underlines it [[fg.RED]]red[[/fg.RED]] Colors Text. See Colors for more information --- Inserts a horizontal rule Colors \u00b6 You are able to color text using the [[fg.COLOR]]text[[/fg.COLOR]] syntax. The following objects are available for use: fg - Foreground Colors bg - Background Colors color - Configured Colors","title":"Documentation Generation"},{"location":"usage/documentation-generation/#example","text":"hello.py import arc @arc . command def hello ( name : str ): \"\"\"Greets someone by name\"\"\" arc . print ( f \"Hello { name } !\" ) hello () $ python hello.py --help USAGE hello.py [-h] name DESCRIPTION Greets someone by name ARGUMENTS name OPTIONS --help (-h) Displays this help message","title":"Example"},{"location":"usage/documentation-generation/#parameter-documentation","text":"Command parameters are documented using the desc argument of Argument / Option / Flag . The following command: arguments_documentation.py import arc @arc . command def cli ( firstname : str = arc . Argument ( desc = \"Someone's first name\" ), lastname : str = arc . Option ( default = \"Johnson\" , desc = \"Someone's last name. Optional\" ), reverse : bool = arc . Flag ( desc = \"print the name out in reverse\" ), ): \"\"\"Parameter documentation\"\"\" cli () Will produce the following help output: $ python arguments_documentation.py --help USAGE arguments_documentation.py [-h] [--lastname LASTNAME] [--reverse] firstname DESCRIPTION Parameter documentation ARGUMENTS firstname Someone's first name OPTIONS --help (-h) Displays this help message --lastname Someone's last name. Optional (default: Johnson) --reverse print the name out in reverse","title":"Parameter Documentation"},{"location":"usage/documentation-generation/#formatting","text":"arc supports a markdown-like syntax for formatting help output.","title":"Formatting"},{"location":"usage/documentation-generation/#example_1","text":"examples/formatting_help.py import arc @arc . command def command (): \"\"\"**Command description**. Any text before the first section heading will be considered the command description. # Section Heading You can add a section heading to your help text by using a line that starts with a hash followed by a space. Any sections you define will be included in the help text below the auto-generated sections. Paragraphs are separated by blank lines. `arc` will handle wrapping the text for pargraphs automatically. # Lists You can create lists by using the following syntax: - This is a list item - This is another list item - This is a third list item # Unformatted text You can add unformatted text by surrounding the text with three backticks ``` arc will not perform any formatting of this text. This lets you fully control how the text is displayed (Like tabbing it in!) ``` `arc` actually takes advantage of this fact to have more more control over how the Argument and Options are displayed in the help text. \"\"\" command ()","title":"Example"},{"location":"usage/documentation-generation/#syntax","text":"The following syntax is supported: Syntax Description **bold** Bolds Text *italic* Italicizes Text ~~strikethrough~~ Strikethrough Text __underline__ Underlines Text `code` Inline Code Block. Useful for when you want to indicate how to run another command [www.example.com] Marks text as a link. Colors it with config.present.color.accent and underlines it [[fg.RED]]red[[/fg.RED]] Colors Text. See Colors for more information --- Inserts a horizontal rule","title":"Syntax"},{"location":"usage/documentation-generation/#colors","text":"You are able to color text using the [[fg.COLOR]]text[[/fg.COLOR]] syntax. The following objects are available for use: fg - Foreground Colors bg - Background Colors color - Configured Colors","title":"Colors"},{"location":"usage/error-handlers/","text":"You can define error handlers for your application. Error handlers are functions that are called when an error occurs in your application. You can define error handlers for specific error types or for all errors. examples/errors/error_handlers.py import arc @arc . command def command (): arc . print ( \"We're going to throw an error\" ) raise RuntimeError ( \"Something has gone wrong!\" ) @command . handle ( RuntimeError ) def handle_exception ( ctx : arc . Context , exc ): arc . print ( \"handled!\" ) command () $ python errors/error_handlers.py We're going to throw an error handled! Handlers are called for relavent errors in reverse to the order they are defined. If you define a handler for a general error type, then a handler for a specific error type, the more specific handler will be called first. Bubbling Errors \u00b6 If a particular error can't be handled by the current error handler, it will be passed to the next error handler. This is called bubbling. If no error handler can handle the error, the error will be passed to the default error handler. examples/errors/bubbling.py import arc @arc . command def command (): arc . print ( \"We're going to throw an error\" ) raise RuntimeError ( \"Something has gone wrong!\" ) @command . handle ( Exception ) def handle_exception ( ctx : arc . Context , exc ): arc . print ( \"General exception handler\" ) @command . handle ( RuntimeError ) def handle_runtime_error ( ctx : arc . Context , exc ): arc . print ( \"Cannot handle this error, bubbling\" ) raise exc command () $ python errors/bubbling.py We're going to throw an error Cannot handle this error, bubbling General exception handler Default Error Handling Behavior \u00b6 If no error handler is defined, arc will use the default error handling behavior: For internal errors (errors that derive from arc . errors . ArcError ), a formatted message for the error will be printed to the console and then the application will exit with a non-zero exit code. All other errors will be bubbled to the Python runtime & a traceback will be printed to the console. Since this isn't a particularly graceful exit, it's recommended that you define error handlers for your application.","title":"Error Handling"},{"location":"usage/error-handlers/#bubbling-errors","text":"If a particular error can't be handled by the current error handler, it will be passed to the next error handler. This is called bubbling. If no error handler can handle the error, the error will be passed to the default error handler. examples/errors/bubbling.py import arc @arc . command def command (): arc . print ( \"We're going to throw an error\" ) raise RuntimeError ( \"Something has gone wrong!\" ) @command . handle ( Exception ) def handle_exception ( ctx : arc . Context , exc ): arc . print ( \"General exception handler\" ) @command . handle ( RuntimeError ) def handle_runtime_error ( ctx : arc . Context , exc ): arc . print ( \"Cannot handle this error, bubbling\" ) raise exc command () $ python errors/bubbling.py We're going to throw an error Cannot handle this error, bubbling General exception handler","title":"Bubbling Errors"},{"location":"usage/error-handlers/#default-error-handling-behavior","text":"If no error handler is defined, arc will use the default error handling behavior: For internal errors (errors that derive from arc . errors . ArcError ), a formatted message for the error will be printed to the console and then the application will exit with a non-zero exit code. All other errors will be bubbled to the Python runtime & a traceback will be printed to the console. Since this isn't a particularly graceful exit, it's recommended that you define error handlers for your application.","title":"Default Error Handling Behavior"},{"location":"usage/intro/","text":"This intro serves as a quick starting off point to see some of arc's most useful features. Hello World \u00b6 The simplest arc program would look like this hello_world.py import arc @arc . command def main (): arc . print ( \"Hello World!\" ) main () Which we can then execute directly! $ python hello_world.py Hello World! Let's break this down to better understand what exactly is going on. @arc . command is a Python decorator that transforms a function into an arc command. def main () is just a simple Python function main () while this make look like we're calling the main function, because the function has been transformed into a command, we're actualy executing the command. Parameters \u00b6 We can add parameters to the previous example by defining an argument. For example, instead of saying hello to the world, we can have the command say hello to a specific person that we can input: examples/hello.py import arc @arc . command def hello ( name : str ): \"\"\"Greets someone by name\"\"\" arc . print ( f \"Hello { name } !\" ) hello () $ python hello.py Joseph Hello Joseph! Documentation \u00b6 Our argument and docstring get added automatcially to the --help output $ python hello.py --help USAGE hello.py [-h] name DESCRIPTION Greets someone by name ARGUMENTS name OPTIONS --help (-h) Displays this help message Type Hints \u00b6 arc uses argument type hints for data validation / conversion. For example, say we want to write a command that can sum two numbers together: examples/add.py import arc @arc . command def add ( val1 : int , val2 : int ): arc . print ( f \"The answer is: { val1 + val2 } \" ) add () $ python add.py 5 10 The answer is: 15 if the input fails to validate, arc will report a user-friendly error for the type $ python add.py 5 not-a-number USAGE add.py [-h] val1 val2 invalid value for val2: must be an integer (invalid literal for int() with base 10: 'not-a-number') Some note about types: if a parameter does not specify a type, arc implicitly types it as str . All builtin types are supported by arc , and many stdlib types Parameter Types contains a comprehensive list of all supported types. Configuration \u00b6 arc is easily configurable via the arc . configure () function. For example, you can set a version string for you application. This will add a --version flag to your application. examples/hello_configuration.py import arc arc . configure ( version = \"1.0.0\" ) @arc . command def hello ( name : str ): \"\"\"My first arc program!\"\"\" arc . print ( f \"Hello { name } !\" ) hello () $ python hello_configuration.py --help USAGE hello_configuration.py [-h] [-v] name DESCRIPTION My first arc program! ARGUMENTS name OPTIONS --help (-h) Displays this help message --version (-v) Displays the app's version number $ python hello_configuration.py --version 1.0.0 View the reference for details on all the configuration options","title":"Intro"},{"location":"usage/intro/#hello-world","text":"The simplest arc program would look like this hello_world.py import arc @arc . command def main (): arc . print ( \"Hello World!\" ) main () Which we can then execute directly! $ python hello_world.py Hello World! Let's break this down to better understand what exactly is going on. @arc . command is a Python decorator that transforms a function into an arc command. def main () is just a simple Python function main () while this make look like we're calling the main function, because the function has been transformed into a command, we're actualy executing the command.","title":"Hello World"},{"location":"usage/intro/#parameters","text":"We can add parameters to the previous example by defining an argument. For example, instead of saying hello to the world, we can have the command say hello to a specific person that we can input: examples/hello.py import arc @arc . command def hello ( name : str ): \"\"\"Greets someone by name\"\"\" arc . print ( f \"Hello { name } !\" ) hello () $ python hello.py Joseph Hello Joseph!","title":"Parameters"},{"location":"usage/intro/#documentation","text":"Our argument and docstring get added automatcially to the --help output $ python hello.py --help USAGE hello.py [-h] name DESCRIPTION Greets someone by name ARGUMENTS name OPTIONS --help (-h) Displays this help message","title":"Documentation"},{"location":"usage/intro/#type-hints","text":"arc uses argument type hints for data validation / conversion. For example, say we want to write a command that can sum two numbers together: examples/add.py import arc @arc . command def add ( val1 : int , val2 : int ): arc . print ( f \"The answer is: { val1 + val2 } \" ) add () $ python add.py 5 10 The answer is: 15 if the input fails to validate, arc will report a user-friendly error for the type $ python add.py 5 not-a-number USAGE add.py [-h] val1 val2 invalid value for val2: must be an integer (invalid literal for int() with base 10: 'not-a-number') Some note about types: if a parameter does not specify a type, arc implicitly types it as str . All builtin types are supported by arc , and many stdlib types Parameter Types contains a comprehensive list of all supported types.","title":"Type Hints"},{"location":"usage/intro/#configuration","text":"arc is easily configurable via the arc . configure () function. For example, you can set a version string for you application. This will add a --version flag to your application. examples/hello_configuration.py import arc arc . configure ( version = \"1.0.0\" ) @arc . command def hello ( name : str ): \"\"\"My first arc program!\"\"\" arc . print ( f \"Hello { name } !\" ) hello () $ python hello_configuration.py --help USAGE hello_configuration.py [-h] [-v] name DESCRIPTION My first arc program! ARGUMENTS name OPTIONS --help (-h) Displays this help message --version (-v) Displays the app's version number $ python hello_configuration.py --version 1.0.0 View the reference for details on all the configuration options","title":"Configuration"},{"location":"usage/middleware/","text":"arc is based on a middleware design pattern. In arc there are three kinds: Initialization middlewares - Middleware that run a single time on startup. These are expected to perform the necessary setup to get an arc application up and running. The default middleware stack does, among other things, the following: Performs development mode checks Normalizes the differences between input sources Validates that input Parses the input from the command line Prepares the context object for execution Execution Middlewares - Middleware that run every-time a command is executed. Each command will have associated middlewares and when a command is chosen all of it's parents middlewares will be ran, then it's middlewares, then the callback. The default middleware stack does, among other things, the following: Associates parsed values with command parameters Retrieves values from other parameter sources (enviroment variables, user input, etc...) Performs type conversion on parsed values Executes validations on parsed values (ensures that they meet the requirements of the parameter) Type Middlewares - Middlewares that operate on the type level . These middlewares are unique and will not be covered on this page. But they are used to add validations / transformations to a type. Middleware Example \u00b6 A middleware is a callable object that receives and instance of arc . Context , which serves as a dict-like object that all middleware share. Each middleware can then perform manipulations to this context object to get their desired effect. In this example, we add a middleware that simple prints out some information about the command that is about to be executed. examples/middleware/middleware.py import arc @arc . command def hello ( name : str = \"world\" ): arc . print ( f \"Hello, { name } !\" ) @hello . use def middleware ( ctx : arc . Context ): arc . print ( \"Hello from middleware!\" ) arc . print ( f \"Command name: { ctx . command . name } \" ) arc . print ( f \"Command args: { ctx [ 'arc.args' ] } \" ) hello () $ python middleware/middleware.py Joseph Hello from middleware! Command name: middleware.py Command args: {'name': 'Joseph'} Hello, Joseph! Registering Middlewares \u00b6 Custom middleware can be added using the @object . use interface Init Middleware \u00b6 The add init middlewares to your application, you are required to construct the App object explicitly @arc . command def command (): ... app = arc . App ( command ) @app . use def middleware ( ctx ): ... app () Exec Middleware \u00b6 Execution middlewares are registered with commands specifically. @arc . command def command (): ... @command . use def middleware ( ctx ): ... Suspending Execution \u00b6 Middlewares may suspend their execution, and resume it after the command has executed by yielding. def middleware ( ctx : Context ): # Perform setup logic res = yield # Perform teardown logic The generators will be resumed in reverse order after command execution. The generator will be sent() the returned result of the command (or previous middleware). You may then choose to return something else which will be used as the result sent to the next middleware. Replace Context \u00b6 If you'd like to completely replace the context object, you may do so by returning (or yielding) a different object from your middleware. def middleware ( ctx : Context ): return { \"arc.args\" : { ... }} # OR def middleware ( ctx : Context ): yield { \"arc.args\" : { ... }} Halting Execution \u00b6 Stopping the rest of the pipeline from running should be accomplished by raising an exception def middleware ( ctx : Context ): arc . exit ( 1 , \"Something bad occured\" ) # raises a SystemExit # OR raise arc . ExecutionError ( \"Something bad occured\" ) # If you want an exception that other middlewares can catch # OR raise CustomException ( ... ) Catching Exceptions \u00b6 Middlewares are capable of catching exceptions that occur further down the pipeline by yielding inside of a try-except block: def middleware ( ctx : Context ): try : yield except Exception : # Handle the exception, or raise again If the handler can't handle a particular error, you can raise the exception again (or even raise a new exception). This will cause it to continue down the list of middlewares until it finds one that does handle the exception. If none are found, the exception will be handled by arc's default error-handling behavior. Alternative Error Handler Syntax Because error handling in middlewares is a common pattern, arc supports an alternate syntax for defining them. examples/errors/error_handlers.py import arc @arc . command def command (): arc . print ( \"We're going to throw an error\" ) raise RuntimeError ( \"Something has gone wrong!\" ) @command . handle ( RuntimeError ) def handle_exception ( ctx : arc . Context , exc ): arc . print ( \"handled!\" ) command () $ python errors/error_handlers.py We're going to throw an error handled! See Error Handling for more information Modifying the Middleware Stack \u00b6 By default use () adds the provided middleware to the end of the stack. Instead, you can provide various arguments to place it in a specific location command . use ( mid1 , pos = 4 ) # at index 4 command . use ( mid2 , after = mid1 ) # Inserted directly after mid1 command . use ( mid3 , before = mid1 ) # Inserted directly before mid1 command . use ( mid4 , replace = mid2 ) # Replaces mid2 with mid4 This can be used to override the default behavior of arc . For example, this could be used to replace arc's parsing middleware with your own. import arc @arc . command def command (): ... app = arc . App () @app . use ( replace = arc . InitMiddleware . Parser ) def parsing ( ctx ): # Do custom parsing app () Be careful when replacing middlewares, as it may break the functionality of arc . Most middlewares expect certain data to be in the Context object and will fail if it is not present. For example, if you replace the arc . InitMiddleware . Parser middleware, you will need to ensure that the arc.parse.result key is present in the context object and contains the parsed arguments. You can review the reference for both the init middlewares and execution middlewares to see what data they expect to be present in and what data they add to the context object.","title":"Middleware"},{"location":"usage/middleware/#middleware-example","text":"A middleware is a callable object that receives and instance of arc . Context , which serves as a dict-like object that all middleware share. Each middleware can then perform manipulations to this context object to get their desired effect. In this example, we add a middleware that simple prints out some information about the command that is about to be executed. examples/middleware/middleware.py import arc @arc . command def hello ( name : str = \"world\" ): arc . print ( f \"Hello, { name } !\" ) @hello . use def middleware ( ctx : arc . Context ): arc . print ( \"Hello from middleware!\" ) arc . print ( f \"Command name: { ctx . command . name } \" ) arc . print ( f \"Command args: { ctx [ 'arc.args' ] } \" ) hello () $ python middleware/middleware.py Joseph Hello from middleware! Command name: middleware.py Command args: {'name': 'Joseph'} Hello, Joseph!","title":"Middleware Example"},{"location":"usage/middleware/#registering-middlewares","text":"Custom middleware can be added using the @object . use interface","title":"Registering Middlewares"},{"location":"usage/middleware/#init-middleware","text":"The add init middlewares to your application, you are required to construct the App object explicitly @arc . command def command (): ... app = arc . App ( command ) @app . use def middleware ( ctx ): ... app ()","title":"Init Middleware"},{"location":"usage/middleware/#exec-middleware","text":"Execution middlewares are registered with commands specifically. @arc . command def command (): ... @command . use def middleware ( ctx ): ...","title":"Exec Middleware"},{"location":"usage/middleware/#suspending-execution","text":"Middlewares may suspend their execution, and resume it after the command has executed by yielding. def middleware ( ctx : Context ): # Perform setup logic res = yield # Perform teardown logic The generators will be resumed in reverse order after command execution. The generator will be sent() the returned result of the command (or previous middleware). You may then choose to return something else which will be used as the result sent to the next middleware.","title":"Suspending Execution"},{"location":"usage/middleware/#replace-context","text":"If you'd like to completely replace the context object, you may do so by returning (or yielding) a different object from your middleware. def middleware ( ctx : Context ): return { \"arc.args\" : { ... }} # OR def middleware ( ctx : Context ): yield { \"arc.args\" : { ... }}","title":"Replace Context"},{"location":"usage/middleware/#halting-execution","text":"Stopping the rest of the pipeline from running should be accomplished by raising an exception def middleware ( ctx : Context ): arc . exit ( 1 , \"Something bad occured\" ) # raises a SystemExit # OR raise arc . ExecutionError ( \"Something bad occured\" ) # If you want an exception that other middlewares can catch # OR raise CustomException ( ... )","title":"Halting Execution"},{"location":"usage/middleware/#catching-exceptions","text":"Middlewares are capable of catching exceptions that occur further down the pipeline by yielding inside of a try-except block: def middleware ( ctx : Context ): try : yield except Exception : # Handle the exception, or raise again If the handler can't handle a particular error, you can raise the exception again (or even raise a new exception). This will cause it to continue down the list of middlewares until it finds one that does handle the exception. If none are found, the exception will be handled by arc's default error-handling behavior. Alternative Error Handler Syntax Because error handling in middlewares is a common pattern, arc supports an alternate syntax for defining them. examples/errors/error_handlers.py import arc @arc . command def command (): arc . print ( \"We're going to throw an error\" ) raise RuntimeError ( \"Something has gone wrong!\" ) @command . handle ( RuntimeError ) def handle_exception ( ctx : arc . Context , exc ): arc . print ( \"handled!\" ) command () $ python errors/error_handlers.py We're going to throw an error handled! See Error Handling for more information","title":"Catching Exceptions"},{"location":"usage/middleware/#modifying-the-middleware-stack","text":"By default use () adds the provided middleware to the end of the stack. Instead, you can provide various arguments to place it in a specific location command . use ( mid1 , pos = 4 ) # at index 4 command . use ( mid2 , after = mid1 ) # Inserted directly after mid1 command . use ( mid3 , before = mid1 ) # Inserted directly before mid1 command . use ( mid4 , replace = mid2 ) # Replaces mid2 with mid4 This can be used to override the default behavior of arc . For example, this could be used to replace arc's parsing middleware with your own. import arc @arc . command def command (): ... app = arc . App () @app . use ( replace = arc . InitMiddleware . Parser ) def parsing ( ctx ): # Do custom parsing app () Be careful when replacing middlewares, as it may break the functionality of arc . Most middlewares expect certain data to be in the Context object and will fail if it is not present. For example, if you replace the arc . InitMiddleware . Parser middleware, you will need to ensure that the arc.parse.result key is present in the context object and contains the parsed arguments. You can review the reference for both the init middlewares and execution middlewares to see what data they expect to be present in and what data they add to the context object.","title":"Modifying the Middleware Stack"},{"location":"usage/plugins/","text":"Plugins are a way for third party packages to extend the functionality of arc . They can be either be added by the user or by the developer of the CLI application, depending on how the plugin loading has been configured. Generally, plugins look like the following: examples/plugin.py import arc def plugin ( ctx : arc . Context ): command = ctx . root @command . use def middleware ( ctx : arc . Context ): arc . print ( \"Starting plugin middleware!\" ) yield arc . print ( \"Ending plugin middleware!\" ) @command . subcommand def subcommand (): arc . print ( \"Subcommand installed by plugin!\" ) The plugin is a callable that receives the arc . Context () object as its only argument. This function can then be used to add new commands, options, arguments, middlewares, etc. to the CLI application. Loading Plugins \u00b6 Plugins are loaded in three ways: By Path By Entrypoint Group By Entrypoint Value By Path By Entrypoint Group By Entrypoint Value Paths should be a list of strings that point to either a python file or a directory. If a directory is provided, all python files in that directory will attempted be loaded as plugins. Each plugin that is to be loaded should have a callable object named plugin that takes a single argument, the arc . Context () object. import arc arc . configure ( plugin = arc . PluginConfig ( paths = [ \"/path/to/plugin.py\" , \"/path/to/other/plugin.py\" , \"/path/to/another/directory/\" , ] ) ) A list of entry points groups as defined by the Entry Point Specification . The value of the entrypoint should be a callable object that takes a single argument, the arc . Context () object. import arc arc . configure ( plugin = arc . PluginConfig ( groups = [ \"arc.plugins\" , \"myapp.plugins\" , ] ) ) A list of entry points values as defined by the Entry Point Specification . Should be a callable object that takes a single argument, the arc . Context () object. import arc arc . configure ( plugin = arc . PluginConfig ( entrypoints = [ \"myapp:plugin.plugin\" , \"myapp:plugin.other_plugin\" , ] ) )","title":"Plugins"},{"location":"usage/plugins/#loading-plugins","text":"Plugins are loaded in three ways: By Path By Entrypoint Group By Entrypoint Value By Path By Entrypoint Group By Entrypoint Value Paths should be a list of strings that point to either a python file or a directory. If a directory is provided, all python files in that directory will attempted be loaded as plugins. Each plugin that is to be loaded should have a callable object named plugin that takes a single argument, the arc . Context () object. import arc arc . configure ( plugin = arc . PluginConfig ( paths = [ \"/path/to/plugin.py\" , \"/path/to/other/plugin.py\" , \"/path/to/another/directory/\" , ] ) ) A list of entry points groups as defined by the Entry Point Specification . The value of the entrypoint should be a callable object that takes a single argument, the arc . Context () object. import arc arc . configure ( plugin = arc . PluginConfig ( groups = [ \"arc.plugins\" , \"myapp.plugins\" , ] ) ) A list of entry points values as defined by the Entry Point Specification . Should be a callable object that takes a single argument, the arc . Context () object. import arc arc . configure ( plugin = arc . PluginConfig ( entrypoints = [ \"myapp:plugin.plugin\" , \"myapp:plugin.other_plugin\" , ] ) )","title":"Loading Plugins"},{"location":"usage/shell-completions/","text":"Warning Shell completions are currently an experimental feature. There is no guarantee that they will work or if the API for using them will be stable. As such, the feature is disabled by default To enable shell completions, add the following to your script: import arc arc . configure ( autocomplete = True ) The autocompletions will be generated with the following commands. foo is used as an example command entry point / name bash zsh fish Add to ~/.bashrc eval \" $( foo --autocomplete bash ) \" Add to ~/.zshrc eval \" $( foo --autocomplete zsh ) \" Add to ~/.config/fish/completions/foo.fish foo --autocomplete fish | source Type Completions \u00b6 Argument types can provide shell completions for the argument. For example, arc's builtin support for enum.Enum provides completions for it's possible options examples/paint.py from enum import Enum import arc arc . configure ( autocomplete = True ) class Color ( Enum ): RED = \"red\" YELLOW = \"yellow\" GREEN = \"green\" # Could also use: # Color = Literal[\"red\", \"yellow\", \"green\"] @arc . command def paint ( color : Color ): if color is Color . RED : arc . print ( \"You painted the walls the bloodiest of reds\" ) elif color is Color . YELLOW : arc . print ( \"You painted the walls the most fabulous yellow\" ) else : arc . print ( \"You painted the walls the deepest of greens\" ) paint () $ paint <tab> red yellow green The following types have builtin completion support: enum . Enum pathlib . Path typing . Literal arc . types . ValidPath arc . types . FilePath arc . types . DirectoryPath arc . types . File .* Custom Types \u00b6 When implenting your own types, you can provide completions for them by implementing the __completions__ () method on your class. This method recieves an info object that contains information about the current state of the command line, and param which is the parameter that is being completed (in the below example, that parameter would be foo ). The method should return an iterable of arc . Completion () objects that are the possible completions for the parameter. examples/custom_type_completions.py import arc class CustomType : def __init__ ( self , val : int ): self . val = val def __str__ ( self ): return f \"CustomType(val= { self . val } )\" @classmethod def __convert__ ( cls , value : str ): if value . isnumeric (): return cls ( int ( value )) else : raise arc . ConversionError ( value , \"must be an integer\" ) @classmethod def __completions__ ( self , info : arc . CompletionInfo , param : arc . Param ): yield arc . Completion ( \"1\" ) yield arc . Completion ( \"2\" ) @arc . command def main ( foo : CustomType ): arc . print ( foo ) main () $ custom_type_example <tab> 1 2 Parameter Completions \u00b6 You can also provide completions on a parameter basis with the Command . complete decorator. examples/param_completions.py import arc @arc . command def command ( name : str ): arc . print ( name ) @command . complete ( \"name\" ) def names ( info : arc . CompletionInfo , param : arc . Param ): yield arc . Completion ( \"Sean\" ) yield arc . Completion ( \"Brooke\" ) command () $ param_completions <tab> Sean Brooke","title":"Shell Completions"},{"location":"usage/shell-completions/#type-completions","text":"Argument types can provide shell completions for the argument. For example, arc's builtin support for enum.Enum provides completions for it's possible options examples/paint.py from enum import Enum import arc arc . configure ( autocomplete = True ) class Color ( Enum ): RED = \"red\" YELLOW = \"yellow\" GREEN = \"green\" # Could also use: # Color = Literal[\"red\", \"yellow\", \"green\"] @arc . command def paint ( color : Color ): if color is Color . RED : arc . print ( \"You painted the walls the bloodiest of reds\" ) elif color is Color . YELLOW : arc . print ( \"You painted the walls the most fabulous yellow\" ) else : arc . print ( \"You painted the walls the deepest of greens\" ) paint () $ paint <tab> red yellow green The following types have builtin completion support: enum . Enum pathlib . Path typing . Literal arc . types . ValidPath arc . types . FilePath arc . types . DirectoryPath arc . types . File .*","title":"Type Completions"},{"location":"usage/shell-completions/#custom-types","text":"When implenting your own types, you can provide completions for them by implementing the __completions__ () method on your class. This method recieves an info object that contains information about the current state of the command line, and param which is the parameter that is being completed (in the below example, that parameter would be foo ). The method should return an iterable of arc . Completion () objects that are the possible completions for the parameter. examples/custom_type_completions.py import arc class CustomType : def __init__ ( self , val : int ): self . val = val def __str__ ( self ): return f \"CustomType(val= { self . val } )\" @classmethod def __convert__ ( cls , value : str ): if value . isnumeric (): return cls ( int ( value )) else : raise arc . ConversionError ( value , \"must be an integer\" ) @classmethod def __completions__ ( self , info : arc . CompletionInfo , param : arc . Param ): yield arc . Completion ( \"1\" ) yield arc . Completion ( \"2\" ) @arc . command def main ( foo : CustomType ): arc . print ( foo ) main () $ custom_type_example <tab> 1 2","title":"Custom Types"},{"location":"usage/shell-completions/#parameter-completions","text":"You can also provide completions on a parameter basis with the Command . complete decorator. examples/param_completions.py import arc @arc . command def command ( name : str ): arc . print ( name ) @command . complete ( \"name\" ) def names ( info : arc . CompletionInfo , param : arc . Param ): yield arc . Completion ( \"Sean\" ) yield arc . Completion ( \"Brooke\" ) command () $ param_completions <tab> Sean Brooke","title":"Parameter Completions"},{"location":"usage/subcommands/","text":"In all of the examples so far, we've had a single command, with a single set of parameters. This works fine for smaller applications, but once a tool starts to grow in scope, it is useful to start breaking up it's functionality into descrete units using subcommands . What is a Subcommand? \u00b6 A subcommand is an arc command object that lives underneath another command object. Each subcommand will have it's own callback function and it's own set of parameters. When ran from the commandline it will look a little something like this $ python example.py <subcommand> <options> Example \u00b6 There are a couple of ways to define subcommands, in this doc we'll focus on the most common examples/subcommand.py import arc @arc . command def command (): ... @command . subcommand def sub1 (): arc . print ( \"This is sub 1\" ) @command . subcommand def sub2 (): arc . print ( \"This is sub 2\" ) command () We can then execute each subcommand by referring to them by name. $ python subcommand.py sub1 This is sub 1 $ python subcommand.py sub2 This is sub 2 Documentation \u00b6 Subcommands also get their own --help $ python subcommand.py --help USAGE subcommand.py [-h] subcommand.py <subcommand> [ARGUMENTS ...] OPTIONS --help (-h) Displays this help message SUBCOMMANDS sub1 sub2 $ python subcommand.py sub1 --help USAGE subcommand.py sub1 [-h] OPTIONS --help (-h) Displays this help message $ python subcommand.py sub2 --help USAGE subcommand.py sub2 [-h] OPTIONS --help (-h) Displays this help message They're all pretty bare-bones right now, but they will fill out as the application grows. Nesting Subcommands \u00b6 Subcommands can be arbitrarly nested examples/nested_subcommands.py import arc @arc . command def command (): ... @command . subcommand def sub1 (): arc . print ( \"This is sub 1\" ) @sub1 . subcommand def nested1 (): arc . print ( \"This is nested 1\" ) @command . subcommand def sub2 (): arc . print ( \"This is sub 2\" ) @sub2 . subcommand def nested2 (): arc . print ( \"This is nested 2\" ) command () $ python nested_subcommands.py sub1 nested1 This is nested 1 $ python nested_subcommands.py sub2 nested2 This is nested 2 Root Command \u00b6 It is important to note that when using subcommands, the root command is still executable. One must take care that subcommand names may come into collision with arguments for the root or command (or any parent command, really). If you do not want a parent command to be executable, you may use this pattern: examples/namespace.py import arc ns = arc . namespace ( \"ns\" ) @ns . subcommand def sub (): arc . print ( \"Namespace Example\" ) ns () $ python namespace.py USAGE ns [-h] ns <subcommand> [ARGUMENTS ...] ns --help for more information $ python namespace.py sub Namespace Example Namespace commands do not take any arguments (besides --help ), and when invoked, will print out the usage for the command, and exit with an error code. Naming Subcommands \u00b6 By default, commands are the kebab-case version of the function they decorate. You can provide an explicit name for the command: import arc @arc . command def command (): ... @command . subcommand ( \"some-other-name\" ) def sub (): ... command () or provide multiple names, for a command: import arc @arc . command def command (): ... @command . subcommand ( \"some-other-name\" , \"another-name\" , \"a-third-name\" ) def sub (): ... command () Note that when you provide multiple names, the first in the list of names will be considered the \"canonical\" name while the others will be considered aliases Subcommands in other Files \u00b6 Breaking up your CLI interface into multiple files in arc is a very straightforward process. subcommand.py cli.py import arc @arc . command def sub (): print ( \"This is the subcommand\" ) # Notice, no call to sub() import arc from subcommand import sub @arc . command def cli (): print ( 'hello there!' ) # Here we add sub as a subcommand to cli cli . subcommand ( sub ) # Could add any number of aliases here if we wanted cli ()","title":"Subcommands"},{"location":"usage/subcommands/#what-is-a-subcommand","text":"A subcommand is an arc command object that lives underneath another command object. Each subcommand will have it's own callback function and it's own set of parameters. When ran from the commandline it will look a little something like this $ python example.py <subcommand> <options>","title":"What is a Subcommand?"},{"location":"usage/subcommands/#example","text":"There are a couple of ways to define subcommands, in this doc we'll focus on the most common examples/subcommand.py import arc @arc . command def command (): ... @command . subcommand def sub1 (): arc . print ( \"This is sub 1\" ) @command . subcommand def sub2 (): arc . print ( \"This is sub 2\" ) command () We can then execute each subcommand by referring to them by name. $ python subcommand.py sub1 This is sub 1 $ python subcommand.py sub2 This is sub 2","title":"Example"},{"location":"usage/subcommands/#documentation","text":"Subcommands also get their own --help $ python subcommand.py --help USAGE subcommand.py [-h] subcommand.py <subcommand> [ARGUMENTS ...] OPTIONS --help (-h) Displays this help message SUBCOMMANDS sub1 sub2 $ python subcommand.py sub1 --help USAGE subcommand.py sub1 [-h] OPTIONS --help (-h) Displays this help message $ python subcommand.py sub2 --help USAGE subcommand.py sub2 [-h] OPTIONS --help (-h) Displays this help message They're all pretty bare-bones right now, but they will fill out as the application grows.","title":"Documentation"},{"location":"usage/subcommands/#nesting-subcommands","text":"Subcommands can be arbitrarly nested examples/nested_subcommands.py import arc @arc . command def command (): ... @command . subcommand def sub1 (): arc . print ( \"This is sub 1\" ) @sub1 . subcommand def nested1 (): arc . print ( \"This is nested 1\" ) @command . subcommand def sub2 (): arc . print ( \"This is sub 2\" ) @sub2 . subcommand def nested2 (): arc . print ( \"This is nested 2\" ) command () $ python nested_subcommands.py sub1 nested1 This is nested 1 $ python nested_subcommands.py sub2 nested2 This is nested 2","title":"Nesting Subcommands"},{"location":"usage/subcommands/#root-command","text":"It is important to note that when using subcommands, the root command is still executable. One must take care that subcommand names may come into collision with arguments for the root or command (or any parent command, really). If you do not want a parent command to be executable, you may use this pattern: examples/namespace.py import arc ns = arc . namespace ( \"ns\" ) @ns . subcommand def sub (): arc . print ( \"Namespace Example\" ) ns () $ python namespace.py USAGE ns [-h] ns <subcommand> [ARGUMENTS ...] ns --help for more information $ python namespace.py sub Namespace Example Namespace commands do not take any arguments (besides --help ), and when invoked, will print out the usage for the command, and exit with an error code.","title":"Root Command"},{"location":"usage/subcommands/#naming-subcommands","text":"By default, commands are the kebab-case version of the function they decorate. You can provide an explicit name for the command: import arc @arc . command def command (): ... @command . subcommand ( \"some-other-name\" ) def sub (): ... command () or provide multiple names, for a command: import arc @arc . command def command (): ... @command . subcommand ( \"some-other-name\" , \"another-name\" , \"a-third-name\" ) def sub (): ... command () Note that when you provide multiple names, the first in the list of names will be considered the \"canonical\" name while the others will be considered aliases","title":"Naming Subcommands"},{"location":"usage/subcommands/#subcommands-in-other-files","text":"Breaking up your CLI interface into multiple files in arc is a very straightforward process. subcommand.py cli.py import arc @arc . command def sub (): print ( \"This is the subcommand\" ) # Notice, no call to sub() import arc from subcommand import sub @arc . command def cli (): print ( 'hello there!' ) # Here we add sub as a subcommand to cli cli . subcommand ( sub ) # Could add any number of aliases here if we wanted cli ()","title":"Subcommands in other Files"},{"location":"usage/user-input/","text":"arc comes with tooling for requsting input from the user in the form of the arc.prompt package. Here's a quick example of it in action: examples/user_input.py import arc from arc.prompt import Prompt @arc . command () def hello ( prompt : Prompt ): name = prompt . input ( \"Name: \" ) while not prompt . confirm ( \"Are you sure?\" ): name = prompt . input ( \"Name: \" ) print ( f \"Hello, { name } !\" ) hello () $ python user_input.py Name: Sean Are you sure? [y/n] y Hello, Sean! Writing a Question \u00b6 Below is an example of how you could write a custom RegexQuesion that validates user input to match a provided regular expression examples/custom_question.py import re from typing import Iterable from arc.prompt import Prompt , Question class RegexQuestion ( Question [ str ]): def __init__ ( self , prompt : str , pattern : re . Pattern ): super () . __init__ () self . prompt = prompt self . pattern = pattern def render ( self ) -> Iterable [ str ]: \"\"\"Render should return an iterable of strings to output before stopping for input\"\"\" yield self . prompt yield f \" [Must match: ' { self . pattern . pattern } '] \" def handle_answer ( self , value : str ) -> str : \"\"\"The handle answer method checks the validity of the user input. In addition, it should perform any additional parsing / conversion of the value that is required and return that. \"\"\" if not self . pattern . match ( value ): self . err ( f \"Must match pattern: ' { self . pattern . pattern } '\" ) return value prompt = Prompt () question = RegexQuestion ( \"Pick a number\" , re . compile ( \"\\d+\" )) number = prompt . ask ( question ) print ( f \"You picked: { number } \" ) $ python custom_question.py Pick a number [Must match: '\\d+'] 2 You picked: 2 You can look at the reference to see the kinds of questions that arc ships with by default. Configuring the Prompt \u00b6 You can provide your own Prompt instance like so: import arc from arc.prompt import Prompt arc . configure ( prompt = Prompt ()) # could also be a subclass, etc... Tip The prompt object you recieve via dependency injection is the same object that powers the prompt functionality of parameters . By configuring your own customized instance of the prompt, you can have the same appearance across both uses.","title":"User Input"},{"location":"usage/user-input/#writing-a-question","text":"Below is an example of how you could write a custom RegexQuesion that validates user input to match a provided regular expression examples/custom_question.py import re from typing import Iterable from arc.prompt import Prompt , Question class RegexQuestion ( Question [ str ]): def __init__ ( self , prompt : str , pattern : re . Pattern ): super () . __init__ () self . prompt = prompt self . pattern = pattern def render ( self ) -> Iterable [ str ]: \"\"\"Render should return an iterable of strings to output before stopping for input\"\"\" yield self . prompt yield f \" [Must match: ' { self . pattern . pattern } '] \" def handle_answer ( self , value : str ) -> str : \"\"\"The handle answer method checks the validity of the user input. In addition, it should perform any additional parsing / conversion of the value that is required and return that. \"\"\" if not self . pattern . match ( value ): self . err ( f \"Must match pattern: ' { self . pattern . pattern } '\" ) return value prompt = Prompt () question = RegexQuestion ( \"Pick a number\" , re . compile ( \"\\d+\" )) number = prompt . ask ( question ) print ( f \"You picked: { number } \" ) $ python custom_question.py Pick a number [Must match: '\\d+'] 2 You picked: 2 You can look at the reference to see the kinds of questions that arc ships with by default.","title":"Writing a Question"},{"location":"usage/user-input/#configuring-the-prompt","text":"You can provide your own Prompt instance like so: import arc from arc.prompt import Prompt arc . configure ( prompt = Prompt ()) # could also be a subclass, etc... Tip The prompt object you recieve via dependency injection is the same object that powers the prompt functionality of parameters . By configuring your own customized instance of the prompt, you can have the same appearance across both uses.","title":"Configuring the Prompt"},{"location":"usage/parameters/arguments/","text":"An arc argument is a parameter which get passed to the command positionally . They are defined using regular Python function arguments. import arc @arc . command def hello ( firstname : str , lastname : str | None ): name = firstname if lastname : name += f \" { lastname } \" arc . print ( f \"Hello, { name } ! Hope you have a wonderful day!\" ) hello () Notice that we annotated the first argument as str , but the second argument as str | None ? We do this because we want firstname to be required and lastname to be optional . By giving lastname a union type that includes None , we're letting arc know that if no value is passed in from the command line, it's ok for it to be None . Using None In arc , defining parameters as allowing None , can be done in several ways, all of which are equivelant. The following are all equivelant: def hello ( firstname : str , lastname : str | None ): Setting it explictly def hello ( firstname : str , lastname : str | None = None ): If you set the default as None , you don't actually have to annotate as such if not desired def hello ( firstname : str , lastname : str = None ): We can see it in action here $ python parameter_argument.py Joseph Hello, Joseph! Hope you have a wonderful day! And adding the optional lastname $ python parameter_argument.py Joseph Joestar Hello, Joseph Joestar! Hope you have a wonderful day! Documentation \u00b6 $ python parameter_argument.py --help USAGE parameter_argument.py [-h] firstname [lastname] ARGUMENTS firstname lastname OPTIONS --help (-h) Displays this help message Note The brackets around lastname in the USAGE indicate that it is optional Default Values \u00b6 Often, we don't just want a None when a value isn't provided, but we want some sort of default. This can be accomplished by simply giving the argument a default value. examples/parameter_default.py import arc @arc . command def hello ( firstname : str , lastname : str = \"Joestar\" ): name = f \" { firstname } { lastname } \" arc . print ( f \"Hello, { name } ! Hope you have a wonderful day!\" ) hello () Note the lack of None in the type signature. Now that we have a default, the value will always be a string, and we don't need to tell arc that the value is optional. Check it: $ python parameter_default.py Sean Hello, Sean Joestar! Hope you have a wonderful day! $ python parameter_default.py Sean Collings Hello, Sean Collings! Hope you have a wonderful day! Alternative Syntax \u00b6 arc has an alternative syntax fo defining arguments Take this argument from the last example lastname : str = \"Joestar\" Could also be defined as: lastname : str = arc . Argument ( default = \"Joestar\" ) Now, arc.Argument is unnecessary here, but comes with some additional bells and whistles that make it more useful. Some of these features will be explored in future guides, or you check the reference for full details on what it provides .","title":"Arguments"},{"location":"usage/parameters/arguments/#documentation","text":"$ python parameter_argument.py --help USAGE parameter_argument.py [-h] firstname [lastname] ARGUMENTS firstname lastname OPTIONS --help (-h) Displays this help message Note The brackets around lastname in the USAGE indicate that it is optional","title":"Documentation"},{"location":"usage/parameters/arguments/#default-values","text":"Often, we don't just want a None when a value isn't provided, but we want some sort of default. This can be accomplished by simply giving the argument a default value. examples/parameter_default.py import arc @arc . command def hello ( firstname : str , lastname : str = \"Joestar\" ): name = f \" { firstname } { lastname } \" arc . print ( f \"Hello, { name } ! Hope you have a wonderful day!\" ) hello () Note the lack of None in the type signature. Now that we have a default, the value will always be a string, and we don't need to tell arc that the value is optional. Check it: $ python parameter_default.py Sean Hello, Sean Joestar! Hope you have a wonderful day! $ python parameter_default.py Sean Collings Hello, Sean Collings! Hope you have a wonderful day!","title":"Default Values"},{"location":"usage/parameters/arguments/#alternative-syntax","text":"arc has an alternative syntax fo defining arguments Take this argument from the last example lastname : str = \"Joestar\" Could also be defined as: lastname : str = arc . Argument ( default = \"Joestar\" ) Now, arc.Argument is unnecessary here, but comes with some additional bells and whistles that make it more useful. Some of these features will be explored in future guides, or you check the reference for full details on what it provides .","title":"Alternative Syntax"},{"location":"usage/parameters/counter/","text":"A counter is a special kind of flag , but instead of representing a boolean value, it represents (you guessed it) a count! A count parameter tallies the number of times that is used on the command line. examples/parameter_count.py import arc @arc . command def hello ( firstname : str , repeat : int = arc . Count ()): arc . print ( f \"Repeat { repeat } time(s)\" ) for _ in range ( 0 , repeat ): arc . print ( f \"Hello, { firstname } ! Hope you have a wonderful day!\" ) hello () $ python parameter_count.py Joseph Repeat 0 time(s) $ python parameter_count.py Joseph --repeat Repeat 1 time(s) Hello, Joseph! Hope you have a wonderful day! $ python parameter_count.py Joseph --repeat --repeat Repeat 2 time(s) Hello, Joseph! Hope you have a wonderful day! Hello, Joseph! Hope you have a wonderful day!","title":"Counter"},{"location":"usage/parameters/dependancy-injection/","text":"arc supports a simple dependency injection system for commands. examples/dependency.py import arc def dep ( ctx : arc . Context ) -> int : return 2 @arc . command () def command ( value : int = arc . Depends ( dep )): arc . print ( value ) command () $ python dependency.py 2 Note that arguments whose values are discovered via dependency injection do not have associated command line parameters. You can see this by inspecting the --help for the command. $ python dependency.py --help USAGE dependency.py [-h] OPTIONS --help (-h) Displays this help message No value argument! Type dependencies \u00b6 A type can be denoted to be a dependency by implementing the __depends__ () class method. examples/type_dependency.py import arc class Dependency : def __init__ ( self , value : int ) -> None : self . value = value @classmethod def __depends__ ( cls , ctx : arc . Context ): return Dependency ( 2 ) @arc . command () def command ( dep : Dependency ): arc . print ( dep ) arc . print ( dep . value ) command () $ python type_dependency.py <Dependency object at 0x7f0799f846a0> 2 Warning If you implement this method, then this type cannot be used as the type of any other kind of parameter. arc uses this feature to make various components available to your commands: arc.Context arc.prompt.Prompt arc.types.State","title":"Dependency Injection"},{"location":"usage/parameters/dependancy-injection/#type-dependencies","text":"A type can be denoted to be a dependency by implementing the __depends__ () class method. examples/type_dependency.py import arc class Dependency : def __init__ ( self , value : int ) -> None : self . value = value @classmethod def __depends__ ( cls , ctx : arc . Context ): return Dependency ( 2 ) @arc . command () def command ( dep : Dependency ): arc . print ( dep ) arc . print ( dep . value ) command () $ python type_dependency.py <Dependency object at 0x7f0799f846a0> 2 Warning If you implement this method, then this type cannot be used as the type of any other kind of parameter. arc uses this feature to make various components available to your commands: arc.Context arc.prompt.Prompt arc.types.State","title":"Type dependencies"},{"location":"usage/parameters/flags/","text":"Flags are similar to options as they are referenced by name, but they can only represent a boolean value (True / False) and do not recieve an associated value. Flags are defined by annotating an argument with the bool type. examples/parameter_flag.py import arc @arc . command def hello ( firstname : str , reverse : bool ): if reverse : firstname = firstname [:: - 1 ] arc . print ( f \"Hello, { firstname } ! Hope you have a wonderful day!\" ) hello () $ python parameter_flag.py Joseph Hello, Joseph! Hope you have a wonderful day! $ python parameter_flag.py Joseph --reverse Hello, hpesoJ! Hope you have a wonderful day! Default Values Unlike arguments and options, flags are always optional. Thie is because they can only represent two possible values (True / False). Absence of the flag implies False; presence of the flag implies True. If a flag is given a default of True then this relationship is inversed. Alternative Syntax \u00b6 Once again, like arguments and options , flags also have an alternative syntax reverse : bool reverse = arc . Flag () The bool type is no longer required, but it's still generally recommended Check the reference for all the options that arc.Flag() can recieve","title":"Flags"},{"location":"usage/parameters/flags/#alternative-syntax","text":"Once again, like arguments and options , flags also have an alternative syntax reverse : bool reverse = arc . Flag () The bool type is no longer required, but it's still generally recommended Check the reference for all the options that arc.Flag() can recieve","title":"Alternative Syntax"},{"location":"usage/parameters/groups/","text":"Parameter groups allow you to (as the name implies!) group parameters into re-usable chunks. A parameter group can then be used for multiple commands, and each of those commands will have all of those params defined. Creating A group \u00b6 Parameter groups are fairly simple to create, you just need to decorate a class with the @arc . group decorator. @arc . group class MyGroup : ... Adding Parameters to a group \u00b6 Now, to make a group useful , we need to actually add parameters to it. To do so, we add class-variables with our desired parameter definitions. For example, let's take this example from the flags page: examples/parameter_flag.py import arc @arc . command def hello ( firstname : str , reverse : bool ): if reverse : firstname = firstname [:: - 1 ] arc . print ( f \"Hello, { firstname } ! Hope you have a wonderful day!\" ) hello () and convert it to use a parameter group instead. For this example, the transfer is very straight forward, we can just take the argument list definition, and add it to the class body: @arc . group class MyGroup : firstname : str reverse : bool Using a group \u00b6 To use a Parameter Group, all we need to do is add an argument to the argument list of a command, with the param group as the type hint. def hello ( group : MyGroup ): # Don't need firstname or reverse here anymore Putting it together \u00b6 examples/group.py import arc @arc . group class MyGroup : firstname : str reverse : bool @arc . command def hello ( group : MyGroup ): if group . reverse : group . firstname = group . firstname [:: - 1 ] arc . print ( f \"Hello, { group . firstname } ! Hope you have a wonderful day!\" ) hello () $ python group.py --help USAGE group.py [-h] [--reverse] firstname ARGUMENTS firstname OPTIONS --help (-h) Displays this help message --reverse $ python group.py Joseph --reverse Hello, hpesoJ! Hope you have a wonderful day! And just like that, we have a set of re-usable parameters that we can add to any command at-will! Some Notes about param groups Anything that works for regular parameters also works for Parameter groups. This means that arc . Argument () and it's cohorts can be used to expand the use of a parameter in a group. Because there is no bare * or equivelant, there isn't a good way to distinguish between arguments and options. So, any non-flag will be presumed to be an argument unless given an explicit arc . Option () as a default value. Groups are allowed to be nested arbitrarily Param Group Callbacks \u00b6 You may optionally define callbacks on a param group that will be called before or after execution of the command. examples/group_callbacks.py import arc @arc . group class Group : name : str def pre_exec ( self ): arc . print ( \"Before the command executes\" ) def post_exec ( self ): arc . print ( \"After the command executes\" ) @arc . command def command ( group : Group ): arc . print ( f \"Hello, { group . name } \" ) command () $ python group_callbacks.py Jonathan Before the command executes Hello, Jonathan After the command executes Excluding Some Annotations \u00b6 You can exclude certain annotations from being interpreted as parameters examples/group_exclude.py import arc @arc . group ( exclude = [ \"val2\" ]) class Group : val1 : str val2 : str @arc . command def command ( group : Group ): ... command () You can see in the help that val1 is included as a param while val2 is not. $ python group_exclude.py --help USAGE group_exclude.py [-h] val1 ARGUMENTS val1 OPTIONS --help (-h) Displays this help message This is useful when you are assiging some attributes of your param group in the pre_exec () callback mentioned above, but still want type checking applying.","title":"Parameter Groups"},{"location":"usage/parameters/groups/#creating-a-group","text":"Parameter groups are fairly simple to create, you just need to decorate a class with the @arc . group decorator. @arc . group class MyGroup : ...","title":"Creating A group"},{"location":"usage/parameters/groups/#adding-parameters-to-a-group","text":"Now, to make a group useful , we need to actually add parameters to it. To do so, we add class-variables with our desired parameter definitions. For example, let's take this example from the flags page: examples/parameter_flag.py import arc @arc . command def hello ( firstname : str , reverse : bool ): if reverse : firstname = firstname [:: - 1 ] arc . print ( f \"Hello, { firstname } ! Hope you have a wonderful day!\" ) hello () and convert it to use a parameter group instead. For this example, the transfer is very straight forward, we can just take the argument list definition, and add it to the class body: @arc . group class MyGroup : firstname : str reverse : bool","title":"Adding Parameters to a group"},{"location":"usage/parameters/groups/#using-a-group","text":"To use a Parameter Group, all we need to do is add an argument to the argument list of a command, with the param group as the type hint. def hello ( group : MyGroup ): # Don't need firstname or reverse here anymore","title":"Using a group"},{"location":"usage/parameters/groups/#putting-it-together","text":"examples/group.py import arc @arc . group class MyGroup : firstname : str reverse : bool @arc . command def hello ( group : MyGroup ): if group . reverse : group . firstname = group . firstname [:: - 1 ] arc . print ( f \"Hello, { group . firstname } ! Hope you have a wonderful day!\" ) hello () $ python group.py --help USAGE group.py [-h] [--reverse] firstname ARGUMENTS firstname OPTIONS --help (-h) Displays this help message --reverse $ python group.py Joseph --reverse Hello, hpesoJ! Hope you have a wonderful day! And just like that, we have a set of re-usable parameters that we can add to any command at-will! Some Notes about param groups Anything that works for regular parameters also works for Parameter groups. This means that arc . Argument () and it's cohorts can be used to expand the use of a parameter in a group. Because there is no bare * or equivelant, there isn't a good way to distinguish between arguments and options. So, any non-flag will be presumed to be an argument unless given an explicit arc . Option () as a default value. Groups are allowed to be nested arbitrarily","title":"Putting it together"},{"location":"usage/parameters/groups/#param-group-callbacks","text":"You may optionally define callbacks on a param group that will be called before or after execution of the command. examples/group_callbacks.py import arc @arc . group class Group : name : str def pre_exec ( self ): arc . print ( \"Before the command executes\" ) def post_exec ( self ): arc . print ( \"After the command executes\" ) @arc . command def command ( group : Group ): arc . print ( f \"Hello, { group . name } \" ) command () $ python group_callbacks.py Jonathan Before the command executes Hello, Jonathan After the command executes","title":"Param Group Callbacks"},{"location":"usage/parameters/groups/#excluding-some-annotations","text":"You can exclude certain annotations from being interpreted as parameters examples/group_exclude.py import arc @arc . group ( exclude = [ \"val2\" ]) class Group : val1 : str val2 : str @arc . command def command ( group : Group ): ... command () You can see in the help that val1 is included as a param while val2 is not. $ python group_exclude.py --help USAGE group_exclude.py [-h] val1 ARGUMENTS val1 OPTIONS --help (-h) Displays this help message This is useful when you are assiging some attributes of your param group in the pre_exec () callback mentioned above, but still want type checking applying.","title":"Excluding Some Annotations"},{"location":"usage/parameters/intro/","text":"In arc , command-line parameters are defined using Python function arguments. This sub-section of the documentation is dedicated to talking about all the components of command line arguments in arc . Kinds of Parameters \u00b6 There are several kinds of parameters that arc allows you the define. Each of them have their own page that goes into detail on their usage, but here's a quick rundown Arguments are provided on the command line positionally. For example the filenames in grep filename1 filename2 would be arc arguments. Options are (generally optional, hence the name) parameters that are provided on the command line by-name. For example, in grep --file <FILENAME> , file would be an arc option Flags indicate a boolean value. For example, in grep --invert-match , --invert-match could be represented as an arc flag. Counters are flags that instead of keeping track of whether or not they've been provided, they keep track of the number of times they've been provided Parameter Sources \u00b6 The value for a parameter can come from multiple different sources, if no value is found in the input, these places can be checked: Enviorment Variables Input Prompt Getter Function Defalt Values For more info Parameter Types \u00b6 arc uses type hints types for type validation / conversion. See more here Additional Features \u00b6 Parameter Groups Parameter Sources","title":"Parameters Intro"},{"location":"usage/parameters/intro/#kinds-of-parameters","text":"There are several kinds of parameters that arc allows you the define. Each of them have their own page that goes into detail on their usage, but here's a quick rundown Arguments are provided on the command line positionally. For example the filenames in grep filename1 filename2 would be arc arguments. Options are (generally optional, hence the name) parameters that are provided on the command line by-name. For example, in grep --file <FILENAME> , file would be an arc option Flags indicate a boolean value. For example, in grep --invert-match , --invert-match could be represented as an arc flag. Counters are flags that instead of keeping track of whether or not they've been provided, they keep track of the number of times they've been provided","title":"Kinds of Parameters"},{"location":"usage/parameters/intro/#parameter-sources","text":"The value for a parameter can come from multiple different sources, if no value is found in the input, these places can be checked: Enviorment Variables Input Prompt Getter Function Defalt Values For more info","title":"Parameter Sources"},{"location":"usage/parameters/intro/#parameter-types","text":"arc uses type hints types for type validation / conversion. See more here","title":"Parameter Types"},{"location":"usage/parameters/intro/#additional-features","text":"Parameter Groups Parameter Sources","title":"Additional Features"},{"location":"usage/parameters/options/","text":"An arc option is a (usually optional) parameter that is referenced by name on the command line. We can take the example from the previous page and convert both of the arguments to options by only adding 2 characters: examples/parameter_option.py import arc @arc . command def hello ( * , firstname : str , lastname : str | None ): name = firstname if lastname : name += f \" { lastname } \" arc . print ( f \"Hello, { name } ! Hope you have a wonderful day!\" ) hello () Now we can run it, but we must reference each argument by name (prefixed with -- ) $ python parameter_option.py --firstname Joesph --lastname Joestar Hello, Joesph Joestar! Hope you have a wonderful day! Notice the difference? We've added a *, to the start of the argument list. In Python, any argument that comes after a bare * is a keyword-only argument . In arc , this indicates that the arguments are options . Documentation \u00b6 $ python parameter_option.py --help USAGE parameter_option.py [-h] [--lastname LASTNAME] --firstname FIRSTNAME OPTIONS --help (-h) Displays this help message --firstname --lastname Note lastname appears before firstname in the USAGE because arc sorts optionals first Alternative Syntax \u00b6 Like arguments , options also have an alternative syntax. Taking the function definition above: def hello ( * , firstname : str , lastname : str | None ): We could also have written it as: def hello ( firstname : str = arc . Option (), lastname : str | None = arc . Option () ): Note that the base * is no longer present. When arc . Option () is present, it is no longer required because you are explictly telling arc what kind of parameter it is. However, it is still allowed. Check the reference for a full rundown of the capabilities","title":"Options"},{"location":"usage/parameters/options/#documentation","text":"$ python parameter_option.py --help USAGE parameter_option.py [-h] [--lastname LASTNAME] --firstname FIRSTNAME OPTIONS --help (-h) Displays this help message --firstname --lastname Note lastname appears before firstname in the USAGE because arc sorts optionals first","title":"Documentation"},{"location":"usage/parameters/options/#alternative-syntax","text":"Like arguments , options also have an alternative syntax. Taking the function definition above: def hello ( * , firstname : str , lastname : str | None ): We could also have written it as: def hello ( firstname : str = arc . Option (), lastname : str | None = arc . Option () ): Note that the base * is no longer present. When arc . Option () is present, it is no longer required because you are explictly telling arc what kind of parameter it is. However, it is still allowed. Check the reference for a full rundown of the capabilities","title":"Alternative Syntax"},{"location":"usage/parameters/sources/","text":"While generally, input is parsed from the command line, there are a few other sources that parameters can recieve values from The precedence of sources is: Command Argument Command Line Environment Variables Input Prompt Getter Function Default Value Type Conversion All input sources, except for default values and getter functions, will still pass through the type conversion systems that arc provides. So you're free to use int , float , bool , or any other type that you've defined. arc will handle the conversion from enviroment variables and input prompts for you. Command Argument \u00b6 When an arc command is executed it will check sys . argv for input. However, you can actually provide explcit input as the first argument to call: examples/command_string.py import arc @arc . command def hello ( name : str ): arc . print ( f \"Hello { name } !\" ) hello ( \"Sean\" ) $ python command_string.py Hello Sean! You generally don't need to do this, but it's useful for when you want to test your interface. (In fact, that's how pretty much all of arc's own tests are defined). Note that the command string is treated as if it was the command line input, so if the command string is provided, sys.argv will be ignored. Command Line \u00b6 This is the default you're probably used to. If you provide an argument on the command line, it will be parsed as the value for that parameter. examples/hello.py import arc @arc . command def hello ( name : str ): \"\"\"Greets someone by name\"\"\" arc . print ( f \"Hello { name } !\" ) hello () $ python hello.py Joseph Hello Joseph! Environment Variables \u00b6 examples/from_env.py import arc import os os . environ [ \"VAL\" ] = \"2\" @arc . command def command ( val : int = arc . Argument ( envvar = \"VAL\" )): arc . print ( f \"VAL: { val } \" ) command () Now, if the argument isn't present on the command line, it will be parsed from the environment variable VAL $ python from_env.py VAL: 2 $ python from_env.py 10 VAL: 10 Input Prompt \u00b6 If there is no input provided on the command line for name (and there was no enviroment variable), arc will prompt the user for input. examples/from_prompt.py import arc @arc . command def command ( name : str = arc . Argument ( prompt = \"What is your first name? \" )): arc . print ( \"Hello, \" + name ) command () $ python from_prompt.py Jolyne Hello, Jolyne $ python from_prompt.py What is your name? Jolyne Hello, Jolyne If the parameter is optional, the user will be still be prompted, but the user can enter an empty input by just pressing Enter and the default will be used. You can customize the prompt via a configuration parameter. Getter Function \u00b6 Getter functions are a way to provide a default for an argument, based on the result of a function call. examples/from_getter.py import arc def get_default_name (): return \"Josuke\" @arc . command def command ( name : str = arc . Argument ( get = get_default_name )): arc . print ( f \"Good morning { name } \" ) command () $ python from_getter.py Sean Good morning Sean $ python from_getter.py Good morning Josuke Different Syntax \u00b6 Getter functions may also be defined using this decorator syntax examples/from_getter_alias.py import arc @arc . command def command ( name : str = arc . Argument ()): arc . print ( f \"Good morning { name } \" ) @command . get ( \"name\" ) def get_default_name (): return \"Josuke\" command () Default Value \u00b6 If none of the above are satisfied first, arc will check for a default value of your parameter. examples/parameter_default.py import arc @arc . command def hello ( firstname : str , lastname : str = \"Joestar\" ): name = f \" { firstname } { lastname } \" arc . print ( f \"Hello, { name } ! Hope you have a wonderful day!\" ) hello () $ python parameter_default.py Sean Hello, Sean Joestar! Hope you have a wonderful day! $ python parameter_default.py Sean Collings Hello, Sean Collings! Hope you have a wonderful day! If there is no default (like with firstname above), arc will emit an error $ python parameter_default.py USAGE parameter_default.py [-h] firstname [lastname] The following arguments are required: firstname Checking origin of parameter value \u00b6 You can check what the origin of a value is like this: examples/origins.py import arc @arc . command () def command ( ctx : arc . Context , value : int = 2 ): origin = ctx . get_origin ( \"value\" ) arc . print ( value , origin ) command () $ python origins.py 2 default $ python origins.py 10 10 command_line","title":"Parameter Sources"},{"location":"usage/parameters/sources/#command-argument","text":"When an arc command is executed it will check sys . argv for input. However, you can actually provide explcit input as the first argument to call: examples/command_string.py import arc @arc . command def hello ( name : str ): arc . print ( f \"Hello { name } !\" ) hello ( \"Sean\" ) $ python command_string.py Hello Sean! You generally don't need to do this, but it's useful for when you want to test your interface. (In fact, that's how pretty much all of arc's own tests are defined). Note that the command string is treated as if it was the command line input, so if the command string is provided, sys.argv will be ignored.","title":"Command Argument"},{"location":"usage/parameters/sources/#command-line","text":"This is the default you're probably used to. If you provide an argument on the command line, it will be parsed as the value for that parameter. examples/hello.py import arc @arc . command def hello ( name : str ): \"\"\"Greets someone by name\"\"\" arc . print ( f \"Hello { name } !\" ) hello () $ python hello.py Joseph Hello Joseph!","title":"Command Line"},{"location":"usage/parameters/sources/#environment-variables","text":"examples/from_env.py import arc import os os . environ [ \"VAL\" ] = \"2\" @arc . command def command ( val : int = arc . Argument ( envvar = \"VAL\" )): arc . print ( f \"VAL: { val } \" ) command () Now, if the argument isn't present on the command line, it will be parsed from the environment variable VAL $ python from_env.py VAL: 2 $ python from_env.py 10 VAL: 10","title":"Environment Variables"},{"location":"usage/parameters/sources/#input-prompt","text":"If there is no input provided on the command line for name (and there was no enviroment variable), arc will prompt the user for input. examples/from_prompt.py import arc @arc . command def command ( name : str = arc . Argument ( prompt = \"What is your first name? \" )): arc . print ( \"Hello, \" + name ) command () $ python from_prompt.py Jolyne Hello, Jolyne $ python from_prompt.py What is your name? Jolyne Hello, Jolyne If the parameter is optional, the user will be still be prompted, but the user can enter an empty input by just pressing Enter and the default will be used. You can customize the prompt via a configuration parameter.","title":"Input Prompt"},{"location":"usage/parameters/sources/#getter-function","text":"Getter functions are a way to provide a default for an argument, based on the result of a function call. examples/from_getter.py import arc def get_default_name (): return \"Josuke\" @arc . command def command ( name : str = arc . Argument ( get = get_default_name )): arc . print ( f \"Good morning { name } \" ) command () $ python from_getter.py Sean Good morning Sean $ python from_getter.py Good morning Josuke","title":"Getter Function"},{"location":"usage/parameters/sources/#different-syntax","text":"Getter functions may also be defined using this decorator syntax examples/from_getter_alias.py import arc @arc . command def command ( name : str = arc . Argument ()): arc . print ( f \"Good morning { name } \" ) @command . get ( \"name\" ) def get_default_name (): return \"Josuke\" command ()","title":"Different Syntax"},{"location":"usage/parameters/sources/#default-value","text":"If none of the above are satisfied first, arc will check for a default value of your parameter. examples/parameter_default.py import arc @arc . command def hello ( firstname : str , lastname : str = \"Joestar\" ): name = f \" { firstname } { lastname } \" arc . print ( f \"Hello, { name } ! Hope you have a wonderful day!\" ) hello () $ python parameter_default.py Sean Hello, Sean Joestar! Hope you have a wonderful day! $ python parameter_default.py Sean Collings Hello, Sean Collings! Hope you have a wonderful day! If there is no default (like with firstname above), arc will emit an error $ python parameter_default.py USAGE parameter_default.py [-h] firstname [lastname] The following arguments are required: firstname","title":"Default Value"},{"location":"usage/parameters/sources/#checking-origin-of-parameter-value","text":"You can check what the origin of a value is like this: examples/origins.py import arc @arc . command () def command ( ctx : arc . Context , value : int = 2 ): origin = ctx . get_origin ( \"value\" ) arc . print ( value , origin ) command () $ python origins.py 2 default $ python origins.py 10 10 command_line","title":"Checking origin of parameter value"},{"location":"usage/parameters/types/custom-types/","text":"Implement Your Own Type \u00b6 By implementing a simple protocol, your custom classes can be easily used as the type of an arc parameter. Example \u00b6 When implementing your own types, you can make them compatible with arc by implementing the __convert__ () class method. arc will call this with the input from the command line (or some other source ), and you are expected to parse the input and return an instance of the type. For example, custom_type.py import arc class CustomType : def __init__ ( self , val : int ): self . val = val def __str__ ( self ): return f \"CustomType(val= { self . val } )\" @classmethod def __convert__ ( cls , value : str ): if value . isnumeric (): return cls ( int ( value )) else : raise arc . ConversionError ( value , \"must be an integer\" ) @arc . command def main ( foo : CustomType ): arc . print ( foo ) main () $ python custom_type.py 2 CustomType(val=2) $ python custom_type.py string USAGE custom_type.py [-h] foo invalid value for foo: must be an integer Some notes about custom types: In additon to value , you can also add the following arguments to the signature (in the given order, but the names don't need to match): info : Description of the provided type. Instance of arc . types . TypeInfo Context Managers \u00b6 Any type that is considered a context manager will be opened before the command callback executes, and then closed after the command executes examples/context_manager.py import arc class ContextManager : def __init__ ( self , value ) -> None : self . value = value def __enter__ ( self ): arc . print ( \"Entering the Context\" ) return self def __exit__ ( self , * args ): arc . print ( \"Exiting the Context\" ) @classmethod def __convert__ ( cls , value ): return cls ( value ) @arc . command def command ( val : ContextManager ): arc . print ( val ) command () $ python context_manager.py 1 Entering the Context <ContextManager object at 0x7f0799b1a860> Exiting the Context Note Note that the return value of __enter__() is important here, because it is the value that is passed to the command. Type Aliases \u00b6 Type aliases are the way in which arc implements support for builtin and standard library Python types, but can also be used for any type. You can use type aliases to provide support fo any third party library types. For example, supporting numpy arrays import arc from arc.types import Alias import numpy as np # Inherits from Alias. The 'of' parameter declares what types(s) this # alias handles (can be a single type or tuple of types). # Reads like a sentence: \"NDArrayAlias is the Alias of np.ndarray\" class NDArrayAlias ( Alias , of = np . ndarry ): @classmethod def __convert__ ( cls , value : str ): return np . ndarray ( value . split ( \",\" )) @arc . command def main ( array : np . ndarray ): arc . print ( repr ( array )) main () $ python example.py x,y,z array(['x', 'y', 'z'], dtype='<U1') All other principles about custom types hold for alias types. Note that this is a simplified example, a more complete implementation would support the use of generics using numpy . typing","title":"Custom Types"},{"location":"usage/parameters/types/custom-types/#implement-your-own-type","text":"By implementing a simple protocol, your custom classes can be easily used as the type of an arc parameter.","title":"Implement Your Own Type"},{"location":"usage/parameters/types/custom-types/#example","text":"When implementing your own types, you can make them compatible with arc by implementing the __convert__ () class method. arc will call this with the input from the command line (or some other source ), and you are expected to parse the input and return an instance of the type. For example, custom_type.py import arc class CustomType : def __init__ ( self , val : int ): self . val = val def __str__ ( self ): return f \"CustomType(val= { self . val } )\" @classmethod def __convert__ ( cls , value : str ): if value . isnumeric (): return cls ( int ( value )) else : raise arc . ConversionError ( value , \"must be an integer\" ) @arc . command def main ( foo : CustomType ): arc . print ( foo ) main () $ python custom_type.py 2 CustomType(val=2) $ python custom_type.py string USAGE custom_type.py [-h] foo invalid value for foo: must be an integer Some notes about custom types: In additon to value , you can also add the following arguments to the signature (in the given order, but the names don't need to match): info : Description of the provided type. Instance of arc . types . TypeInfo","title":"Example"},{"location":"usage/parameters/types/custom-types/#context-managers","text":"Any type that is considered a context manager will be opened before the command callback executes, and then closed after the command executes examples/context_manager.py import arc class ContextManager : def __init__ ( self , value ) -> None : self . value = value def __enter__ ( self ): arc . print ( \"Entering the Context\" ) return self def __exit__ ( self , * args ): arc . print ( \"Exiting the Context\" ) @classmethod def __convert__ ( cls , value ): return cls ( value ) @arc . command def command ( val : ContextManager ): arc . print ( val ) command () $ python context_manager.py 1 Entering the Context <ContextManager object at 0x7f0799b1a860> Exiting the Context Note Note that the return value of __enter__() is important here, because it is the value that is passed to the command.","title":"Context Managers"},{"location":"usage/parameters/types/custom-types/#type-aliases","text":"Type aliases are the way in which arc implements support for builtin and standard library Python types, but can also be used for any type. You can use type aliases to provide support fo any third party library types. For example, supporting numpy arrays import arc from arc.types import Alias import numpy as np # Inherits from Alias. The 'of' parameter declares what types(s) this # alias handles (can be a single type or tuple of types). # Reads like a sentence: \"NDArrayAlias is the Alias of np.ndarray\" class NDArrayAlias ( Alias , of = np . ndarry ): @classmethod def __convert__ ( cls , value : str ): return np . ndarray ( value . split ( \",\" )) @arc . command def main ( array : np . ndarray ): arc . print ( repr ( array )) main () $ python example.py x,y,z array(['x', 'y', 'z'], dtype='<U1') All other principles about custom types hold for alias types. Note that this is a simplified example, a more complete implementation would support the use of generics using numpy . typing","title":"Type Aliases"},{"location":"usage/parameters/types/supported-types/","text":"This document outlines all of the types that arc supports for parameters. When possible, arc uses builtin and standard library data types. But if no type is available, or the builtin types don't provide the neccessary functionality, arc may implement a custom type. Builtin Types \u00b6 str \u00b6 str ( v ) is used which, in most cases, will be comparable to no change. This is considered the default type is no type is specified. int \u00b6 arc uses int ( v ) to convert the value. Note that decimal input ( 1.4 ) will result in an error, not a narrowing operation. float \u00b6 Likewise, arc uses float ( v ) . Ingeter values will be converted to a float ( 2 -> 2.0 ) bool \u00b6 Used to denote a Flag examples/parameter_flag.py import arc @arc . command def hello ( firstname : str , reverse : bool ): if reverse : firstname = firstname [:: - 1 ] arc . print ( f \"Hello, { firstname } ! Hope you have a wonderful day!\" ) hello () $ python parameter_flag.py Joseph Hello, Joseph! Hope you have a wonderful day! $ python parameter_flag.py Joseph --reverse Hello, hpesoJ! Hope you have a wonderful day! bytes \u00b6 Converted using v . encode () dict \u00b6 Allows a list of comma-seperated key-value pairs. Can be typed generically on both keys and values. dict_argument.py import arc @arc . command def command ( numbers : dict [ str , int ]): arc . print ( numbers ) command () $ python dict_argument.py one = 1 ,two = 2 ,three = 3 {'one': 1, 'two': 2, 'three': 3} Collection Types \u00b6 arc allows you to collect multiple values from the command line into a single argument for your comamnd. To do this, you use the collection types: list , set and tuple list \u00b6 list_argument.py import arc @arc . command def main ( names : list ): for name in names : arc . print ( name ) main () $ python list_argument.py Jonathen Joseph Jotaro Jonathen Joseph Jotaro Because list can accept any number of values, you won't be able to add additional arguments after names . Any other positional arguments would have to come before names . set \u00b6 Similar to list , but will filter out any non-unique elements. set_argument.py import arc @arc . command def main ( vals : set ): arc . print ( \"Unique values:\" ) arc . print ( \" \\n \" . join ( vals )) main () $ python set_argument.py 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 Unique values: 2 3 1 4 tuple \u00b6 Similar to list , but with some additional functionality. According to PEP 484: tuple represents an arbitrarily sized tuple of any type. In arc , this will behave the same as list tuple [ int , ... ] represents an arbitrarily sized tuple of integers. In arc , this will behave the same as list [ int ] tuple [ int , int ] represents a size-two tuple of integers. In arc , this behavior is unique to tuple as the parameter will only select 2 values from input. Sub Typing \u00b6 Collections can be sub-typed so that each item will be converted to the proper type: sum.py import arc @arc . command def main ( nums : list [ int ]): arc . print ( \"The total is: \" , sum ( nums )) main () $ python sum.py 1 2 3 4 5 6 7 8 9 The total is: 45 Collections as Options \u00b6 When used as an option, it allows the option to be used multiple times: list_option.py import arc @arc . command def main ( * , names : list ): for name in names : arc . print ( name ) main () $ python list_option.py --names Josuke --names Giorno --names Joylene Josuke Giorno Joylene Collection Lengths \u00b6 You can specify how many items should be provided to a collection type with a type validator , specifically Len () examples/length.py from typing import Annotated import arc from arc.types.middleware import Len @arc . command () def command ( vals : Annotated [ list [ int ], Len ( 2 , 10 )]): arc . print ( vals ) command () $ python length.py 1 2 3 4 5 6 [1, 2, 3, 4, 5, 6] $ python length.py 1 USAGE length.py [-h] vals [vals...] invalid value for vals: expects between 2 and 10 arguments Standard Library Types \u00b6 typing . Any \u00b6 Equivelant to str typing . TypedDict \u00b6 Constrains a dictionary input to a specific subset of keys and specific value types. typing . Union \u00b6 Allows the input to be multiple different types. examples/union_argument.py from typing import Union import arc @arc . command def main ( number : Union [ int , str ]): arc . print ( type ( number )) main () $ python union_argument.py 5 <class 'int'> $ python union_argument.py hello <class 'str'> arc will attempt to coerce the input into each type, from left to right. The first to succeed will be passed along to the command. Warning You cannot have a type like typing . Union [ list , int ] as collection types need to be known at definition of a command rather than during data validation. Python 3.10's union syntax is also valid: int | str pathlib . Path \u00b6 Path won't perform any validation checks to assert that the input is a valid path, but it just offers the convenience of working with path objects rather than strings. Check the ValidPath custom type for additional validations ipaddress . IPv4Address \u00b6 Uses ipaddress . IPv4Address ( v ) for conversion, so anything valid there is valid here. ipaddress . IPv6Address \u00b6 Same as above re . Pattern \u00b6 Compile a regular expression using re . compile () datetime . datetime \u00b6 Convert string input to a datetime object Type Arguments \u00b6 You can provide the expected format of the datetime string via a type argument: examples/dates.py from typing import Annotated import arc from arc import types import datetime @arc . command def command ( date : Annotated [ datetime . datetime , types . DateTimeArgs ( \"%Y-%m- %d \" )]): arc . print ( date ) command () $ python dates.py 2022 -01-01 2022-01-01 00:00:00 datetime . date \u00b6 Convert string input to a date object. types.DateArgs is equivalent to the above example. datetime . time \u00b6 Convert string input to a time object types.TimeArgs is equivalent to the above example. Constrained Input \u00b6 typing . Literal \u00b6 Enforces that the input must be a specific sub-set of values examples/literal_argument.py from typing import Literal import arc @arc . command def main ( word : Literal [ \"foo\" , \"bar\" , 1 ]): arc . print ( word , type ( word )) main () $ python literal_argument.py foo foo <class 'str'> $ python literal_argument.py 1 1 <class 'int'> $ python literal_argument.py other USAGE literal_argument.py [-h] word invalid value for word: must be foo, bar or 1 Note arc compares the input to the string-ified version of each value in the Literal. So for the second example above, the comparison that succedded was \"1\" == \"1\" not 1 == 1 . enum . Enum \u00b6 Similar to typing . Literal , restricts the input to a specific sub-set of values examples/paint.py from enum import Enum import arc arc . configure ( autocomplete = True ) class Color ( Enum ): RED = \"red\" YELLOW = \"yellow\" GREEN = \"green\" # Could also use: # Color = Literal[\"red\", \"yellow\", \"green\"] @arc . command def paint ( color : Color ): if color is Color . RED : arc . print ( \"You painted the walls the bloodiest of reds\" ) elif color is Color . YELLOW : arc . print ( \"You painted the walls the most fabulous yellow\" ) else : arc . print ( \"You painted the walls the deepest of greens\" ) paint () $ python paint.py red You painted the walls the bloodiest of reds $ python paint.py blue USAGE paint.py [-h] [--autocomplete AUTOCOMPLETE] color invalid value for color: must be red, yellow or green arc Types \u00b6 arc provides a variety of additional types exported from the arc . types module: Warning arc types are sort of weird in the general Python sense. While it will become more aparent later as to why this is the case, know that you cannot usually create the types on your own and have the expected behavior. If you do need / want to do this, you can use: arc . convert ( < value > , < type > ) Context \u00b6 Annotating an argument with this gives you access to the current execution context. State \u00b6 Reference State for details Prompt \u00b6 Gives you access to a Prompt instance SemVer \u00b6 A type to support semantically-versioned strings based on the spec found here User ( *NIX ONLY ) \u00b6 A representation of a *nix user. The input should be the name of the *nix user. Group ( *NIX ONLY ) \u00b6 A representation of a *nix group. The input should be the name of the *nix group. File System Types \u00b6 File \u00b6 One of the most common things that a CLI tool is likely to do, is take in a file name as input, and interact with that file in some way. arc's advanced typing system makes this trivial, with the details around ensuring the file exists, opening it, and closing it handled by arc for you. arc provides this functionality through its arc . types . File type. Let's use it to read out the first line of the source code's README. examples/file.py import arc from arc.types import File @arc . command def command ( file : File . Read ): arc . print ( file . readline ()) command () $ python file.py README.md # ARC There are constants defined on File (like File.Read above) for all common actions ( Read , Write , Append , ReadWrite , etc...). You can view them all in the reference ValidPath \u00b6 pathlib . Path but asserts that the provided path actually exists FilePath \u00b6 pathlib . Path but asserts that the path both exists and is a file DirectoryPath \u00b6 pathlib . Path but asserts that the path both exists and is a directory Networking Types \u00b6 IpAddress \u00b6 Union type for IPv4Address and IPv6Address Url \u00b6 Parses the strings input using urllib . parse . urlparse HttpUrl \u00b6 Url that asserts the scheme to be http or https WebSocketUrl \u00b6 Url that asserts the scheme to be wss FtpUrl \u00b6 Url that asserts the scheme to be ftp MysqlUrl \u00b6 Url that asserts the scheme to be `mysql PostgresUrl \u00b6 Url that checks that it is a valid PostgreSQL URL Number Types \u00b6 Note For any types that simply change the base of the input (like Binary or Hex ), it is essentially equivelant to int(v, base=<base>) . Binary \u00b6 Accepts integers as binary stings ( 0101010110 ). Oct \u00b6 Accepts integers in base 8 Hex \u00b6 Accepts integers in base 16 PositveInt \u00b6 Enforces that the integer must be greater than 0 NegativeInt \u00b6 Enforces that the integer must be less than 0 PositveFloat \u00b6 Enforces that the float must be greater than 0 NegativeFloat \u00b6 Enforces that the float must be less than 0 AnyNumber \u00b6 Accepts floats, and integers in any base. String Types \u00b6 Char \u00b6 Enforces that the string can only be a single character long Password \u00b6 When prompted for input, the user's input will not be echoed to the screen. Email \u00b6 Enforces that the string is a valid email address","title":"Supported Types"},{"location":"usage/parameters/types/supported-types/#builtin-types","text":"","title":"Builtin Types"},{"location":"usage/parameters/types/supported-types/#str","text":"str ( v ) is used which, in most cases, will be comparable to no change. This is considered the default type is no type is specified.","title":"str"},{"location":"usage/parameters/types/supported-types/#int","text":"arc uses int ( v ) to convert the value. Note that decimal input ( 1.4 ) will result in an error, not a narrowing operation.","title":"int"},{"location":"usage/parameters/types/supported-types/#float","text":"Likewise, arc uses float ( v ) . Ingeter values will be converted to a float ( 2 -> 2.0 )","title":"float"},{"location":"usage/parameters/types/supported-types/#bool","text":"Used to denote a Flag examples/parameter_flag.py import arc @arc . command def hello ( firstname : str , reverse : bool ): if reverse : firstname = firstname [:: - 1 ] arc . print ( f \"Hello, { firstname } ! Hope you have a wonderful day!\" ) hello () $ python parameter_flag.py Joseph Hello, Joseph! Hope you have a wonderful day! $ python parameter_flag.py Joseph --reverse Hello, hpesoJ! Hope you have a wonderful day!","title":"bool"},{"location":"usage/parameters/types/supported-types/#bytes","text":"Converted using v . encode ()","title":"bytes"},{"location":"usage/parameters/types/supported-types/#dict","text":"Allows a list of comma-seperated key-value pairs. Can be typed generically on both keys and values. dict_argument.py import arc @arc . command def command ( numbers : dict [ str , int ]): arc . print ( numbers ) command () $ python dict_argument.py one = 1 ,two = 2 ,three = 3 {'one': 1, 'two': 2, 'three': 3}","title":"dict"},{"location":"usage/parameters/types/supported-types/#collection-types","text":"arc allows you to collect multiple values from the command line into a single argument for your comamnd. To do this, you use the collection types: list , set and tuple","title":"Collection Types"},{"location":"usage/parameters/types/supported-types/#list","text":"list_argument.py import arc @arc . command def main ( names : list ): for name in names : arc . print ( name ) main () $ python list_argument.py Jonathen Joseph Jotaro Jonathen Joseph Jotaro Because list can accept any number of values, you won't be able to add additional arguments after names . Any other positional arguments would have to come before names .","title":"list"},{"location":"usage/parameters/types/supported-types/#set","text":"Similar to list , but will filter out any non-unique elements. set_argument.py import arc @arc . command def main ( vals : set ): arc . print ( \"Unique values:\" ) arc . print ( \" \\n \" . join ( vals )) main () $ python set_argument.py 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 Unique values: 2 3 1 4","title":"set"},{"location":"usage/parameters/types/supported-types/#tuple","text":"Similar to list , but with some additional functionality. According to PEP 484: tuple represents an arbitrarily sized tuple of any type. In arc , this will behave the same as list tuple [ int , ... ] represents an arbitrarily sized tuple of integers. In arc , this will behave the same as list [ int ] tuple [ int , int ] represents a size-two tuple of integers. In arc , this behavior is unique to tuple as the parameter will only select 2 values from input.","title":"tuple"},{"location":"usage/parameters/types/supported-types/#sub-typing","text":"Collections can be sub-typed so that each item will be converted to the proper type: sum.py import arc @arc . command def main ( nums : list [ int ]): arc . print ( \"The total is: \" , sum ( nums )) main () $ python sum.py 1 2 3 4 5 6 7 8 9 The total is: 45","title":"Sub Typing"},{"location":"usage/parameters/types/supported-types/#collections-as-options","text":"When used as an option, it allows the option to be used multiple times: list_option.py import arc @arc . command def main ( * , names : list ): for name in names : arc . print ( name ) main () $ python list_option.py --names Josuke --names Giorno --names Joylene Josuke Giorno Joylene","title":"Collections as Options"},{"location":"usage/parameters/types/supported-types/#collection-lengths","text":"You can specify how many items should be provided to a collection type with a type validator , specifically Len () examples/length.py from typing import Annotated import arc from arc.types.middleware import Len @arc . command () def command ( vals : Annotated [ list [ int ], Len ( 2 , 10 )]): arc . print ( vals ) command () $ python length.py 1 2 3 4 5 6 [1, 2, 3, 4, 5, 6] $ python length.py 1 USAGE length.py [-h] vals [vals...] invalid value for vals: expects between 2 and 10 arguments","title":"Collection Lengths"},{"location":"usage/parameters/types/supported-types/#standard-library-types","text":"","title":"Standard Library Types"},{"location":"usage/parameters/types/supported-types/#typingany","text":"Equivelant to str","title":"typing.Any"},{"location":"usage/parameters/types/supported-types/#typingtypeddict","text":"Constrains a dictionary input to a specific subset of keys and specific value types.","title":"typing.TypedDict"},{"location":"usage/parameters/types/supported-types/#typingunion","text":"Allows the input to be multiple different types. examples/union_argument.py from typing import Union import arc @arc . command def main ( number : Union [ int , str ]): arc . print ( type ( number )) main () $ python union_argument.py 5 <class 'int'> $ python union_argument.py hello <class 'str'> arc will attempt to coerce the input into each type, from left to right. The first to succeed will be passed along to the command. Warning You cannot have a type like typing . Union [ list , int ] as collection types need to be known at definition of a command rather than during data validation. Python 3.10's union syntax is also valid: int | str","title":"typing.Union"},{"location":"usage/parameters/types/supported-types/#pathlibpath","text":"Path won't perform any validation checks to assert that the input is a valid path, but it just offers the convenience of working with path objects rather than strings. Check the ValidPath custom type for additional validations","title":"pathlib.Path"},{"location":"usage/parameters/types/supported-types/#ipaddressipv4address","text":"Uses ipaddress . IPv4Address ( v ) for conversion, so anything valid there is valid here.","title":"ipaddress.IPv4Address"},{"location":"usage/parameters/types/supported-types/#ipaddressipv6address","text":"Same as above","title":"ipaddress.IPv6Address"},{"location":"usage/parameters/types/supported-types/#repattern","text":"Compile a regular expression using re . compile ()","title":"re.Pattern"},{"location":"usage/parameters/types/supported-types/#datetimedatetime","text":"Convert string input to a datetime object","title":"datetime.datetime"},{"location":"usage/parameters/types/supported-types/#type-arguments","text":"You can provide the expected format of the datetime string via a type argument: examples/dates.py from typing import Annotated import arc from arc import types import datetime @arc . command def command ( date : Annotated [ datetime . datetime , types . DateTimeArgs ( \"%Y-%m- %d \" )]): arc . print ( date ) command () $ python dates.py 2022 -01-01 2022-01-01 00:00:00","title":"Type Arguments"},{"location":"usage/parameters/types/supported-types/#datetimedate","text":"Convert string input to a date object. types.DateArgs is equivalent to the above example.","title":"datetime.date"},{"location":"usage/parameters/types/supported-types/#datetimetime","text":"Convert string input to a time object types.TimeArgs is equivalent to the above example.","title":"datetime.time"},{"location":"usage/parameters/types/supported-types/#constrained-input","text":"","title":"Constrained Input"},{"location":"usage/parameters/types/supported-types/#typingliteral","text":"Enforces that the input must be a specific sub-set of values examples/literal_argument.py from typing import Literal import arc @arc . command def main ( word : Literal [ \"foo\" , \"bar\" , 1 ]): arc . print ( word , type ( word )) main () $ python literal_argument.py foo foo <class 'str'> $ python literal_argument.py 1 1 <class 'int'> $ python literal_argument.py other USAGE literal_argument.py [-h] word invalid value for word: must be foo, bar or 1 Note arc compares the input to the string-ified version of each value in the Literal. So for the second example above, the comparison that succedded was \"1\" == \"1\" not 1 == 1 .","title":"typing.Literal"},{"location":"usage/parameters/types/supported-types/#enumenum","text":"Similar to typing . Literal , restricts the input to a specific sub-set of values examples/paint.py from enum import Enum import arc arc . configure ( autocomplete = True ) class Color ( Enum ): RED = \"red\" YELLOW = \"yellow\" GREEN = \"green\" # Could also use: # Color = Literal[\"red\", \"yellow\", \"green\"] @arc . command def paint ( color : Color ): if color is Color . RED : arc . print ( \"You painted the walls the bloodiest of reds\" ) elif color is Color . YELLOW : arc . print ( \"You painted the walls the most fabulous yellow\" ) else : arc . print ( \"You painted the walls the deepest of greens\" ) paint () $ python paint.py red You painted the walls the bloodiest of reds $ python paint.py blue USAGE paint.py [-h] [--autocomplete AUTOCOMPLETE] color invalid value for color: must be red, yellow or green","title":"enum.Enum"},{"location":"usage/parameters/types/supported-types/#arc-types","text":"arc provides a variety of additional types exported from the arc . types module: Warning arc types are sort of weird in the general Python sense. While it will become more aparent later as to why this is the case, know that you cannot usually create the types on your own and have the expected behavior. If you do need / want to do this, you can use: arc . convert ( < value > , < type > )","title":"arc Types"},{"location":"usage/parameters/types/supported-types/#context","text":"Annotating an argument with this gives you access to the current execution context.","title":"Context"},{"location":"usage/parameters/types/supported-types/#state","text":"Reference State for details","title":"State"},{"location":"usage/parameters/types/supported-types/#prompt","text":"Gives you access to a Prompt instance","title":"Prompt"},{"location":"usage/parameters/types/supported-types/#semver","text":"A type to support semantically-versioned strings based on the spec found here","title":"SemVer"},{"location":"usage/parameters/types/supported-types/#user-nix-only","text":"A representation of a *nix user. The input should be the name of the *nix user.","title":"User (*NIX ONLY)"},{"location":"usage/parameters/types/supported-types/#group-nix-only","text":"A representation of a *nix group. The input should be the name of the *nix group.","title":"Group (*NIX ONLY)"},{"location":"usage/parameters/types/supported-types/#file-system-types","text":"","title":"File System Types"},{"location":"usage/parameters/types/supported-types/#file","text":"One of the most common things that a CLI tool is likely to do, is take in a file name as input, and interact with that file in some way. arc's advanced typing system makes this trivial, with the details around ensuring the file exists, opening it, and closing it handled by arc for you. arc provides this functionality through its arc . types . File type. Let's use it to read out the first line of the source code's README. examples/file.py import arc from arc.types import File @arc . command def command ( file : File . Read ): arc . print ( file . readline ()) command () $ python file.py README.md # ARC There are constants defined on File (like File.Read above) for all common actions ( Read , Write , Append , ReadWrite , etc...). You can view them all in the reference","title":"File"},{"location":"usage/parameters/types/supported-types/#validpath","text":"pathlib . Path but asserts that the provided path actually exists","title":"ValidPath"},{"location":"usage/parameters/types/supported-types/#filepath","text":"pathlib . Path but asserts that the path both exists and is a file","title":"FilePath"},{"location":"usage/parameters/types/supported-types/#directorypath","text":"pathlib . Path but asserts that the path both exists and is a directory","title":"DirectoryPath"},{"location":"usage/parameters/types/supported-types/#networking-types","text":"","title":"Networking Types"},{"location":"usage/parameters/types/supported-types/#ipaddress","text":"Union type for IPv4Address and IPv6Address","title":"IpAddress"},{"location":"usage/parameters/types/supported-types/#url","text":"Parses the strings input using urllib . parse . urlparse","title":"Url"},{"location":"usage/parameters/types/supported-types/#httpurl","text":"Url that asserts the scheme to be http or https","title":"HttpUrl"},{"location":"usage/parameters/types/supported-types/#websocketurl","text":"Url that asserts the scheme to be wss","title":"WebSocketUrl"},{"location":"usage/parameters/types/supported-types/#ftpurl","text":"Url that asserts the scheme to be ftp","title":"FtpUrl"},{"location":"usage/parameters/types/supported-types/#mysqlurl","text":"Url that asserts the scheme to be `mysql","title":"MysqlUrl"},{"location":"usage/parameters/types/supported-types/#postgresurl","text":"Url that checks that it is a valid PostgreSQL URL","title":"PostgresUrl"},{"location":"usage/parameters/types/supported-types/#number-types","text":"Note For any types that simply change the base of the input (like Binary or Hex ), it is essentially equivelant to int(v, base=<base>) .","title":"Number Types"},{"location":"usage/parameters/types/supported-types/#binary","text":"Accepts integers as binary stings ( 0101010110 ).","title":"Binary"},{"location":"usage/parameters/types/supported-types/#oct","text":"Accepts integers in base 8","title":"Oct"},{"location":"usage/parameters/types/supported-types/#hex","text":"Accepts integers in base 16","title":"Hex"},{"location":"usage/parameters/types/supported-types/#positveint","text":"Enforces that the integer must be greater than 0","title":"PositveInt"},{"location":"usage/parameters/types/supported-types/#negativeint","text":"Enforces that the integer must be less than 0","title":"NegativeInt"},{"location":"usage/parameters/types/supported-types/#positvefloat","text":"Enforces that the float must be greater than 0","title":"PositveFloat"},{"location":"usage/parameters/types/supported-types/#negativefloat","text":"Enforces that the float must be less than 0","title":"NegativeFloat"},{"location":"usage/parameters/types/supported-types/#anynumber","text":"Accepts floats, and integers in any base.","title":"AnyNumber"},{"location":"usage/parameters/types/supported-types/#string-types","text":"","title":"String Types"},{"location":"usage/parameters/types/supported-types/#char","text":"Enforces that the string can only be a single character long","title":"Char"},{"location":"usage/parameters/types/supported-types/#password","text":"When prompted for input, the user's input will not be echoed to the screen.","title":"Password"},{"location":"usage/parameters/types/supported-types/#email","text":"Enforces that the string is a valid email address","title":"Email"},{"location":"usage/parameters/types/type-arguments/","text":"Type Arguments are a way for types to recieve additional information that can be used during type conversion. Type arguments are attached to a types using an Annotated type. They will generally take the form of. Annotated [ Type , Type . Args ( ... )] For example, the arc . types . File type uses a type argument to specify the mode to open the file in. from typing import Annotated import arc from arc.types import File @arc . command def read ( file : Annotated [ File , File . Args ( \"r\" )]): print ( file . readline ()) This tells arc that the file parameter should be opened in read mode. Type Aliases For convenience, arc provides several type aliases on the File type with the mode already defined. So the above example could be written as: examples/file.py import arc from arc.types import File @arc . command def command ( file : File . Read ): arc . print ( file . readline ()) command () Note that using the alias doesn't actually prevent your from providing your own type arguments. So the following is also valid: from typing import Annotated import arc from arc.types import File @arc . command def read ( file : Annotated [ File . Read , File . Args ( encoding = \"ascii\" )]): print ( file . readline ()) Check out the source for File . Args () for information on how to define your own type arguments. Non arc types \u00b6 If it's neccessary for a builtin or standard lib type to implement type arguments, they will be provided in the types package. For example: examples/dates.py from typing import Annotated import arc from arc import types import datetime @arc . command def command ( date : Annotated [ datetime . datetime , types . DateTimeArgs ( \"%Y-%m- %d \" )]): arc . print ( date ) command () Currently the following standard lib types have type arguments defined: datetime . datetime : arc . types . DateTimeArgs datetime . date : arc . types . DateArgs datetime . time : arc . types . TimeArgs int : arc . types . IntArgs When to Use Type Arguments \u00b6 Type arguments should be used to provide information that is necessary during type construction . For example: arc . types . File uses a type argument to specify the expected file mode. This is necessary because the File type needs to know the file mode before it can be opened. datetime . datetime type uses a type argument to specify the expected format of the input string. This is necessary because the datetime . datetime type needs to know the format of the input string before it can be converted to a datetime object. In all other cases If the information isn't needed until after the type has been constructed, then you should probably opt for a Type Middleware","title":"Type Arguments"},{"location":"usage/parameters/types/type-arguments/#non-arc-types","text":"If it's neccessary for a builtin or standard lib type to implement type arguments, they will be provided in the types package. For example: examples/dates.py from typing import Annotated import arc from arc import types import datetime @arc . command def command ( date : Annotated [ datetime . datetime , types . DateTimeArgs ( \"%Y-%m- %d \" )]): arc . print ( date ) command () Currently the following standard lib types have type arguments defined: datetime . datetime : arc . types . DateTimeArgs datetime . date : arc . types . DateArgs datetime . time : arc . types . TimeArgs int : arc . types . IntArgs","title":"Non arc types"},{"location":"usage/parameters/types/type-arguments/#when-to-use-type-arguments","text":"Type arguments should be used to provide information that is necessary during type construction . For example: arc . types . File uses a type argument to specify the expected file mode. This is necessary because the File type needs to know the file mode before it can be opened. datetime . datetime type uses a type argument to specify the expected format of the input string. This is necessary because the datetime . datetime type needs to know the format of the input string before it can be converted to a datetime object. In all other cases If the information isn't needed until after the type has been constructed, then you should probably opt for a Type Middleware","title":"When to Use Type Arguments"},{"location":"usage/parameters/types/type-middleware/","text":"arc is based on a middleware design pattern. This also applies to arc's type system to give you further flexibility in defining your APIs. What is a Type Middleware? \u00b6 A Type Middleware is simply a callable object that recieves a value, and then returns a value of the same type. It can be used to modify that value, validate some property of that value, or simply analyze the value and return it. Middlewares fall into a couple of rough categories, and so arc uses specific terms to refer to them. Validator : A middleware that checks the value against some condition. It raises an exception if the condition is not met, and otherwise it returns the original value Transformer : A middleware that modifies the value and returns it. Observer : A middleware that just analyzes the type, but won't every raise an error / manipulate it These terms will be used throughout the rest of this page. Creating a Type Middleware \u00b6 Because middleware are just callables, they are extremely simple to define. For example, we could create a transform middleware that rounds floats to 2 digits. def round2 ( val : float ): return round ( val , 2 ) Tip arc already ships with a Round() transformer, so you wouldn't actually need to implement this one yourself. Using a Type Middleware \u00b6 Type Middleware are attached to a type using an Annotated Type examples/round.py from typing import Annotated import arc # Could use arc.types.middleware.Round() instead # of implementing a custom middleware. def round2 ( val : float ): return round ( val , 2 ) @arc . command def command ( val : Annotated [ float , round2 ]): arc . print ( val ) command () $ python round.py 1 .123456789 1.12 Tip Middlewares are actually why most custom arc types require you to use arc . convert () to convert them properly. A good majority of them are actually just an underlying type + some middleware to provide a validation / conversion step. For example arc . types . PositiveInt is actually just defined as PositiveInt = Annotated [ int , GreaterThan ( 0 )] Builtin Middlewares \u00b6 arc ships with a set of general-use builtin middlewares Validators Transformers Observers Examples \u00b6 Middleware that ensure that a passed in version is greater than the current version examples/new_version.py import typing as t import arc from arc import types def greater_than_previous ( value : types . SemVer , ctx : arc . Context ): current_version : types . SemVer | None = ctx . state . get ( \"curr_version\" ) if not current_version : return value if current_version >= value : raise arc . ValidationError ( f \"New version must be greater than current version ( { current_version } )\" ) return value NewVersion = t . Annotated [ types . SemVer , greater_than_previous ] @arc . command def command ( version : NewVersion ): arc . print ( version ) command ( state = { \"curr_version\" : types . SemVer . parse ( \"1.0.0\" )}) $ python new_version.py 0 .1.1 USAGE new_version.py [-h] version invalid value for version: New version must be greater than current version (1.0.0) $ python new_version.py 1 .2.1 1.2.1","title":"Type Middleware"},{"location":"usage/parameters/types/type-middleware/#what-is-a-type-middleware","text":"A Type Middleware is simply a callable object that recieves a value, and then returns a value of the same type. It can be used to modify that value, validate some property of that value, or simply analyze the value and return it. Middlewares fall into a couple of rough categories, and so arc uses specific terms to refer to them. Validator : A middleware that checks the value against some condition. It raises an exception if the condition is not met, and otherwise it returns the original value Transformer : A middleware that modifies the value and returns it. Observer : A middleware that just analyzes the type, but won't every raise an error / manipulate it These terms will be used throughout the rest of this page.","title":"What is a Type Middleware?"},{"location":"usage/parameters/types/type-middleware/#creating-a-type-middleware","text":"Because middleware are just callables, they are extremely simple to define. For example, we could create a transform middleware that rounds floats to 2 digits. def round2 ( val : float ): return round ( val , 2 ) Tip arc already ships with a Round() transformer, so you wouldn't actually need to implement this one yourself.","title":"Creating a Type Middleware"},{"location":"usage/parameters/types/type-middleware/#using-a-type-middleware","text":"Type Middleware are attached to a type using an Annotated Type examples/round.py from typing import Annotated import arc # Could use arc.types.middleware.Round() instead # of implementing a custom middleware. def round2 ( val : float ): return round ( val , 2 ) @arc . command def command ( val : Annotated [ float , round2 ]): arc . print ( val ) command () $ python round.py 1 .123456789 1.12 Tip Middlewares are actually why most custom arc types require you to use arc . convert () to convert them properly. A good majority of them are actually just an underlying type + some middleware to provide a validation / conversion step. For example arc . types . PositiveInt is actually just defined as PositiveInt = Annotated [ int , GreaterThan ( 0 )]","title":"Using a Type Middleware"},{"location":"usage/parameters/types/type-middleware/#builtin-middlewares","text":"arc ships with a set of general-use builtin middlewares Validators Transformers Observers","title":"Builtin Middlewares"},{"location":"usage/parameters/types/type-middleware/#examples","text":"Middleware that ensure that a passed in version is greater than the current version examples/new_version.py import typing as t import arc from arc import types def greater_than_previous ( value : types . SemVer , ctx : arc . Context ): current_version : types . SemVer | None = ctx . state . get ( \"curr_version\" ) if not current_version : return value if current_version >= value : raise arc . ValidationError ( f \"New version must be greater than current version ( { current_version } )\" ) return value NewVersion = t . Annotated [ types . SemVer , greater_than_previous ] @arc . command def command ( version : NewVersion ): arc . print ( version ) command ( state = { \"curr_version\" : types . SemVer . parse ( \"1.0.0\" )}) $ python new_version.py 0 .1.1 USAGE new_version.py [-h] version invalid value for version: New version must be greater than current version (1.0.0) $ python new_version.py 1 .2.1 1.2.1","title":"Examples"},{"location":"usage/parameters/types/types-intro/","text":"arc uses argument type hints for data validation / conversion. For example, say we want to write a command that can sum two numbers together: examples/add.py import arc @arc . command def add ( val1 : int , val2 : int ): arc . print ( f \"The answer is: { val1 + val2 } \" ) add () $ python add.py 5 10 The answer is: 15 if the input fails to validate, arc will report a user-friendly error for the type $ python add.py 5 not-a-number USAGE add.py [-h] val1 val2 invalid value for val2: must be an integer (invalid literal for int() with base 10: 'not-a-number') Note if a parameter does not specify a type, arc implicitly types it as str .","title":"Types Intro"},{"location":"usage/presentation/coloring/","text":"Spice up your script's output with some color! arc implements support for the basic ANSI-16 color scheme, and rgb / hex colors codes The reference contains a full breakdown of all the constants and methods Ansi Codes \u00b6 ANSI escape codes are defined as constants on the fg , bg and fx classes import arc from arc import color @arc . command def command (): arc . print ( f \" { color . fg . RED } This will be in red! { color . fx . CLEAR } \" ) command () RGB \u00b6 Create new colors using fg . rgb () and bg . rgb () import arc from arc import color mauve = color . fg . rgb ( 183 , 132 , 167 ) arc . print ( f \" { mauve } This string will be in mauve { color . fx . CLEAR } \" ) Hex \u00b6 Create new colors using fg . hex () and bg . hex () import arc from arc import color light_purple = color . fg . hex ( \"#c6b3e2\" ) arc . print ( f \" { light_purple } This string will be in light purple { color . fx . CLEAR } \" ) colorize() \u00b6 arc . color . colorize () applies an arbitrary number of colors / effects to the provided string, and adds fx.CLEAR to the end of the string. It can make applying a bunch of different effects to a string a little cleaner than just appending them to the start of a string. Using this is essentially up to personal preference. import arc from arc.color import colorize , fg , bg , fx arc . print ( colorize ( 'This is a colored string' , fg . RED , bg . GREY , fx . UNDERLINE )) # As opposed to: arc . print ( f \" { fg . RED }{ bg . GREY }{ fx . UNDERLINE } This is a colored string { fx . CLEAR } ) Configured arc Colors \u00b6 arc also colors some of it's own output using the colors defined in config . present . color . You may configure these colors to your liking by setting them in your arc . configure () call. The following colors are configurable with the builtin in ColorConfig class: import arc arc . configure ( present = arc . PresentConfig ( color = arc . ColorConfig ( accent = arc . fg . GREEN , error = arc . fg . RED , highlight = arc . fg . WHITE , ) ) )","title":"Coloring"},{"location":"usage/presentation/coloring/#ansi-codes","text":"ANSI escape codes are defined as constants on the fg , bg and fx classes import arc from arc import color @arc . command def command (): arc . print ( f \" { color . fg . RED } This will be in red! { color . fx . CLEAR } \" ) command ()","title":"Ansi Codes"},{"location":"usage/presentation/coloring/#rgb","text":"Create new colors using fg . rgb () and bg . rgb () import arc from arc import color mauve = color . fg . rgb ( 183 , 132 , 167 ) arc . print ( f \" { mauve } This string will be in mauve { color . fx . CLEAR } \" )","title":"RGB"},{"location":"usage/presentation/coloring/#hex","text":"Create new colors using fg . hex () and bg . hex () import arc from arc import color light_purple = color . fg . hex ( \"#c6b3e2\" ) arc . print ( f \" { light_purple } This string will be in light purple { color . fx . CLEAR } \" )","title":"Hex"},{"location":"usage/presentation/coloring/#colorize","text":"arc . color . colorize () applies an arbitrary number of colors / effects to the provided string, and adds fx.CLEAR to the end of the string. It can make applying a bunch of different effects to a string a little cleaner than just appending them to the start of a string. Using this is essentially up to personal preference. import arc from arc.color import colorize , fg , bg , fx arc . print ( colorize ( 'This is a colored string' , fg . RED , bg . GREY , fx . UNDERLINE )) # As opposed to: arc . print ( f \" { fg . RED }{ bg . GREY }{ fx . UNDERLINE } This is a colored string { fx . CLEAR } )","title":"colorize()"},{"location":"usage/presentation/coloring/#configured-arc-colors","text":"arc also colors some of it's own output using the colors defined in config . present . color . You may configure these colors to your liking by setting them in your arc . configure () call. The following colors are configurable with the builtin in ColorConfig class: import arc arc . configure ( present = arc . PresentConfig ( color = arc . ColorConfig ( accent = arc . fg . GREEN , error = arc . fg . RED , highlight = arc . fg . WHITE , ) ) )","title":"Configured arc Colors"},{"location":"usage/presentation/presentation-intro/","text":"arc contains a set of utilties for presenting output to the user. They are all exported from the arc.present package, although some of them are also re-exported in the top-level arc package for convenience. Note These utilites are intedend to be simple, if you need more flexibility / power I would reccomend using something like rich . Here are the sections covered: Printing / Logging Coloring Output Rich Output","title":"Intro"},{"location":"usage/presentation/printing/","text":"Printing \u00b6 arc exports several functions to be used when printing things to the screen: arc . print () - Wrapper around the normal print function that is aware of whether or not stdout is the terminal or not. If it not a terminal, all escape codes will be removed. arc . info () - Wrapper around arc . print () , but writes to stderr instead of stdout. Useful for quick logging purposes arc . err () - Wrapper around arc . print () , but writes to stderr instead of stdout and styled as an error. arc . log () - Wrapper around arc . print () , but writes to stderr instead of stdout and includes a timestamp. Reference Logging \u00b6 arc has a logger setup that will change it's level based on the current enviroment. import arc # Uncomment the below line for the log to # print to the screen. # arc.configure(enviroment=\"development\") @arc . command def command ( ctx : Context ): ctx . logger . info ( 'hello there!' ) command () The levels are: development: INFO production: WARNING You can also set the level to DEBUG by setting arc . configure ( debug = True ) , which takes priority over the enviroment. Note that this will start printing out arc's own debug statements","title":"Printing"},{"location":"usage/presentation/printing/#printing","text":"arc exports several functions to be used when printing things to the screen: arc . print () - Wrapper around the normal print function that is aware of whether or not stdout is the terminal or not. If it not a terminal, all escape codes will be removed. arc . info () - Wrapper around arc . print () , but writes to stderr instead of stdout. Useful for quick logging purposes arc . err () - Wrapper around arc . print () , but writes to stderr instead of stdout and styled as an error. arc . log () - Wrapper around arc . print () , but writes to stderr instead of stdout and includes a timestamp. Reference","title":"Printing"},{"location":"usage/presentation/printing/#logging","text":"arc has a logger setup that will change it's level based on the current enviroment. import arc # Uncomment the below line for the log to # print to the screen. # arc.configure(enviroment=\"development\") @arc . command def command ( ctx : Context ): ctx . logger . info ( 'hello there!' ) command () The levels are: development: INFO production: WARNING You can also set the level to DEBUG by setting arc . configure ( debug = True ) , which takes priority over the enviroment. Note that this will start printing out arc's own debug statements","title":"Logging"},{"location":"usage/presentation/rich-output/","text":"arc has a few utility elements for outputting rich content Box \u00b6 Highligh some output by surrounding it with a border examples/box.py import arc from arc.color import fg from arc.present import Box @arc . command () def command (): arc . print ( Box ( \"Some cool text\" , padding = 2 , color = fg . GREEN )) command () $ python box.py \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 \u2502 \u2502 Some cool text \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Table \u00b6 Display formatted tabular data examples/table.py import arc from arc.present import Table @arc . command def command (): t = Table ([ \"Name\" , \"Age\" , \"Stand\" ]) t . add_row ([ \"Jonathen Joestar\" , 20 , \"-\" ]) t . add_row ([ \"Joseph Joestar\" , 18 , \"Hermit Purple (in Part 3)\" ]) t . add_row ([ \"Jotaro Kujo\" , 18 , \"Star Platinum\" ]) t . add_row ([ \"Josuke Higashikata\" , 16 , \"Crazy Diamond\" ]) t . add_row ([ \"Giorno Giovanna\" , 15 , \"Gold Experience\" ]) t . add_row ([ \"Joylene Kujo\" , 19 , \"Stone Free\" ]) arc . print ( t ) command () $ python table.py \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Name \u2503 Age \u2503 Stand \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 Jonathen Joestar \u2502 20 \u2502 - \u2502 \u2502 Joseph Joestar \u2502 18 \u2502 Hermit Purple (in Part 3) \u2502 \u2502 Jotaro Kujo \u2502 18 \u2502 Star Platinum \u2502 \u2502 Josuke Higashikata \u2502 16 \u2502 Crazy Diamond \u2502 \u2502 Giorno Giovanna \u2502 15 \u2502 Gold Experience \u2502 \u2502 Joylene Kujo \u2502 19 \u2502 Stone Free \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Rich Output"},{"location":"usage/presentation/rich-output/#box","text":"Highligh some output by surrounding it with a border examples/box.py import arc from arc.color import fg from arc.present import Box @arc . command () def command (): arc . print ( Box ( \"Some cool text\" , padding = 2 , color = fg . GREEN )) command () $ python box.py \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 \u2502 \u2502 Some cool text \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"Box"},{"location":"usage/presentation/rich-output/#table","text":"Display formatted tabular data examples/table.py import arc from arc.present import Table @arc . command def command (): t = Table ([ \"Name\" , \"Age\" , \"Stand\" ]) t . add_row ([ \"Jonathen Joestar\" , 20 , \"-\" ]) t . add_row ([ \"Joseph Joestar\" , 18 , \"Hermit Purple (in Part 3)\" ]) t . add_row ([ \"Jotaro Kujo\" , 18 , \"Star Platinum\" ]) t . add_row ([ \"Josuke Higashikata\" , 16 , \"Crazy Diamond\" ]) t . add_row ([ \"Giorno Giovanna\" , 15 , \"Gold Experience\" ]) t . add_row ([ \"Joylene Kujo\" , 19 , \"Stone Free\" ]) arc . print ( t ) command () $ python table.py \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Name \u2503 Age \u2503 Stand \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 Jonathen Joestar \u2502 20 \u2502 - \u2502 \u2502 Joseph Joestar \u2502 18 \u2502 Hermit Purple (in Part 3) \u2502 \u2502 Jotaro Kujo \u2502 18 \u2502 Star Platinum \u2502 \u2502 Josuke Higashikata \u2502 16 \u2502 Crazy Diamond \u2502 \u2502 Giorno Giovanna \u2502 15 \u2502 Gold Experience \u2502 \u2502 Joylene Kujo \u2502 19 \u2502 Stone Free \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Table"}]}